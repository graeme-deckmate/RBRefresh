`,$r=i=>(i==null?void 0:i.image_url)||(i==null?void 0:i.image)||null,Ur=i=>(i.power.Body||0)+(i.power.Calm||0)+(i.power.Chaos||0)+(i.power.Fury||0)+(i.power.Mind||0)+(i.power.Order||0)+(i.power.Colorless||0),x1=i=>{const r=[],f=["Body","Calm","Chaos","Fury","Mind","Order","Colorless"];for(const u of f)r.push(`${u[0]}:${i.power[u]||0}`);return r.join(" ")},E1=(i,r,f)=>{A&&(!Ye(i)||!Ol(A)||(Ze({type:"HIDE_CARD",player:i,cardInstanceId:r,battlefieldIndex:f,autoPay:fs}),P(null),ri({cardId:null,battlefieldIndex:null})))},Dy=(i,r,f,u)=>{A&&(!Ye(i)||!Wc(A)||f.length!==0&&(Ze({type:"STANDARD_MOVE",player:i,from:r,unitIds:f,to:u}),E(null),Wn({from:null,unitIds:[],to:null})))},jt=({card:i,facedown:r,size:f="md",selected:u,dimmed:h,showReadyDot:p,targetId:b,targetLegal:m,targetSelected:v,targetSlotLabel:C,onClick:w,onDoubleClick:K})=>{const X=r?null:$r(i),oe=["rb-card",f==="md"?"":f==="sm"?" rb-card--sm":" rb-card--xs",r?" rb-cardFaceDown":"",u?" rb-cardSelected":"",m?" rb-targetLegal":"",v?" rb-targetSelected":"",F===b?" rb-targetHover":""].join(""),H=i.type==="Unit"?`${$e(i,{role:"NONE",game:A})}`:i.type==="Spell"?"Spell":i.type==="Gear"?"Gear":i.type,O=$=>{if(!r&&s1(i)){$&&typeof $.stopPropagation=="function"&&$.stopPropagation();return}w&&w()};return o.jsxs("div",{className:oe,ref:$=>{b&&Al(b,$)},"data-target-key":b||void 0,style:{opacity:h?.55:1,cursor:w||m?"pointer":"default"},onMouseEnter:()=>{r||Bt(i),b&&m&&se(b)},onMouseLeave:()=>{Bt($=>$&&$.instanceId===i.instanceId?null:$),b&&se($=>$===b?null:$)},onClick:O,onDoubleClick:K,children:[X?o.jsx("img",{src:X,alt:i.name}):null,r?null:o.jsx("div",{className:"rb-cardBadge",children:H}),p?o.jsx("div",{className:`rb-readyDot ${i.isReady?"":"rb-exhaustedDot"}`}):null,!r&&i.type==="Unit"&&i.buffs>0?o.jsx("div",{className:"rb-buffToken",children:"B"}):null,!r&&i.type==="Unit"?o.jsxs("div",{className:"rb-cardStat",children:[o.jsxs("span",{children:["M",$e(i,{role:"NONE",game:A})]}),o.jsxs("span",{children:["D",i.damage]})]}):null,C?o.jsx("div",{className:"rb-targetSlotBadge",children:C}):null]})},T1=()=>{var Tt,Ci,$a,Ua,Ga;if(!A)return null;const i=rt,r=Mt(i),f=A.players[i],u=A.players[r],h=_d(A,i),p=f.hand.find(pe=>pe.instanceId===Ma)||null,b=Nc(A,Xe),m=(b==null?void 0:b.type)==="Spell"?ut(((Tt=b.ability)==null?void 0:Tt.effect_text)||"",{here:(Xe==null?void 0:Xe.from)==="FACEDOWN"}):{kind:"NONE"},v=ot.filter(pe=>pe.kind!=="NONE").length,C=m.count??1,w=m.kind==="UNIT_FRIENDLY_AND_ENEMY"||m.kind==="UNIT_FRIENDLY_IN_BASE_AND_BATTLEFIELD"||m.kind==="UNIT_AND_GEAR_FRIENDLY"||m.kind==="UNIT_AND_GEAR_SAME_CONTROLLER",K=m.kind==="NONE"?!0:w?((Ci=ot[0])==null?void 0:Ci.kind)!=="NONE"&&(($a=ot[1])==null?void 0:$a.kind)!=="NONE":m.optional?v<=C:v>=C,X=jd(b,Xe),q=!X||!!hs,oe=!!Xe&&!!b&&rt===Xe.player&&Ye(Xe.player)&&q&&K,H=A.turnPlayer===i,O=Ye(i)&&A.turnPlayer===i&&A.chain.length===0&&A.windowKind==="NONE"&&A.state==="OPEN"&&A.step!=="GAME_OVER",$=!Xe&&!At&&A.priorityPlayer===i&&(A.state==="CLOSED"||A.windowKind!=="NONE"||A.chain.length>0),j=At&&(A.chain.find(pe=>pe.id===At.chainItemId)||A.chain[A.chain.length-1])||null,ue=(j==null?void 0:j.targetRequirement)||{kind:"NONE"},ve=ot.filter(pe=>pe.kind!=="NONE").length,he=ue.count??1,Y=ue.kind==="UNIT_FRIENDLY_AND_ENEMY"||ue.kind==="UNIT_FRIENDLY_IN_BASE_AND_BATTLEFIELD"||ue.kind==="UNIT_AND_GEAR_FRIENDLY"||ue.kind==="UNIT_AND_GEAR_SAME_CONTROLLER",ge=ue.kind==="NONE"?!0:Y?((Ua=ot[0])==null?void 0:Ua.kind)!=="NONE"&&((Ga=ot[1])==null?void 0:Ga.kind)!=="NONE":ue.optional?ve<=he:ve>=he,R=!!j&&rt===j.controller&&Ye(j.controller)&&ue.kind!=="NONE"&&ge,W=At?ve:Xe?v:0,I=R||oe,Z=A.step==="MULLIGAN",ee=new Set(f.mulliganSelectedIds),de=H&&Wc(A)&&Ye(i),Re=H&&Ol(A)&&Ye(i),Se=n1(),G=pe=>Se.legalKeys.has(pe),be=pe=>Se.selectedKeys.has(pe),ne=pe=>Se.slotLabelByKey[pe]||null,te=Se.sourceKey&&Ie[Se.sourceKey]?Ie[Se.sourceKey]:{x:Math.max(30,Math.floor(Qe.width/2)),y:28},Oe=Array.from(Se.selectedKeys).map(pe=>({key:pe,center:Ie[pe]||null,label:ne(pe)})).filter(pe=>!!pe.center),Pe=(()=>{if(!ae)return null;if(ae==="PENDING_PLAY")return b?{id:"PENDING_PLAY",label:`Play ${b.name}`,targets:ot}:null;const pe=A.chain.find(ke=>ke.id===ae);return pe?{id:pe.id,label:pe.label,targets:pe.targets||[]}:null})(),et=Pe?(Pe.targets||[]).filter(pe=>pe&&pe.kind!=="NONE").map(pe=>{const ke=Yd(pe),_=Ie[ke]||null;return _?{key:ke,center:_}:null}).filter(Boolean):[],Le=Pe?`SRCCHAIN:${Pe.id}`:null,Ge=Le&&Ie[Le]||{x:Math.max(24,Qe.width-30),y:40},ht=Se.active||et.length>0,Ut=(pe,ke)=>({id:`ZONE_BACK_${ke}_${pe}`,name:ke,domain:"Colorless",cost:0,type:"Spell",stats:{might:null,power:null},tags:[],ability:void 0,rarity:"Unknown",image:void 0,image_url:void 0,instanceId:`ZONE_BACK_${pe}_${ke}`,owner:pe,controller:pe,isReady:!1,damage:0,buffs:0,tempMightBonus:0,stunned:!1,stunnedUntilTurn:0,moveCountThisTurn:0,conditionalKeywords:[],createdTurn:0}),it=(pe,ke)=>{const _=A.players[pe],U=Ut(pe,"Main Deck"),ie=_.trash.length>0?_.trash[_.trash.length-1]:null,J=_.legend?{..._.legend,instanceId:`legend_${pe}`,owner:pe,controller:pe,isReady:_.legendReady,damage:0,buffs:0,tempMightBonus:0,stunned:!1,createdTurn:0}:null;return o.jsxs("div",{className:"rb-playerInfoGrid",children:[o.jsxs("div",{className:"rb-playerInfoCell",children:[o.jsxs("div",{className:"rb-zoneLabel",children:["Main Deck (",_.mainDeck.length,")"]}),o.jsx(jt,{card:U,facedown:!0,size:"xs",showReadyDot:!1})]}),o.jsxs("div",{className:"rb-playerInfoCell",children:[o.jsx("div",{className:"rb-zoneLabel",children:"Legend"}),J?o.jsxs(o.Fragment,{children:[o.jsx(jt,{card:J,size:"xs",showReadyDot:!0,onClick:()=>Bt(_.legend)}),ke?o.jsx("button",{className:"rb-miniButton",disabled:!Ye(pe)||A.priorityPlayer!==pe||!_.legendReady||!h.ok,onClick:()=>Ze({type:"LEGEND_ACTIVATE",player:pe,autoPay:fs}),children:"Activate"}):null]}):o.jsx("span",{className:"rb-softText",children:"—"})]}),o.jsxs("div",{className:"rb-playerInfoCell",children:[o.jsxs("div",{className:"rb-zoneLabel",children:["Discard (",_.trash.length,")"]}),ie?o.jsx(jt,{card:ie,size:"xs",showReadyDot:!1,onClick:()=>ks({player:pe,zone:"TRASH"})}):o.jsx(jt,{card:Ut(pe,"Discard"),facedown:!0,size:"xs",showReadyDot:!1,onClick:()=>ks({player:pe,zone:"TRASH"})})]}),o.jsxs("div",{className:"rb-playerInfoCell",children:[o.jsx("div",{className:"rb-zoneLabel",children:"Champion"}),_.championZone?o.jsx(jt,{card:_.championZone,size:"xs",showReadyDot:!1,onDoubleClick:()=>{ke&&Fd(pe)},onClick:()=>{ke&&Fd(pe)}}):o.jsx("span",{className:"rb-softText",children:"—"})]})]})},mt=()=>{const pe=Ut(r,"Rune Deck");return o.jsxs("div",{className:"rb-playerLaneTop rb-handLane",children:[o.jsxs("div",{className:"rb-handAux rb-handAuxLeft",children:[o.jsxs("div",{className:"rb-zoneLabel",children:[r," Runes In Play"]}),o.jsxs("div",{className:"rb-row rb-rowTight",children:[u.runesInPlay.length===0?o.jsx("span",{className:"rb-softText",children:"—"}):null,u.runesInPlay.map(ke=>o.jsx(jt,{card:ke,size:"xs",showReadyDot:!0,onClick:()=>Bt(ke)},ke.instanceId))]}),o.jsxs("div",{className:"rb-zoneLabel",style:{marginTop:8},children:["Rune Deck (",u.runeDeck.length,")"]}),o.jsx("div",{className:"rb-row rb-rowCenter",children:o.jsx(jt,{card:pe,facedown:!0,size:"xs",showReadyDot:!1})})]}),o.jsxs("div",{className:"rb-handCenter",children:[o.jsxs("div",{className:"rb-zoneLabel",children:[r," Hand (",u.hand.length,")"]}),o.jsxs("div",{className:"rb-faceDownHandRow",children:[u.hand.length===0?o.jsx("span",{className:"rb-softText",children:"—"}):null,Array.from({length:u.hand.length}).map((ke,_)=>o.jsx(jt,{card:Ut(r,`Hand ${_+1}`),facedown:!0,size:"xs",showReadyDot:!1},`opp_hand_back_${_}`))]})]}),o.jsx("div",{className:"rb-handAux rb-handAuxRight",children:it(r,!1)})]})},Jt=(pe,ke)=>{const _=`UNIT:${pe.owner}:${pe.instanceId}`,U=pe.attachedGear||[];return o.jsxs("div",{className:"rb-unitStack",children:[o.jsx(jt,{card:pe,size:"xs",selected:!!(ke!=null&&ke.selected),showReadyDot:!0,targetId:_,targetLegal:G(_),targetSelected:be(_),targetSlotLabel:ne(_),onClick:()=>{if(ke!=null&&ke.clickable&&(ke!=null&&ke.onUnitClick)){ke.onUnitClick();return}Bt(pe)},onDoubleClick:()=>{ke!=null&&ke.onUnitDoubleClick?ke.onUnitDoubleClick():Bt(pe)}}),U.length>0?o.jsx("div",{className:"rb-attachedGearFan",children:U.map((ie,J)=>{const re=`GEAR:${ie.owner}:${ie.instanceId}`;return o.jsx("div",{className:"rb-attachedGearSlot",style:{"--rb-gear-fan-index":J},children:o.jsx(jt,{card:ie,size:"xs",showReadyDot:!0,targetId:re,targetLegal:G(re),targetSelected:be(re),targetSlotLabel:ne(re),onClick:()=>Bt(ie)})},`${pe.instanceId}_attached_${ie.instanceId}`)})}):null]},(ke==null?void 0:ke.key)||pe.instanceId)},Nn=({idx:pe})=>{const ke=A.battlefields[pe],_=!!k&&Re&&ke.controller===i&&(!ke.facedown||Vc(ke)&&!ke.facedownExtra),U=!!g&&de&&!(g.from.kind==="BF"&&g.from.index===pe),ie=!!Xe&&Xe.player===i&&!!b&&b.type==="Unit"&&Xe.from!=="FACEDOWN"&&ke.controller===i,J=ke.controller?`Controlled by ${ke.controller}`:"Uncontrolled",re=ke.contestedBy?`• Contested by ${ke.contestedBy}`:"",Me=`BATTLEFIELD:${pe}`,qe=G(Me),dt=be(Me),Wt=F===Me,nt=ne(Me);return o.jsxs("div",{ref:He=>Al(Me,He),"data-target-key":Me,className:["rb-bf",qe?"rb-targetLegal":"",dt?"rb-targetSelected":"",Wt?"rb-targetHover":""].filter(Boolean).join(" "),style:{boxShadow:dt?"0 0 0 2px rgba(250, 210, 100, 0.85), 0 0 22px rgba(250, 210, 100, 0.28), 0 20px 60px rgba(0,0,0,0.35)":qe?"0 0 0 2px rgba(120, 215, 255, 0.55), 0 0 18px rgba(120, 215, 255, 0.22), 0 20px 60px rgba(0,0,0,0.35)":ie?"0 0 0 2px rgba(140, 220, 170, 0.60), 0 0 18px rgba(120, 220, 160, 0.22), 0 20px 60px rgba(0,0,0,0.35)":_?"0 0 0 2px rgba(120, 255, 200, 0.35), 0 20px 60px rgba(0,0,0,0.35)":U?"0 0 0 2px rgba(130, 210, 255, 0.30), 0 20px 60px rgba(0,0,0,0.35)":void 0},onMouseEnter:()=>{qe&&se(Me)},onMouseLeave:()=>{se(He=>He===Me?null:He)},onClick:()=>{if(!Ud({kind:"BATTLEFIELD",index:pe})){if(ie){ps({kind:"BF",index:pe});return}_?E1(i,k,pe):U&&Dy(i,g.from,g.unitIds,{kind:"BF",index:pe})}},children:[o.jsxs("div",{className:"rb-bfHeader",children:[o.jsxs("div",{style:{minWidth:0},children:[o.jsx("div",{className:"rb-bfName",children:ke.card.name}),o.jsxs("div",{className:"rb-bfMeta",children:["BF ",pe+1," • ",J," ",re]})]}),o.jsx("div",{className:"rb-bfControllerBadge",children:ke.controller??"—"})]}),nt?o.jsx("div",{className:"rb-targetSlotBadge rb-targetSlotBadgeStatic",children:nt}):null,o.jsxs("div",{className:"rb-bfBody",children:[o.jsxs("div",{className:"rb-bfSide",children:[o.jsx("div",{className:"rb-zoneLabel",children:"Battlefield"}),o.jsx(jt,{card:{...ke.card,owner:ke.owner,createdTurn:0,instanceId:`bf_${pe}`,controller:ke.owner,isReady:!0,damage:0,buffs:0,tempMightBonus:0,stunned:!1},size:"sm",showReadyDot:!1,onClick:()=>Bt(ke.card)}),o.jsx("div",{className:"rb-zoneLabel",children:"Facedown"}),ke.facedown||ke.facedownExtra?o.jsxs("div",{style:{display:"flex",flexDirection:"column",gap:6},children:[ke.facedown?o.jsx(jt,{card:ke.facedown.card,facedown:!(Ws||rt===ke.facedown.owner),size:"sm",showReadyDot:!1,onDoubleClick:()=>Rl(ke.facedown.owner,pe,ke.facedown.card.instanceId),onClick:()=>Rl(ke.facedown.owner,pe,ke.facedown.card.instanceId)}):null,ke.facedownExtra?o.jsx(jt,{card:ke.facedownExtra.card,facedown:!(Ws||rt===ke.facedownExtra.owner),size:"sm",showReadyDot:!1,onDoubleClick:()=>Rl(ke.facedownExtra.owner,pe,ke.facedownExtra.card.instanceId),onClick:()=>Rl(ke.facedownExtra.owner,pe,ke.facedownExtra.card.instanceId)}):null]}):o.jsx("div",{className:"rb-softText",style:{fontSize:12},children:"—"})]}),o.jsxs("div",{children:[o.jsxs("div",{className:"rb-zoneLabel",children:[r," units"]}),o.jsxs("div",{className:"rb-row rb-rowTight",children:[ke.units[r].length===0?o.jsx("span",{className:"rb-softText",children:"—"}):null,ke.units[r].map(He=>Jt(He))]}),o.jsxs("div",{className:"rb-zoneLabel",children:[r," gear"]}),o.jsxs("div",{className:"rb-row rb-rowTight",children:[ke.gear[r].length===0?o.jsx("span",{className:"rb-softText",children:"—"}):null,ke.gear[r].map(He=>o.jsx(jt,{card:He,size:"xs",showReadyDot:!0,targetId:`GEAR:${He.owner}:${He.instanceId}`,targetLegal:G(`GEAR:${He.owner}:${He.instanceId}`),targetSelected:be(`GEAR:${He.owner}:${He.instanceId}`),targetSlotLabel:ne(`GEAR:${He.owner}:${He.instanceId}`),onClick:()=>Bt(He)},He.instanceId))]}),o.jsx("div",{style:{height:10}}),o.jsxs("div",{className:"rb-zoneLabel",children:[i," units"]}),o.jsxs("div",{className:"rb-row rb-rowTight",children:[ke.units[i].length===0?o.jsx("span",{className:"rb-softText",children:"—"}):null,ke.units[i].map(He=>{const Nt=(g==null?void 0:g.unitIds.includes(He.instanceId))??!1,ss=de&&He.isReady;return Jt(He,{selected:Nt,clickable:ss,onUnitClick:()=>{E(_s=>{const Gn={kind:"BF",index:pe};if(!_s||_s.from.kind!=="BF"||_s.from.index!==pe)return{from:Gn,unitIds:[He.instanceId]};const zn=new Set(_s.unitIds);zn.has(He.instanceId)?zn.delete(He.instanceId):zn.add(He.instanceId);const Zs=Array.from(zn);return Zs.length===0?null:{..._s,unitIds:Zs}})},onUnitDoubleClick:()=>Bt(He)})})]}),o.jsx("div",{style:{height:10}}),o.jsxs("div",{className:"rb-zoneLabel",children:[i," gear"]}),o.jsxs("div",{className:"rb-row rb-rowTight",children:[ke.gear[i].length===0?o.jsx("span",{className:"rb-softText",children:"—"}):null,ke.gear[i].map(He=>o.jsx(jt,{card:He,size:"xs",showReadyDot:!0,targetId:`GEAR:${He.owner}:${He.instanceId}`,targetLegal:G(`GEAR:${He.owner}:${He.instanceId}`),targetSelected:be(`GEAR:${He.owner}:${He.instanceId}`),targetSlotLabel:ne(`GEAR:${He.owner}:${He.instanceId}`),onClick:()=>Bt(He)},He.instanceId))]})]})]})]})},In=({pid:pe})=>{const ke=A.players[pe];return o.jsxs("div",{children:[o.jsxs("div",{className:"rb-zoneLabel",children:[pe," base"]}),o.jsxs("div",{className:"rb-row rb-rowTight",children:[ke.base.units.map(_=>o.jsxs("div",{style:{display:"flex",flexDirection:"column",gap:4,alignItems:"center"},children:[Jt(_,{selected:pe===i?g==null?void 0:g.unitIds.includes(_.instanceId):!1,clickable:pe===i&&de&&_.isReady,onUnitClick:()=>{E(U=>{const ie={kind:"BASE"};if(!U||U.from.kind!=="BASE")return{from:ie,unitIds:[_.instanceId]};const J=new Set(U.unitIds);J.has(_.instanceId)?J.delete(_.instanceId):J.add(_.instanceId);const re=Array.from(J);return re.length===0?null:{...U,unitIds:re}})},onUnitDoubleClick:()=>Bt(_)}),pe===i&&Br(_)&&_.buffs&&_.buffs>0&&o.jsx("button",{className:"rb-miniButton",style:{fontSize:9},disabled:!Ye(i),onClick:()=>Ze({type:"SPEND_MY_BUFF_ACTIVATE",player:i,unitInstanceId:_.instanceId}),children:"Spend buff"})]},_.instanceId)),ke.base.gear.map(_=>{const U=oc(_),ie=Ka(_,ke.domains);return o.jsxs("div",{style:{display:"flex",flexDirection:"column",gap:4,alignItems:"center"},children:[o.jsx(jt,{card:_,size:"xs",showReadyDot:!0,targetId:`GEAR:${_.owner}:${_.instanceId}`,targetLegal:G(`GEAR:${_.owner}:${_.instanceId}`),targetSelected:be(`GEAR:${_.owner}:${_.instanceId}`),targetSlotLabel:ne(`GEAR:${_.owner}:${_.instanceId}`),onClick:()=>Bt(_)}),pe===i&&ie?o.jsx("button",{className:"rb-miniButton",style:{fontSize:9},disabled:!Ye(i)||!_.isReady,onClick:()=>yy(i,_.instanceId),children:"Exhaust (Seal)"}):null,pe===i&&U?o.jsx("button",{className:"rb-miniButton",style:{fontSize:9},disabled:!Ye(i)||U.cost.exhaustSelf&&!_.isReady,onClick:()=>Ze({type:"GEAR_ACTIVATE",player:i,gearInstanceId:_.instanceId,autoPay:fs}),children:"Activate"}):null,pe===i&&Es(_)?o.jsx("button",{className:"rb-miniButton",style:{fontSize:9},disabled:!Ye(i)||!_.isReady,onClick:()=>Ze({type:"EQUIP_START",player:i,gearInstanceId:_.instanceId}),children:"Equip"}):null,pe===i&&!U&&lc(_)?o.jsx("button",{className:"rb-miniButton",style:{fontSize:9},disabled:!Ye(i),onClick:()=>Ze({type:"KILL_GEAR_ACTIVATE",player:i,gearInstanceId:_.instanceId}),children:"Kill this"}):null]},_.instanceId)}),ke.base.units.length===0&&ke.base.gear.length===0?o.jsx("span",{className:"rb-softText",children:"—"}):null]})]})},Ps=()=>{const pe=f,ke=!!k,_=[{key:"MULLIGAN",label:"Mulligan"},{key:"AWAKEN",label:"Awaken"},{key:"BEGINNING",label:"Beginning"},{key:"CHANNEL",label:"Channel"},{key:"DRAW",label:"Draw"},{key:"ACTION",label:"Action"},{key:"ENDING",label:"Ending"}],U=(()=>{switch(A.step){case"SETUP":return 0;case"MULLIGAN":return 0;case"AWAKEN":return 1;case"SCORING":return 2;case"CHANNEL":return 3;case"DRAW":return 4;case"ACTION":return 5;case"ENDING":return 6;case"GAME_OVER":return 6;default:return 0}})(),ie=Ut(i,"Rune Deck");return o.jsxs("div",{className:"rb-playerLaneBottom rb-handLane",children:[o.jsxs("div",{className:"rb-handAux rb-handAuxLeft",children:[o.jsx("div",{className:"rb-zoneLabel",children:"Runes in play"}),o.jsxs("div",{className:"rb-row rb-rowTight",children:[f.runesInPlay.length===0?o.jsx("span",{className:"rb-softText",children:"—"}):null,f.runesInPlay.map(J=>{var Wt;const re=Rr==null?void 0:Rr.plan.runeUses[J.instanceId],Me=$r(J),qe=["rb-rune",J.isReady?"":"rb-runeExhausted",re==="EXHAUST"?"rb-runeGlowExhaust":"",re==="RECYCLE"?"rb-runeGlowRecycle":"",re==="BOTH"?"rb-runeGlowBoth":""].filter(Boolean).join(" "),dt=re==="EXHAUST"?"E":re==="RECYCLE"?"P":re==="BOTH"?"E+P":((Wt=J.domain)==null?void 0:Wt[0])||"R";return o.jsxs("div",{className:qe,title:`${J.name||"Rune"} (${J.domain}) • Left-click: Exhaust (+1 Energy) • Right-click: Recycle (+1 Power)`,onClick:()=>hy(i,J.instanceId),onContextMenu:nt=>{nt.preventDefault(),py(i,J.instanceId)},children:[Me?o.jsx("img",{src:Me,alt:J.name||J.domain}):o.jsx("div",{children:J.domain}),o.jsx("div",{className:`rb-readyDot ${J.isReady?"":"rb-exhaustedDot"}`}),o.jsx("div",{className:"rb-runeHint",children:dt})]},J.instanceId)})]}),o.jsx("div",{className:"rb-actionHint",style:{marginTop:8},children:"Left-click Exhaust (+1E), right-click Recycle (+1P)."}),o.jsxs("div",{className:"rb-zoneLabel",style:{marginTop:8},children:["Rune Deck (",f.runeDeck.length,"/12)"]}),o.jsx("div",{className:"rb-row rb-rowCenter",children:o.jsx(jt,{card:ie,facedown:!0,size:"xs",showReadyDot:!1})})]}),o.jsxs("div",{className:"rb-handCenter",children:[o.jsxs("div",{className:"rb-zoneLabel",children:["Hand (",pe.hand.length,") ",Z?"• Mulligan: click up to 2 cards":""]}),o.jsxs("div",{className:"rb-hand",children:[pe.hand.length===0?o.jsx("span",{className:"rb-softText",children:"—"}):null,pe.hand.map((J,re)=>{const Me=Z&&ee.has(J.instanceId),qe=Ma===J.instanceId,dt=Z?Me:qe,Wt=re<=1?"rb-handSlotEdgeLeft":re>=pe.hand.length-2?"rb-handSlotEdgeRight":"",nt=(pe.hand.length-1)/2,He=Math.max(5,Math.min(13,38/Math.max(1,pe.hand.length/2))),Nt=(re-nt)*He,ss=Math.round(Math.abs(re-nt)*2),_s={"--rb-hand-rot":`${Nt}deg`,"--rb-hand-lift":`${ss}px`,zIndex:Xo===J.instanceId?240:re+10};return o.jsx("div",{className:`rb-handSlot ${Wt} ${Xo===J.instanceId?"rb-handSlotHover":""}`,style:_s,onMouseEnter:()=>{if(kr(J.instanceId),!fs||!A||!Ye(i)||Z)return;if(qc(J,A,i)){Ba(null);return}const zn=(()=>{const rn=Qt(J.domain).map(vt);return rn.length===0||rn.includes("Colorless")?f.domains:rn})(),Zs=Vr(f.runePool,f.runesInPlay,{energyNeed:J.cost,basePowerNeed:J.stats.power||0,powerDomainsAllowed:zn,additionalPowerByDomain:{},additionalPowerAny:0},{sealExhaustedThisTurn:f.sealExhaustedThisTurn,seals:f.base.gear,playerDomains:f.domains});Ba(Zs?{cardInstanceId:J.instanceId,plan:Zs}:null)},onMouseLeave:()=>{kr(Gn=>Gn===J.instanceId?null:Gn),Ba(Gn=>(Gn==null?void 0:Gn.cardInstanceId)===J.instanceId?null:Gn)},children:o.jsx(jt,{card:J,size:Z?"sm":"md",selected:dt,showReadyDot:!1,onClick:()=>{if(Z){gy(i,J.instanceId);return}Zi(J.instanceId),P(null)},onDoubleClick:()=>{Z||Hd(i,J.instanceId)}})},J.instanceId)})]}),o.jsx("div",{className:"rb-actionHint",children:Z?o.jsxs(o.Fragment,{children:[o.jsx("button",{className:"rb-miniButton",disabled:f.mulliganDone,onClick:()=>zd(i),children:f.mulliganDone?"Mulligan Confirmed":`Confirm Mulligan (${f.mulliganSelectedIds.length}/2)`}),o.jsx("div",{className:"rb-softText",style:{marginTop:6},children:"Switch “playing as” to confirm the other player."})]}):A.pendingOptionalChoice?o.jsx("div",{style:{display:"flex",flexDirection:"column",gap:8},children:(()=>{const J=A.pendingOptionalChoice,re=J.min??0,Me=Math.max(re,J.max??re),qe=Math.max(re,Math.min(Me,yn)),Wt=J.player===rt&&Ye(J.player)&&!Ln(J.player),nt=(He,Nt)=>{Ze({type:"OPTIONAL_CHOICE",player:J.player,choiceId:J.id,accept:He,value:Nt})};return o.jsxs(o.Fragment,{children:[o.jsxs("div",{children:[o.jsx("b",{children:"Choice:"})," ",J.prompt]}),Wt?J.kind==="CONFIRM"?o.jsxs("div",{style:{display:"flex",gap:8,flexWrap:"wrap"},children:[o.jsx("button",{className:"rb-miniButton",style:{background:"#16a34a"},onClick:()=>nt(!0),children:"Yes"}),o.jsx("button",{className:"rb-miniButton",style:{background:"#dc2626"},onClick:()=>nt(!1),children:"No"})]}):o.jsxs("div",{style:{display:"flex",gap:8,flexWrap:"wrap",alignItems:"center"},children:[Array.from({length:Math.min(10,Me-re+1)},(He,Nt)=>re+Nt).map(He=>o.jsx("button",{className:"rb-miniButton",style:{background:He===qe?"#2563eb":void 0},onClick:()=>nt(!0,He),children:He},He)),o.jsx("input",{type:"number",min:re,max:Me,value:qe,onChange:He=>{const Nt=parseInt(He.target.value,10);Number.isFinite(Nt)&&yl(Math.max(re,Math.min(Me,Nt)))},style:{width:78}}),o.jsx("button",{className:"rb-miniButton",onClick:()=>nt(!0,qe),children:"Confirm"}),o.jsx("button",{className:"rb-miniButton",onClick:()=>nt(!0,0),children:"Skip (0)"})]}):o.jsxs("div",{className:"rb-softText",children:["Waiting for ",J.player,"..."]})]})})()}):A.pendingCullChoice?o.jsx("div",{style:{display:"flex",flexDirection:"column",gap:8},children:(()=>{const J=A.pendingCullChoice,re=J.order[J.index],Me=re===rt&&Ye(re)&&!Ln(re);return o.jsxs(o.Fragment,{children:[o.jsxs("div",{children:[o.jsx("b",{children:"Cull the Weak:"})," ",re," must choose one of their units."]}),o.jsxs("div",{className:"rb-softText",children:["Use point-and-click only: click one of ",re,"'s units on the board."]}),Me?o.jsx("div",{className:"rb-softText",children:"Clicking the unit immediately confirms the choice."}):o.jsxs("div",{className:"rb-softText",children:["Waiting for ",re,"..."]})]})})()}):A.pendingCandlelitChoice&&A.pendingCandlelitChoice.player===i?o.jsxs("div",{style:{display:"flex",flexDirection:"column",gap:8},children:[o.jsxs("div",{children:[o.jsx("b",{children:"The Candlelit Sanctum:"})," Recycle one or both cards (optional)."]}),(()=>{const J=A.pendingCandlelitChoice,re=J.choices||{},Me=J.cards.filter(nt=>(re[nt.instanceId]||"KEEP")!=="RECYCLE").map(nt=>nt.instanceId),qe=J.order&&J.order.length>0?J.order[0]:Me[0],dt=(nt,He)=>{J.choices={...J.choices,[nt]:He},He==="RECYCLE"&&J.order&&(J.order=J.order.filter(Nt=>Nt!==nt)),s({...A})},Wt=nt=>{const He=J.cards.filter(Nt=>{var ss;return(((ss=J.choices)==null?void 0:ss[Nt.instanceId])||"KEEP")!=="RECYCLE"}).map(Nt=>Nt.instanceId);J.order=[nt,...He.filter(Nt=>Nt!==nt)],s({...A})};return o.jsxs(o.Fragment,{children:[o.jsx("div",{style:{display:"flex",gap:10,flexWrap:"wrap"},children:J.cards.map(nt=>{const He=re[nt.instanceId]||"KEEP",Nt=He!=="RECYCLE";return o.jsxs("div",{style:{display:"flex",flexDirection:"column",gap:6,padding:6,border:"1px solid rgba(255,255,255,0.2)",borderRadius:8},children:[o.jsx(jt,{card:nt,size:"xs",showReadyDot:!1}),o.jsxs("div",{style:{display:"flex",gap:6},children:[o.jsx("button",{className:"rb-miniButton",style:{background:He==="KEEP"?"#16a34a":void 0},onClick:()=>dt(nt.instanceId,"KEEP"),children:"Keep"}),o.jsx("button",{className:"rb-miniButton",style:{background:He==="RECYCLE"?"#dc2626":void 0},onClick:()=>dt(nt.instanceId,"RECYCLE"),children:"Recycle"})]}),Me.length>1&&Nt?o.jsx("button",{className:"rb-miniButton",style:{background:qe===nt.instanceId?"#2563eb":void 0},onClick:()=>Wt(nt.instanceId),children:qe===nt.instanceId?"Top (selected)":"Set as Top"}):null]},nt.instanceId)})}),o.jsxs("div",{style:{display:"flex",gap:8,alignItems:"center"},children:[o.jsx("button",{className:"rb-miniButton",onClick:()=>{const nt=A.pendingCandlelitChoice,He=nt.choices||{},Nt=nt.cards.filter(rn=>(He[rn.instanceId]||"KEEP")!=="RECYCLE"),ss=nt.cards.filter(rn=>(He[rn.instanceId]||"KEEP")==="RECYCLE"),_s=Nt.map(rn=>rn.instanceId),Gn=(nt.order||[]).filter(rn=>_s.includes(rn));for(const rn of _s)Gn.includes(rn)||Gn.push(rn);const zn=Gn.map(rn=>Nt.find(wc=>wc.instanceId===rn)).filter(Boolean),Zs=A.players[nt.player];zn.length>0&&(Zs.mainDeck=zn.concat(Zs.mainDeck)),ss.length>0&&Zs.mainDeck.push(...ss),A.log.unshift(`${nt.player} resolved Candlelit Sanctum (recycled ${ss.length}).`),A.pendingCandlelitChoice=null,s({...A})},children:"Confirm Choices"}),o.jsx("span",{className:"rb-softText",children:"Kept cards return on top in chosen order."})]})]})})()]}):A.pendingWeaponmasterChoice&&A.pendingWeaponmasterChoice.unitOwner===i?o.jsxs("div",{style:{display:"flex",flexDirection:"column",gap:8},children:[o.jsxs("div",{children:[o.jsx("b",{children:"Weaponmaster:"})," You may equip a gear to the unit that just entered play."]}),o.jsxs("div",{style:{display:"flex",gap:6,flexWrap:"wrap"},children:[(()=>{const J=A.pendingWeaponmasterChoice,re=A.players[i];return[...re.hand.filter(qe=>qe.type==="Gear"),...re.base.gear].filter(qe=>J.availableGearIds.includes(qe.instanceId)).map(qe=>o.jsxs("button",{className:"rb-miniButton",onClick:()=>{var Wt;const dt=(Wt=Fe(A,J.unitOwner,J.unitInstanceId))==null?void 0:Wt.unit;if(dt&&qe){const nt=$e(dt,{role:"NONE",game:A}),He=re.hand.findIndex(Nt=>Nt.instanceId===qe.instanceId);if(He>=0)re.hand.splice(He,1);else{const Nt=re.base.gear.findIndex(ss=>ss.instanceId===qe.instanceId);Nt>=0&&re.base.gear.splice(Nt,1)}dt.attachedGear||(dt.attachedGear=[]),dt.attachedGear.push(qe),A.log.unshift(`${qe.name} equipped to ${dt.name} (Weaponmaster).`),$i(A,dt,nt)}A.pendingWeaponmasterChoice=null,s({...A})},children:["Equip ",qe.name]},qe.instanceId))})(),o.jsx("button",{className:"rb-miniButton",onClick:()=>{A.pendingWeaponmasterChoice=null,s({...A})},children:"Skip (No Equip)"})]})]}):A.pendingEquipChoice&&A.pendingEquipChoice.gearOwner===i?o.jsxs("div",{style:{display:"flex",flexDirection:"column",gap:8},children:[o.jsxs("div",{children:[o.jsx("b",{children:"Equip:"})," Select a unit to attach the equipment to."]}),o.jsxs("div",{style:{display:"flex",gap:6,flexWrap:"wrap"},children:[(()=>{const J=A.pendingEquipChoice;return f.base.gear.find(Me=>Me.instanceId===J.gearInstanceId),Rt(A,i).map(Me=>o.jsxs("button",{className:"rb-miniButton",onClick:()=>Ze({type:"EQUIP_CONFIRM",player:i,unitInstanceId:Me.instanceId}),children:[Me.name," (M",$e(Me,{role:"NONE",game:A}),")"]},Me.instanceId))})(),o.jsx("button",{className:"rb-miniButton",onClick:()=>Ze({type:"EQUIP_CANCEL",player:i}),children:"Cancel"})]}),(()=>{var Me;const J=A.pendingEquipChoice,re=f.base.gear.find(qe=>qe.instanceId===J.gearInstanceId);return re?o.jsxs("div",{className:"rb-softText",children:[re.name," (+",((Me=re.stats)==null?void 0:Me.might)||0," might) - Cost: ",J.equipCost.energy>0?`${J.equipCost.energy}E + `:"",J.equipCost.power,"P"]}):null})(),(()=>{const J=A.pendingEquipChoice,re=f.base.gear.filter(Me=>Me.instanceId!==J.gearInstanceId&&Me.isReady).map(Me=>({gear:Me,seal:Ka(Me,f.domains)})).filter(Me=>!!Me.seal);return re.length===0?null:o.jsxs("div",{style:{display:"flex",gap:6,flexWrap:"wrap",alignItems:"center"},children:[o.jsx("span",{className:"rb-softText",children:"Use Seal for Equip:"}),re.map(({gear:Me,seal:qe})=>o.jsxs("button",{className:"rb-miniButton",onClick:()=>Ze({type:"SEAL_EXHAUST",player:i,gearInstanceId:Me.instanceId}),children:[Me.name," (+",qe.amount," ",qe.domain,"P)"]},Me.instanceId))]})})()]}):Xe&&Xe.player===i&&b?o.jsxs("div",{style:{display:"flex",gap:8,alignItems:"center",flexWrap:"wrap"},children:[o.jsxs("span",{children:["Playing: ",o.jsx("b",{children:b.name})]}),X&&!hs?o.jsx("span",{className:"rb-softText",children:"Choose destination by clicking Base or a controlled battlefield."}):null,o.jsx("button",{className:"rb-miniButton",disabled:!oe,onClick:Ay,children:"Put on Chain"}),o.jsx("button",{className:"rb-miniButton",onClick:o1,children:"Cancel"})]}):p?o.jsxs("div",{style:{display:"flex",gap:8,alignItems:"center",flexWrap:"wrap"},children:[o.jsxs("span",{children:["Selected: ",o.jsx("b",{children:p.name})]}),o.jsx("button",{className:"rb-miniButton",disabled:!Ye(i),onClick:()=>Hd(i,p.instanceId),children:"Play"}),It(p,"Hidden")?o.jsx("button",{className:"rb-miniButton",disabled:!Re,onClick:()=>P(J=>J===p.instanceId?null:p.instanceId),children:ke?"Cancel Hide":"Hide → Battlefield"}):null,ke?o.jsx("span",{className:"rb-softText",children:"Click a battlefield you control to place it facedown."}):null]}):o.jsx("span",{className:"rb-softText",children:"Tip: double-click a card to play it."})}),Z?null:o.jsxs("div",{className:"rb-bottomActionBar",children:[o.jsxs("div",{className:"rb-bottomButtons",children:[o.jsx("button",{className:"rb-bigButton",disabled:!O,onClick:()=>Gd(),children:A.step==="ACTION"?"End Turn":"Next Step"}),o.jsx("button",{className:"rb-bigButton rb-bigButtonSecondary",disabled:Xe||At?!I:!$||!Ye(i),onClick:()=>{if(Xe||At){Ry();return}Ic(i)},children:Xe||At?`Confirm Target (${W})`:"Pass"})]}),o.jsx("div",{className:"rb-phaseTrack rb-phaseDots",children:_.map((J,re)=>{const Me=re<=U,qe=re===U?A.turnPlayer===i?"rb-phasePill rb-phasePillActiveMyTurn":"rb-phasePill rb-phasePillActiveOppTurn":Me?"rb-phasePill rb-phasePillDone":"rb-phasePill";return o.jsx("span",{className:qe,title:J.label,children:J.label},J.key)})}),o.jsxs("div",{className:"rb-softText",style:{fontSize:11},children:["Shortcut: press ",o.jsx("b",{children:"Space"})," for Confirm Target/Pass/Next (whichever is currently legal)."]})]})]}),o.jsxs("div",{className:"rb-handAux rb-handAuxRight",children:[it(i,!0),o.jsxs("div",{className:"rb-actionHint",style:{marginTop:8},children:["Points ",f.points,"/",A.victoryScore," • Hand ",f.hand.length," • Main Deck ",f.mainDeck.length]})]})]})},ns=()=>{var _,U,ie,J;if(!Ii)return o.jsx("div",{className:"rb-softText",children:"Hover a card to preview it here."});const pe=Ii,ke=$r(pe);return o.jsx("div",{children:o.jsxs("div",{className:"rb-preview",children:[ke?o.jsx("img",{src:ke,alt:pe.name}):null,o.jsxs("div",{className:"rb-previewText",children:[o.jsx("div",{style:{fontWeight:900,marginBottom:4},children:pe.name}),o.jsxs("div",{className:"rb-softText",style:{marginBottom:6},children:[pe.type," • ",pe.domain," • Cost ",pe.cost,"E",(_=pe.stats)!=null&&_.power?` + ${pe.stats.power}P`:""]}),(ie=(U=pe.ability)==null?void 0:U.keywords)!=null&&ie.length?o.jsxs("div",{style:{marginBottom:6},children:["KW: ",pe.ability.keywords.join(", ")]}):null,(J=pe.ability)!=null&&J.effect_text?o.jsx("div",{children:pe.ability.effect_text}):null]})]})})};return o.jsxs("div",{className:"rb-grid",children:[o.jsxs("div",{className:"rb-panel",children:[o.jsx("div",{className:"rb-panelTitle",children:"Preview"}),ns(),o.jsx("div",{className:"rb-panelTitle",style:{marginTop:12},children:"Log"}),o.jsxs("div",{className:"rb-log",children:[A.log.length===0?o.jsx("div",{className:"rb-softText",children:"—"}):null,A.log.slice(0,30).map((pe,ke)=>o.jsx("div",{style:{padding:"2px 0"},children:pe},ke))]}),o.jsxs("div",{style:{marginTop:10,display:"flex",gap:8,justifyContent:"space-between"},children:[o.jsx("button",{className:"rb-miniButton",onClick:()=>Zt(pe=>pe.log=[]),children:"Clear log"}),o.jsx("button",{className:"rb-miniButton",onClick:()=>Bt(null),children:"Clear preview"})]})]}),o.jsx("div",{className:`rb-board ${A.step==="MULLIGAN"?"rb-boardMulligan":"rb-boardLive"}`,children:o.jsxs("div",{className:"rb-boardInner",ref:sn,children:[Se.active?o.jsx("div",{className:"rb-targetHintPanel",children:Se.slotHints.map((pe,ke)=>o.jsx("div",{className:"rb-targetHintPill",children:pe},`${pe}:${ke}`))}):null,ht?o.jsxs("svg",{className:"rb-targetArrowLayer",width:Qe.width,height:Qe.height,viewBox:`0 0 ${Qe.width} ${Qe.height}`,preserveAspectRatio:"none",children:[o.jsxs("defs",{children:[o.jsx("marker",{id:"rb-targetArrowHead",markerWidth:"10",markerHeight:"8",refX:"8",refY:"4",orient:"auto",children:o.jsx("path",{d:"M 0 0 L 8 4 L 0 8 z",fill:"rgba(255,210,125,0.92)"})}),o.jsx("marker",{id:"rb-chainHoverArrowHead",markerWidth:"10",markerHeight:"8",refX:"8",refY:"4",orient:"auto",children:o.jsx("path",{d:"M 0 0 L 8 4 L 0 8 z",fill:"rgba(120,210,255,0.92)"})})]}),o.jsx("circle",{cx:te.x,cy:te.y,r:5,className:"rb-targetSourceDot"}),Oe.map((pe,ke)=>{const _=pe.center,U=_.x-te.x,ie=_.y-te.y,J=Math.max(26,Math.min(110,Math.abs(U)*.32+Math.abs(ie)*.08)),re=te.x+(U>=0?J:-J),Me=te.y+Math.max(14,Math.abs(ie)*.2),qe=_.x-(U>=0?J:-J),dt=_.y-Math.max(14,Math.abs(ie)*.2);return o.jsx("path",{d:`M ${te.x} ${te.y} C ${re} ${Me}, ${qe} ${dt}, ${_.x} ${_.y}`,className:"rb-targetArrowPath",markerEnd:"url(#rb-targetArrowHead)"},`${pe.key}:${ke}`)}),et.map((pe,ke)=>{const _=pe.center,U=_.x-Ge.x,ie=_.y-Ge.y,J=Math.max(26,Math.min(110,Math.abs(U)*.32+Math.abs(ie)*.08)),re=Ge.x+(U>=0?J:-J),Me=Ge.y+Math.max(14,Math.abs(ie)*.2),qe=_.x-(U>=0?J:-J),dt=_.y-Math.max(14,Math.abs(ie)*.2);return o.jsx("path",{d:`M ${Ge.x} ${Ge.y} C ${re} ${Me}, ${qe} ${dt}, ${_.x} ${_.y}`,className:"rb-targetArrowPath rb-chainHoverArrowPath",markerEnd:"url(#rb-chainHoverArrowHead)"},`chain-hover:${pe.key}:${ke}`)}),et.length>0?o.jsx("circle",{cx:Ge.x,cy:Ge.y,r:5,className:"rb-targetSourceDot rb-chainHoverSourceDot"}):null]}):null,A.chain.length>0||b?o.jsxs("div",{className:"rb-targetSourceStack",children:[b?o.jsxs("div",{ref:pe=>Al("SRCCHAIN:PENDING_PLAY",pe),className:`rb-targetSourceChip ${Xe?"rb-targetSourceChipActive":""}`,children:["Armed Play: ",b.name]}):null,A.chain.map((pe,ke)=>o.jsxs("div",{ref:_=>Al(`SRCCHAIN:${pe.id}`,_),className:`rb-targetSourceChip ${ke===0?"rb-targetSourceChipActive":""}`,children:[ke===0?"Resolving":"Queued",": ",pe.label]},pe.id))]}):null,o.jsxs("div",{className:"rb-hudRow",children:[o.jsxs("div",{className:"rb-hud",children:[o.jsx("div",{className:"rb-avatar",children:u.legend&&$r(u.legend)?o.jsx("img",{src:$r(u.legend),alt:u.legend.name}):null}),o.jsxs("div",{className:"rb-hudText",children:[o.jsxs("div",{className:"rb-hudName",children:[r," — ",u.legend?u.legend.name:"Legend"]}),o.jsxs("div",{className:"rb-hudSub",children:["Points ",u.points,"/",A.victoryScore," • Hand ",u.hand.length," • Deck ",u.mainDeck.length," • ",o.jsxs("button",{className:"rb-miniButton",onClick:()=>ks({player:r,zone:"TRASH"}),children:["Trash ",u.trash.length]})]})]})]}),o.jsxs("div",{style:{textAlign:"right",fontSize:12,opacity:.9},children:[o.jsxs("div",{children:["Turn ",A.turnNumber," • ",o.jsx("b",{children:A.step})]}),o.jsxs("div",{children:["Turn player: ",o.jsx("b",{children:A.turnPlayer})," • Priority: ",o.jsx("b",{children:A.priorityPlayer})]}),o.jsxs("div",{children:["Chain: ",A.chain.length," • State: ",A.state," ",A.windowKind!=="NONE"?`• ${A.windowKind} @ BF${(A.windowBattlefieldIndex??-1)+1}`:""]})]})]}),mt(),o.jsx(In,{pid:r}),o.jsxs("div",{className:"rb-matRow",children:[o.jsx(Nn,{idx:0}),o.jsx(Nn,{idx:1})]}),o.jsxs("div",{style:{border:g&&de?"1px dashed rgba(130, 210, 255, 0.45)":"1px solid rgba(255,255,255,0.10)",borderRadius:16,padding:10,background:"rgba(0,0,0,0.18)"},onClick:()=>{if(Xe&&Xe.player===i&&b&&b.type==="Unit"&&Xe.from!=="FACEDOWN"){ps({kind:"BASE"});return}g&&de&&g.from.kind!=="BASE"&&Dy(i,g.from,g.unitIds,{kind:"BASE"})},children:[o.jsx(In,{pid:i}),g&&de?o.jsxs("div",{className:"rb-actionHint",children:["Move armed: click a battlefield (or this base panel) to move selected ready units."," ",o.jsx("button",{className:"rb-miniButton",onClick:()=>E(null),children:"Cancel move"})]}):null,Xe&&Xe.player===i&&b&&b.type==="Unit"&&Xe.from!=="FACEDOWN"?o.jsxs("div",{className:"rb-actionHint",children:["Play destination armed: click this base panel to set destination to ",o.jsx("b",{children:"Base"}),", or click a controlled battlefield."]}):null]}),Ps()]})}),o.jsxs("div",{className:"rb-panel",children:[o.jsx("div",{className:"rb-panelTitle",children:"Actions"}),Z?o.jsx("button",{className:"rb-bigButton",style:{background:f.mulliganDone?"rgba(90, 200, 130, 0.3)":"linear-gradient(135deg, rgba(80, 160, 255, 0.35) 0%, rgba(60, 130, 220, 0.35) 100%)",borderColor:f.mulliganDone?"rgba(90, 200, 130, 0.6)":"rgba(130, 210, 255, 0.6)"},disabled:f.mulliganDone,onClick:()=>zd(i),children:f.mulliganDone?"✓ Mulligan Confirmed":`Confirm Mulligan (${f.mulliganSelectedIds.length}/2 selected)`}):o.jsx("div",{className:"rb-actionHint",children:"Primary turn controls are now below the hand (MTGA-style action lane)."}),o.jsxs("div",{style:{marginTop:10,display:"flex",gap:8},children:[o.jsx("button",{className:"rb-miniButton",disabled:ai.current.length===0,onClick:i1,children:"Undo"}),o.jsx("button",{className:"rb-miniButton",onClick:()=>E(null),children:"Clear move"}),o.jsx("button",{className:"rb-miniButton",onClick:()=>P(null),children:"Clear hide"})]}),o.jsxs("div",{style:{marginTop:8,display:"flex",gap:8,flexWrap:"wrap"},children:[o.jsx("button",{id:"rb-run-retreat-challenge-repro",className:"rb-miniButton",disabled:!Ye(i),onClick:by,title:"Load and run deterministic Retreat -> Challenge chain repro",children:"Run Retreat->Challenge Repro"}),o.jsx("button",{id:"rb-run-cull-weak-repro",className:"rb-miniButton",disabled:!Ye(i),onClick:my,title:"Load and run deterministic Cull the Weak kill-state repro",children:"Run Cull the Weak Repro"}),o.jsx("button",{id:"rb-run-conditional-audit-repro",className:"rb-miniButton",disabled:!Ye(i),onClick:xy,title:"Run deterministic Sivir/Rek'Sai/Void Hatchling conditional audit repro",children:"Run Conditional Audit Repro"}),o.jsx("button",{id:"rb-run-seal-autopay-repro",className:"rb-miniButton",disabled:!Ye(i),onClick:Ey,title:"Run deterministic Seal-first auto-pay repro",children:"Run Seal Auto-pay Repro"}),o.jsx("button",{id:"rb-run-gold-token-repro",className:"rb-miniButton",disabled:!Ye(i),onClick:Ty,title:"Run deterministic Gold token activation repro",children:"Run Gold Token Repro"}),o.jsx("button",{id:"rb-run-battlefield-audit-repro",className:"rb-miniButton",disabled:!Ye(i),onClick:Ny,title:"Run deterministic pass/fail repro for all battlefield effects",children:"Run Battlefield Audit Repro"}),o.jsx("button",{id:"rb-run-legend-audit-repro",className:"rb-miniButton",disabled:!Ye(i),onClick:Iy,title:"Run deterministic pass/fail repro for all legend effects",children:"Run Legend Audit Repro"}),o.jsx("button",{id:"rb-run-champion-audit-repro",className:"rb-miniButton",disabled:!Ye(i),onClick:vy,title:"Run deterministic pass/fail repro for all champion unit effects",children:"Run Champion Audit Repro"}),o.jsx("button",{id:"rb-run-spell-audit-repro",className:"rb-miniButton",disabled:!Ye(i),onClick:Cy,title:"Run deterministic pass/fail repro for all spell effects",children:"Run Spell Audit Repro"}),o.jsx("button",{id:"rb-run-gear-audit-repro",className:"rb-miniButton",disabled:!Ye(i),onClick:wy,title:"Run deterministic pass/fail repro for all gear effects",children:"Run Gear Audit Repro"})]}),o.jsxs("div",{className:"rb-actionHint",style:{marginTop:10},children:[o.jsxs("div",{children:[o.jsx("b",{children:i})," Pool: ",f.runePool.energy,"E • ",Ur(f.runePool),"P (",x1(f.runePool),")"]}),o.jsx("div",{className:"rb-softText",style:{marginTop:4},children:"Opponent pool hidden in this view (switch “playing as” to see it)."})]}),o.jsxs("div",{style:{marginTop:10},children:[o.jsxs("label",{style:{display:"flex",alignItems:"center",gap:8,fontSize:13},children:[o.jsx("input",{type:"checkbox",checked:fs,onChange:pe=>gd(pe.target.checked)}),"Auto-pay runes on Play"]}),o.jsxs("div",{className:"rb-softText",style:{marginTop:4},children:["Hover a hand card to preview payment: ",o.jsx("span",{style:{opacity:.95},children:"blue = Exhaust"}),", ",o.jsx("span",{style:{opacity:.95},children:"orange = Recycle"}),", ",o.jsx("span",{style:{opacity:.95},children:"purple = Both"}),"."]})]}),j?o.jsxs("div",{style:{marginTop:12,padding:10,borderRadius:10,border:"1px solid rgba(255,255,255,0.18)",background:"rgba(0,0,0,0.28)"},children:[o.jsx("div",{style:{fontWeight:800,fontSize:12},children:"Target Selection"}),o.jsx("div",{style:{fontSize:12,marginTop:4},children:j.label}),o.jsx("div",{className:"rb-softText",style:{marginTop:4,fontSize:11},children:"Click legal targets directly on the board."}),o.jsxs("div",{style:{marginTop:8,display:"flex",gap:8,flexWrap:"wrap"},children:[ue.optional&&rt===j.controller&&Ye(j.controller)?o.jsx("button",{className:"rb-miniButton",onClick:()=>{const pe=structuredClone(A),ke=pe.chain.find(_=>_.id===(At==null?void 0:At.chainItemId));ke&&(ke.targets=[{kind:"NONE"}],ke.needsTargets=!1,pe.log.unshift(`${ke.controller} declined the optional effect.`),s(pe),jn(null),Yt([{kind:"NONE"}]))},children:"Decline"}):null,o.jsx("button",{className:"rb-miniButton",disabled:!R,onClick:ty,children:"Confirm Targets"})]})]}):null,(A.chain.length>0||b)&&o.jsxs("div",{className:"rb-chainPanel",children:[o.jsxs("div",{className:"rb-panelTitle",style:{marginBottom:8},children:["Chain (",A.chain.length+(b?1:0),")"]}),b?o.jsxs("div",{ref:pe=>Al("CHAIN:PENDING_PLAY",pe),className:`rb-chainItem ${A.chain.length===0?"rb-chainItemActive":""}`,onMouseEnter:()=>Ee("PENDING_PLAY"),onMouseLeave:()=>Ee(pe=>pe==="PENDING_PLAY"?null:pe),onClick:()=>Bt(b),children:[o.jsxs("div",{style:{flex:1},children:[o.jsxs("div",{className:"rb-chainItemLabel",children:["▶ Play ",b.name]}),o.jsx("div",{className:"rb-chainItemTargets",children:Xe?"Awaiting target/destination confirmation.":"Ready to resolve."})]}),o.jsx("div",{style:{fontSize:11,opacity:.6},children:"#0"})]}):null,A.chain.map((pe,ke)=>{var ie;const _=ke===0,U=((ie=pe.targets)==null?void 0:ie.filter(J=>J.kind==="UNIT").map(J=>{const re=Fe(A,J.owner,J.instanceId);return(re==null?void 0:re.unit.name)||"Unknown"}))||[];return o.jsxs("div",{ref:J=>Al(`CHAIN:${pe.id}`,J),className:`rb-chainItem ${_?"rb-chainItemActive":""}`,onMouseEnter:()=>Ee(pe.id),onMouseLeave:()=>Ee(J=>J===pe.id?null:J),onClick:()=>{const J=pe.sourceCard;J&&Bt(J)},children:[o.jsxs("div",{style:{flex:1},children:[o.jsxs("div",{className:"rb-chainItemLabel",children:[_?"▶ ":"",pe.label]}),U.length>0&&o.jsxs("div",{className:"rb-chainItemTargets",children:[o.jsx("span",{className:"rb-chainArrow",children:"→"})," ",U.join(", ")]}),pe.needsTargets&&o.jsx("div",{className:"rb-chainItemTargets",style:{color:"rgba(255, 180, 80, 0.9)"},children:"Needs target selection"})]}),o.jsxs("div",{style:{fontSize:11,opacity:.6},children:["#",ke+1]})]},pe.id)})]}),o.jsxs("div",{style:{marginTop:14},children:[o.jsx("div",{className:"rb-panelTitle",children:"Piles"}),o.jsxs("div",{style:{display:"flex",gap:8,flexWrap:"wrap"},children:[o.jsxs("button",{className:"rb-miniButton",onClick:()=>ks({player:i,zone:"TRASH"}),children:["Your Trash (",f.trash.length,")"]}),o.jsxs("button",{className:"rb-miniButton",onClick:()=>ks({player:r,zone:"TRASH"}),children:["Opponent Trash (",u.trash.length,")"]})]})]}),o.jsxs("div",{style:{marginTop:14},children:[o.jsx("div",{className:"rb-panelTitle",children:"UI"}),o.jsxs("div",{style:{display:"flex",gap:8,flexWrap:"wrap"},children:[o.jsx("button",{className:"rb-miniButton",onClick:()=>gl("Arena"),disabled:Qs==="Arena",children:"Arena"}),o.jsx("button",{className:"rb-miniButton",onClick:()=>gl("Classic"),disabled:Qs==="Classic",children:"Classic"})]}),o.jsx("div",{className:"rb-actionHint",children:"Arena is board-focused; Classic is the old debug panel layout."})]})]})]})},N1=()=>o.jsxs("div",{style:{maxWidth:720,margin:"28px auto"},className:"rb-panel",children:[o.jsx("div",{className:"rb-panelTitle",children:"Setup"}),o.jsx("div",{style:{fontSize:20,fontWeight:900,marginBottom:8},children:"Load card data and start a duel"}),o.jsx("div",{className:"rb-softText",style:{marginBottom:12},children:"Load the provided JSON card database, then auto-setup a hot-seat Duel."}),o.jsxs("div",{style:{display:"flex",gap:10,alignItems:"center",flexWrap:"wrap"},children:[o.jsx("input",{type:"file",accept:".json,application/json",onChange:i=>{var f;const r=(f=i.target.files)==null?void 0:f[0];r&&Td(r).catch(u=>alert(String(u)))}}),o.jsx("button",{className:"rb-miniButton",onClick:()=>Kn("/riftbound_data_expert%20(1).json").catch(i=>alert(String(i))),children:"Load default card data"}),o.jsxs("div",{className:"rb-softText",children:["Loaded cards: ",o.jsx("b",{children:e.length})]})]}),o.jsxs("div",{style:{marginTop:14,display:"flex",gap:10,alignItems:"center",flexWrap:"wrap"},children:[o.jsx("button",{className:"rb-bigButton",style:{maxWidth:320},disabled:e.length===0,onClick:En,children:"Auto-setup Duel (Hot-seat)"}),o.jsx("button",{className:"rb-bigButton",style:{maxWidth:260},disabled:e.length===0,onClick:()=>d("DECK_BUILDER"),children:"Deck Builder"}),o.jsx("button",{id:"rb-quick-start",className:"rb-bigButton",style:{maxWidth:300},onClick:()=>{Kn("/riftbound_data_expert%20(1).json").then(i=>En(i)).catch(i=>alert(String(i)))},children:"Quick Start (local data)"}),o.jsx("button",{id:"rb-quick-retreat-challenge-repro",className:"rb-bigButton",style:{maxWidth:360},onClick:()=>{dc.current=!0,Kn("/riftbound_data_expert%20(1).json").then(i=>En(i)).catch(i=>{dc.current=!1,alert(String(i))})},children:"Quick Retreat->Challenge Repro"}),o.jsx("button",{id:"rb-quick-cull-weak-repro",className:"rb-bigButton",style:{maxWidth:320},onClick:()=>{fc.current=!0,Kn("/riftbound_data_expert%20(1).json").then(i=>En(i)).catch(i=>{fc.current=!1,alert(String(i))})},children:"Quick Cull the Weak Repro"}),o.jsx("button",{id:"rb-quick-conditional-audit-repro",className:"rb-bigButton",style:{maxWidth:360},onClick:()=>{hc.current=!0,Kn("/riftbound_data_expert%20(1).json").then(i=>En(i)).catch(i=>{hc.current=!1,alert(String(i))})},children:"Quick Conditional Audit Repro"}),o.jsx("button",{id:"rb-quick-seal-autopay-repro",className:"rb-bigButton",style:{maxWidth:360},onClick:()=>{pc.current=!0,Kn("/riftbound_data_expert%20(1).json").then(i=>En(i)).catch(i=>{pc.current=!1,alert(String(i))})},children:"Quick Seal Auto-pay Repro"}),o.jsx("button",{id:"rb-quick-gold-token-repro",className:"rb-bigButton",style:{maxWidth:360},onClick:()=>{yc.current=!0,Kn("/riftbound_data_expert%20(1).json").then(i=>En(i)).catch(i=>{yc.current=!1,alert(String(i))})},children:"Quick Gold Token Repro"}),o.jsx("button",{id:"rb-quick-battlefield-audit-repro",className:"rb-bigButton",style:{maxWidth:360},onClick:()=>{gc.current=!0,Kn("/riftbound_data_expert%20(1).json").then(i=>En(i)).catch(i=>{gc.current=!1,alert(String(i))})},children:"Quick Battlefield Audit Repro"}),o.jsx("button",{id:"rb-quick-legend-audit-repro",className:"rb-bigButton",style:{maxWidth:360},onClick:()=>{bc.current=!0,Kn("/riftbound_data_expert%20(1).json").then(i=>En(i)).catch(i=>{bc.current=!1,alert(String(i))})},children:"Quick Legend Audit Repro"}),o.jsx("button",{id:"rb-quick-champion-audit-repro",className:"rb-bigButton",style:{maxWidth:360},onClick:()=>{mc.current=!0,Kn("/riftbound_data_expert%20(1).json").then(i=>En(i)).catch(i=>{mc.current=!1,alert(String(i))})},children:"Quick Champion Audit Repro"}),o.jsx("button",{id:"rb-quick-spell-audit-repro",className:"rb-bigButton",style:{maxWidth:360},onClick:()=>{xc.current=!0,Kn("/riftbound_data_expert%20(1).json").then(i=>En(i)).catch(i=>{xc.current=!1,alert(String(i))})},children:"Quick Spell Audit Repro"}),o.jsx("button",{id:"rb-quick-gear-audit-repro",className:"rb-bigButton",style:{maxWidth:360},onClick:()=>{Ec.current=!0,Kn("/riftbound_data_expert%20(1).json").then(i=>En(i)).catch(i=>{Ec.current=!1,alert(String(i))})},children:"Quick Gear Audit Repro"}),o.jsx("div",{className:"rb-softText",children:"Tip: once started, switch “playing as” to take actions for each player."})]})]}),I1=()=>{const i=x,r=ye[i]||vn(),f=e.filter(_=>_.type==="Legend").slice().sort((_,U)=>(_.name||"").localeCompare(U.name||"")),u=e.filter(_=>_.type==="Rune").slice().sort((_,U)=>(_.name||"").localeCompare(U.name||"")),h=e.filter(_=>_.type==="Battlefield").slice().sort((_,U)=>(_.name||"").localeCompare(U.name||"")),p=e.filter(_=>lr(_.type)).slice().sort((_,U)=>{const ie=Number(_.cost||0),J=Number(U.cost||0);return ie!==J?ie-J:(_.name||"").localeCompare(U.name||"")}),b=r.legendId?wn(e,r.legendId):null,m=b?Vh(b):["Body","Calm","Chaos","Fury","Mind","Order"],v=b&&(b.tags||[])[0]||null,C=b?h.filter(_=>Za(_,m)):h,w=b?u.filter(_=>{const U=(Qt(_.domain)[0]||_.domain||"Colorless").trim(),ie=vt(U);return ie==="Colorless"||m.includes(ie)}):u,K=b?p.filter(_=>Za(_,m)):p,X=b?K.filter(_=>Ab(_,v)):[],q=ls(r.main),oe=ls(r.runes),H=(_,U="")=>({..._,instanceId:`preview_${i}_${U}_${_.id}`,owner:i,controller:i,isReady:!0,damage:0,buffs:0,tempMightBonus:0,stunned:!1,stunnedUntilTurn:0,moveCountThisTurn:0,createdTurn:0}),O=(_,U)=>{const ie=[],J=U.legendId?wn(e,U.legendId):null;(!J||J.type!=="Legend")&&ie.push("Select a Legend.");const re=U.championId?wn(e,U.championId):null;(!re||re.type!=="Unit")&&ie.push("Select a chosen Champion (Unit).");const Me=U.battlefields||[];Me.length!==3&&ie.push(`Choose exactly 3 battlefields (currently ${Me.length}).`);const qe=ls(U.runes||{});qe!==12&&ie.push(`Rune deck must have exactly 12 cards (currently ${qe}).`);const dt=ls(U.main||{});dt<40&&ie.push(`Main deck must have at least 40 cards (currently ${dt}).`),re&&re.type==="Unit"&&Math.floor((U.main||{})[re.id]||0)<1&&ie.push("Main deck must include at least 1 copy of the chosen Champion.");try{Ml(e,_,U,1)}catch(Wt){const nt=String((Wt==null?void 0:Wt.message)||Wt);ie.includes(nt)||ie.push(nt)}return ie},$=O("P1",ye.P1),j=O("P2",ye.P2),ue=i==="P1"?$:j,ve=e.length>0&&$.length===0&&j.length===0,he=wl("P1"),Y=wl("P2"),ge=(D==null?void 0:D.format)==="BO3"&&(D!=null&&D.usedBattlefieldIds)?D.usedBattlefieldIds:{P1:[],P2:[]},R=he.filter(_=>!ge.P1.includes(_.id)),W=Y.filter(_=>!ge.P2.includes(_.id)),I=R.length>0?R:he,Z=W.length>0?W:Y;let ee=K;_a!=="All"&&(ee=ee.filter(_=>_.type===_a));const de=qs.trim().toLowerCase();de&&(ee=ee.filter(_=>(_.name||"").toLowerCase().includes(de)||(_.id||"").toLowerCase().includes(de))),ee=ee.slice(0,96);const Re=Object.entries(r.main).map(([_,U])=>({id:_,n:U,card:wn(e,_)})).filter(_=>_.card!==null&&(_.n||0)>0).sort((_,U)=>{const ie=_.card.type||"",J=U.card.type||"";if(ie!==J)return ie.localeCompare(J);const re=Number(_.card.cost||0),Me=Number(U.card.cost||0);return re!==Me?re-Me:(_.card.name||"").localeCompare(U.card.name||"")}),Se=Object.entries(r.sideboard||{}).map(([_,U])=>({id:_,n:U,card:wn(e,_)})).filter(_=>_.card!==null&&(_.n||0)>0).sort((_,U)=>{const ie=_.card.type||"",J=U.card.type||"";if(ie!==J)return ie.localeCompare(J);const re=Number(_.card.cost||0),Me=Number(U.card.cost||0);return re!==Me?re-Me:(_.card.name||"").localeCompare(U.card.name||"")}),G=ls(r.sideboard||{}),be=(b==null?void 0:b.name)||"—",ne=b?m.join(", "):"—",te=_=>{kn(i,U=>{const ie=U.battlefields||[];return ie.includes(_)?{...U,battlefields:ie.filter(J=>J!==_)}:ie.length>=3?U:{...U,battlefields:[...ie,_]}})},Oe=()=>{e.length!==0&&kn(i,_=>{const U=_.legendId?wn(e,_.legendId):null,ie=U&&U.type==="Legend"?U:f[0]||null;if(!ie)return _;const J=Vh(ie),re=(ie.tags||[])[0]||null,qe=e.filter(Vt=>Ab(Vt,re)).filter(Vt=>Za(Vt,J))[0]||e.find(Vt=>Vt.type==="Unit")||null,dt=h.filter(Vt=>Za(Vt,J)),Wt=Hi(dt,777).slice(0,3).map(Vt=>Vt.id),nt={};for(const Vt of u){const Kd=(Qt(Vt.domain)[0]||Vt.domain||"Colorless").trim(),Sc=vt(Kd);nt[Sc]||(nt[Sc]=Vt)}const He={},Nt=J.length>0?J:["Body","Calm","Chaos","Fury","Mind","Order"],ss=Math.floor(12/Nt.length),_s=12%Nt.length;for(let Vt=0;Vt<Nt.length;Vt++){const Kd=Nt[Vt],Sc=ss+(Vt<_s?1:0),Vd=nt[Kd]||u[0];Vd&&(He[Vd.id]=(He[Vd.id]||0)+Sc)}const Gn=K.length>0?K:p,zn={};qe&&qe.id&&(zn[qe.id]=1);const Zs=3,rn=Hi(Gn,888);let wc=0;for(;ls(zn)<40&&rn.length>0;){const Vt=rn[wc%rn.length];if(wc++,!Vt)break;zn[Vt.id]>=Zs||(zn[Vt.id]=(zn[Vt.id]||0)+1)}return{legendId:ie.id,championId:qe?qe.id:null,battlefields:Wt,runes:He,main:zn}})},Pe=async()=>{const _=JSON.stringify(ye,null,2);try{await navigator.clipboard.writeText(_),alert("Decks JSON copied to clipboard.")}catch{window.prompt("Copy decks JSON:",_)}},et=()=>{const _=window.prompt("Paste decks JSON here:");if(_)try{const U=JSON.parse(_);if(!(U!=null&&U.P1)||!(U!=null&&U.P2))throw new Error("Expected object with {P1, P2}.");_e({P1:U.P1,P2:U.P2}),alert("Imported.")}catch(U){alert(`Import failed: ${String((U==null?void 0:U.message)||U)}`)}},Le=_=>!!_&&typeof _=="object"&&"legendId"in _&&"main"in _&&"runes"in _&&"battlefields"in _,Ge=ze&&Ne.find(_=>_.id===ze)||null,ht=tt.trim().toLowerCase(),Ut=we.trim().toLowerCase(),it=Ne.filter(_=>{const U=(_.name||"").toLowerCase(),ie=(_.tags||[]).map(J=>String(J).toLowerCase());return!(ht&&!U.includes(ht)&&!ie.some(J=>J.includes(ht))||Ut&&!ie.some(J=>J.includes(Ut)))}),mt=(_,U)=>{_e(ie=>({...ie,[U]:_i(_.spec)})),pn(_.name||""),Jn((_.tags||[]).join(", ")),We(_.id)},Jt=_=>{const U=_.legendId?wn(e,_.legendId):null,ie=_.championId?wn(e,_.championId):null,J=(U==null?void 0:U.name)||"Legend",re=(ie==null?void 0:ie.name)||"Champion";return`${J} — ${re}`},Nn=_=>String(_||"").split(",").map(U=>U.trim()).filter(U=>U.length>0).slice(0,16),In=()=>{const _=(Ke&&Ke.trim().length>0?Ke.trim():Jt(r)).trim();if(!_)return;const U={id:ce(),name:_,tags:Nn(Q),spec:_i(r),createdAt:Date.now(),updatedAt:Date.now()};Ue(ie=>[U,...ie]),We(U.id)},Ps=()=>{if(!ze){alert("Select a saved deck first.");return}Ue(_=>_.map(U=>U.id===ze?{...U,spec:_i(r),updatedAt:Date.now()}:U)),alert("Updated saved deck.")},ns=()=>{if(!Ge)return;const _=window.prompt("New name:",Ge.name);_&&Ue(U=>U.map(ie=>ie.id===Ge.id?{...ie,name:_,updatedAt:Date.now()}:ie))},Tt=_=>{if(!Ge)return;const U=Nn(_);Ue(ie=>ie.map(J=>J.id===Ge.id?{...J,tags:U,updatedAt:Date.now()}:J))},Ci=()=>{if(!Ge)return;const _=window.prompt("Name for duplicate:",`${Ge.name} (copy)`);if(!_)return;const U={id:ce(),name:_,tags:_i(Ge.tags||[]),spec:_i(Ge.spec),createdAt:Date.now(),updatedAt:Date.now()};Ue(ie=>[U,...ie]),We(U.id)},$a=()=>{Ge&&confirm(`Delete "${Ge.name}" from library?`)&&(Ue(_=>_.filter(U=>U.id!==Ge.id)),ze===Ge.id&&We(null))},Ua=async()=>{if(!Ge){alert("Select a saved deck first.");return}const _=JSON.stringify(Ge.spec,null,2);try{await navigator.clipboard.writeText(_),alert("Deck JSON copied to clipboard.")}catch{window.prompt("Copy deck JSON:",_)}},Ga=()=>{const _=window.prompt("Paste a single DeckSpec JSON here:");if(_)try{const U=JSON.parse(_);if(!Le(U))throw new Error("Not a DeckSpec.");const ie=window.prompt("Deck name:",Jt(U));if(!ie)return;const J={id:ce(),name:ie,tags:[],spec:U,createdAt:Date.now(),updatedAt:Date.now()};Ue(re=>[J,...re]),We(J.id),alert("Imported deck into library.")}catch(U){alert(`Import failed: ${String((U==null?void 0:U.message)||U)}`)}},pe=async()=>{const _=JSON.stringify(Ne,null,2);try{await navigator.clipboard.writeText(_),alert("Deck library JSON copied to clipboard.")}catch{window.prompt("Copy deck library JSON:",_)}},ke=()=>{const _=window.prompt("Paste Deck Library JSON (array of entries) here:");if(_)try{const U=JSON.parse(_);if(!Array.isArray(U))throw new Error("Expected an array.");const ie=U.filter(re=>re&&typeof re=="object").map(re=>{if(!Le(re.spec))throw new Error("Entry missing spec DeckSpec.");return{id:String(re.id||ce()),name:String(re.name||"Imported Deck"),tags:Array.isArray(re.tags)?re.tags.map(Me=>String(Me)).filter(Boolean):[],spec:re.spec,createdAt:Number(re.createdAt||Date.now()),updatedAt:Number(re.updatedAt||Date.now())}}),J=confirm("Replace your existing deck library? (Cancel = merge)");Ue(J?ie:re=>{const Me=new Set(re.map(dt=>dt.id));return[...ie.map(dt=>Me.has(dt.id)?{...dt,id:ce()}:dt),...re]}),alert("Imported deck library.")}catch(U){alert(`Import failed: ${String((U==null?void 0:U.message)||U)}`)}};return o.jsx("div",{style:{maxWidth:1240,margin:"18px auto",padding:"0 12px"},children:o.jsxs("div",{className:"rb-panel",children:[o.jsx("div",{className:"rb-panelTitle",children:"Deck Builder"}),o.jsxs("div",{style:{display:"flex",gap:10,flexWrap:"wrap",alignItems:"center",marginTop:8},children:[o.jsx("button",{className:"rb-miniButton",onClick:()=>d("SETUP"),children:"← Back"}),o.jsx("button",{className:"rb-miniButton",disabled:e.length===0,onClick:Pe,children:"Export decks"}),o.jsx("button",{className:"rb-miniButton",disabled:e.length===0,onClick:et,children:"Import decks"}),o.jsx("button",{className:"rb-miniButton",onClick:()=>{confirm("Clear BOTH decks?")&&_e({P1:vn(),P2:vn()})},children:"Clear all"}),o.jsx("div",{style:{flex:1}}),o.jsxs("div",{style:{display:"flex",flexDirection:"column",gap:6,alignItems:"flex-end",marginRight:8},children:[o.jsxs("div",{style:{display:"flex",gap:12,alignItems:"center",flexWrap:"wrap"},children:[o.jsx("span",{className:"rb-softText",style:{fontWeight:900},children:"Match"}),o.jsxs("label",{style:{display:"flex",gap:6,alignItems:"center"},className:"rb-softText",children:[o.jsx("input",{type:"radio",name:"matchfmt",checked:T==="BO1",onChange:()=>{N("BO1"),z(null),fe(null),M({P1:null,P2:null})}}),"Best of 1 (random battlefields)"]}),o.jsxs("label",{style:{display:"flex",gap:6,alignItems:"center"},className:"rb-softText",children:[o.jsx("input",{type:"radio",name:"matchfmt",checked:T==="BO3",onChange:()=>{var _,U;N("BO3"),z(null),fe(null),M({P1:((_=I[0])==null?void 0:_.id)??null,P2:((U=Z[0])==null?void 0:U.id)??null})}}),"Best of 3 (pick each game; no repeats)"]})]}),T==="BO3"&&ve?o.jsxs("div",{style:{display:"flex",gap:10,alignItems:"center",flexWrap:"wrap"},children:[o.jsx("span",{className:"rb-softText",children:"Game 1 battlefields:"}),o.jsx("span",{className:"rb-softText",children:"P1"}),o.jsx("select",{value:me.P1??"",onChange:_=>M(U=>({...U,P1:_.target.value||null})),children:I.map(_=>o.jsx("option",{value:_.id,children:_.name},_.id))}),o.jsx("span",{className:"rb-softText",children:"P2"}),o.jsx("select",{value:me.P2??"",onChange:_=>M(U=>({...U,P2:_.target.value||null})),children:Z.map(_=>o.jsx("option",{value:_.id,children:_.name},_.id))})]}):null]}),o.jsx("button",{className:"rb-bigButton",style:{maxWidth:280},disabled:!ve,onClick:()=>Id(),children:"Start Duel from Decks"})]}),o.jsxs("div",{style:{display:"flex",flexDirection:"column",gap:10,marginTop:10,paddingTop:10,borderTop:"1px solid rgba(255,255,255,0.10)"},children:[o.jsxs("div",{style:{display:"flex",gap:12,flexWrap:"wrap",alignItems:"flex-start"},children:[o.jsxs("div",{style:{display:"flex",flexDirection:"column",gap:6},children:[o.jsx("input",{className:"rb-input",placeholder:"Search library (name or tag)…",value:tt,onChange:_=>Be(_.target.value),style:{width:260}}),o.jsx("input",{className:"rb-input",placeholder:"Filter by tag…",value:we,onChange:_=>Je(_.target.value),style:{width:260}})]}),o.jsx("div",{style:{flex:1}}),o.jsxs("div",{style:{display:"flex",flexDirection:"column",gap:6,minWidth:320},children:[o.jsxs("div",{style:{display:"flex",gap:8,flexWrap:"wrap",alignItems:"center"},children:[o.jsx("input",{className:"rb-input",placeholder:"Save current as…",value:Ke,onChange:_=>pn(_.target.value),style:{flex:1,minWidth:200}}),o.jsx("button",{className:"rb-miniButton",onClick:In,title:"Save the current builder deck as a new library entry",children:"Save as new"})]}),o.jsx("input",{className:"rb-input",placeholder:"Tags (comma separated)…",value:Q,onChange:_=>Jn(_.target.value)})]})]}),o.jsxs("div",{style:{display:"flex",gap:12,flexWrap:"wrap",alignItems:"flex-start"},children:[o.jsxs("div",{style:{minWidth:320,flex:1},children:[o.jsxs("div",{className:"rb-softText",style:{marginBottom:6},children:["Library (",it.length,"/",Ne.length,") — drag to reorder"]}),o.jsx("div",{style:{border:"1px solid rgba(255,255,255,0.12)",borderRadius:12,overflow:"hidden",background:"rgba(0,0,0,0.18)",maxHeight:220,overflowY:"auto"},children:it.length===0?o.jsx("div",{className:"rb-softText",style:{padding:10},children:"No decks match your filters."}):it.map((_,U)=>{const ie=_.id===ze,J=(_.tags||[]).join(", ");return o.jsxs("div",{draggable:!0,onDragStart:()=>bt(_.id),onDragEnd:()=>bt(null),onDragOver:re=>re.preventDefault(),onDrop:()=>{gt&&gt!==_.id&&yd(gt,_.id)},onClick:()=>We(_.id),style:{padding:"10px 12px",cursor:"pointer",borderTop:U===0?"none":"1px solid rgba(255,255,255,0.08)",background:ie?"rgba(255,255,255,0.10)":"transparent",userSelect:"none"},title:"Click to select • Drag to reorder",children:[o.jsx("div",{style:{fontWeight:800},children:_.name}),o.jsx("div",{className:"rb-softText",style:{marginTop:2},children:J||"—"})]},_.id)})})]}),o.jsxs("div",{style:{minWidth:320,flex:1},children:[o.jsxs("div",{style:{display:"flex",gap:8,flexWrap:"wrap",alignItems:"center"},children:[o.jsxs("select",{className:"rb-input",value:ze||"",onChange:_=>We(_.target.value||null),style:{flex:1,minWidth:200},children:[o.jsx("option",{value:"",children:"— Select saved deck —"}),it.map(_=>o.jsx("option",{value:_.id,children:_.name},_.id))]}),o.jsxs("button",{className:"rb-miniButton",disabled:!Ge,onClick:()=>Ge&&mt(Ge,x),title:`Load selected deck into ${x}`,children:["Load → ",x]})]}),Ge?o.jsxs("div",{style:{marginTop:8},children:[o.jsx("div",{className:"rb-softText",style:{marginBottom:4},children:"Tags for selected deck"}),o.jsx("input",{className:"rb-input",value:(Ge.tags||[]).join(", "),onChange:_=>Tt(_.target.value),placeholder:"tags…"}),o.jsxs("div",{className:"rb-softText",style:{marginTop:6},children:["Selected: ",o.jsx("b",{children:Ge.name})," • Updated ",new Date(Ge.updatedAt).toLocaleString()]})]}):o.jsx("div",{className:"rb-softText",style:{marginTop:8},children:"Save multiple decks here, then load them into either P1 or P2."}),o.jsxs("div",{style:{display:"flex",gap:8,marginTop:10,flexWrap:"wrap"},children:[o.jsx("button",{className:"rb-miniButton",disabled:!Ge,onClick:Ps,title:"Overwrite the selected library deck with the current builder deck",children:"Update"}),o.jsx("button",{className:"rb-miniButton",disabled:!Ge,onClick:ns,children:"Rename"}),o.jsx("button",{className:"rb-miniButton",disabled:!Ge,onClick:Ci,children:"Duplicate"}),o.jsx("button",{className:"rb-miniButton",disabled:!Ge,onClick:$a,children:"Delete"}),o.jsx("div",{style:{flex:1}}),o.jsx("button",{className:"rb-miniButton",disabled:!Ge,onClick:Ua,children:"Export Deck"}),o.jsx("button",{className:"rb-miniButton",onClick:Ga,children:"Import Deck"}),o.jsx("button",{className:"rb-miniButton",onClick:pe,children:"Export Library"}),o.jsx("button",{className:"rb-miniButton",onClick:ke,children:"Import Library"})]})]})]})]}),o.jsxs("div",{style:{display:"flex",gap:8,marginTop:10,flexWrap:"wrap"},children:[o.jsx("button",{className:"rb-miniButton",disabled:x==="P1",onClick:()=>S("P1"),children:"Edit P1"}),o.jsx("button",{className:"rb-miniButton",disabled:x==="P2",onClick:()=>S("P2"),children:"Edit P2"}),o.jsx("button",{className:"rb-miniButton",onClick:()=>{_e(_=>({..._,P2:JSON.parse(JSON.stringify(_.P1))}))},children:"Copy P1 → P2"}),o.jsxs("button",{className:"rb-miniButton",onClick:()=>kn(i,()=>vn()),children:["Clear ",i]}),o.jsxs("button",{className:"rb-miniButton",disabled:e.length===0,onClick:Oe,children:["Auto-fill ",i]})]}),o.jsxs("div",{style:{marginTop:10},className:"rb-softText",children:["Editing ",o.jsx("b",{children:i})," • Legend: ",o.jsx("b",{children:be})," • Identity: ",o.jsx("b",{children:ne})]}),o.jsxs("div",{style:{display:"grid",gridTemplateColumns:"340px 1fr 340px",gap:12,marginTop:12,alignItems:"start"},children:[o.jsxs("div",{className:"rb-panel",children:[o.jsx("div",{className:"rb-panelTitle",children:"Deck configuration"}),o.jsx("div",{className:"rb-zoneLabel",children:"Legend"}),o.jsxs("select",{value:r.legendId||"",onChange:_=>{const U=_.target.value||null;kn(i,ie=>({...ie,legendId:U,championId:null,battlefields:[],runes:{},main:{}}))},style:{width:"100%",padding:8,borderRadius:10,background:"rgba(0,0,0,0.25)",color:"white",border:"1px solid rgba(255,255,255,0.12)"},children:[o.jsx("option",{value:"",children:"— Select Legend —"}),f.map(_=>o.jsxs("option",{value:_.id,children:[_.name," (",_.domain,")"]},_.id))]}),o.jsx("div",{style:{height:12}}),o.jsx("div",{className:"rb-zoneLabel",children:"Chosen Champion"}),o.jsxs("select",{value:r.championId||"",onChange:_=>{const U=_.target.value||null;kn(i,ie=>{const J={...ie.main||{}};return U&&(J[U]||0)<1&&(J[U]=1),{...ie,championId:U,main:J}})},disabled:!b,style:{width:"100%",padding:8,borderRadius:10,background:"rgba(0,0,0,0.25)",color:"white",border:"1px solid rgba(255,255,255,0.12)"},children:[o.jsx("option",{value:"",children:"— Select Champion —"}),X.map(_=>o.jsxs("option",{value:_.id,children:[_.name," (cost ",_.cost,")"]},_.id))]}),b?null:o.jsx("div",{className:"rb-softText",style:{marginTop:6},children:"Pick a Legend first (to filter legal Champions)."}),o.jsx("div",{style:{height:12}}),o.jsx("div",{className:"rb-zoneLabel",children:"Battlefields (pick 3)"}),o.jsxs("div",{style:{maxHeight:240,overflow:"auto",border:"1px solid rgba(255,255,255,0.10)",borderRadius:12,padding:8},children:[C.map(_=>{const U=(r.battlefields||[]).includes(_.id);return o.jsxs("div",{style:{display:"flex",gap:8,alignItems:"center",padding:"6px 4px",borderRadius:10},children:[o.jsx("input",{type:"checkbox",checked:U,onChange:()=>te(_.id)}),o.jsx("div",{style:{fontSize:12,fontWeight:800,flex:1,minWidth:0,whiteSpace:"nowrap",overflow:"hidden",textOverflow:"ellipsis"},children:_.name}),o.jsx("div",{style:{fontSize:11,opacity:.85},children:_.domain})]},_.id)}),C.length===0?o.jsx("div",{className:"rb-softText",children:"—"}):null]}),o.jsx("div",{style:{height:12}}),o.jsx("div",{className:"rb-zoneLabel",children:"Rune deck (exactly 12)"}),o.jsxs("div",{style:{display:"flex",gap:8,flexWrap:"wrap"},children:[w.map(_=>{const U=Math.floor((r.runes||{})[_.id]||0);return o.jsxs("div",{style:{width:150,border:"1px solid rgba(255,255,255,0.10)",borderRadius:12,padding:8},children:[o.jsx("div",{style:{fontSize:12,fontWeight:900},children:_.name}),o.jsx("div",{style:{fontSize:11,opacity:.8},children:_.domain}),o.jsxs("div",{style:{display:"flex",gap:6,alignItems:"center",marginTop:6},children:[o.jsx("button",{className:"rb-miniButton",onClick:()=>kn(i,ie=>({...ie,runes:Un(ie.runes||{},_.id,-1,0,null)})),children:"−"}),o.jsx("div",{style:{minWidth:24,textAlign:"center",fontWeight:900},children:U}),o.jsx("button",{className:"rb-miniButton",onClick:()=>kn(i,ie=>({...ie,runes:Un(ie.runes||{},_.id,1,0,null)})),children:"+"})]})]},_.id)}),w.length===0?o.jsx("div",{className:"rb-softText",children:"—"}):null]}),o.jsx("div",{style:{height:10}}),o.jsxs("div",{className:"rb-softText",children:["Main deck: ",o.jsx("b",{children:q})," cards • Rune deck: ",o.jsx("b",{children:oe}),"/12"]})]}),o.jsxs("div",{className:"rb-panel",children:[o.jsx("div",{className:"rb-panelTitle",children:"Card browser"}),o.jsxs("div",{style:{display:"flex",gap:8,flexWrap:"wrap",alignItems:"center"},children:[o.jsx("input",{value:qs,onChange:_=>Ar(_.target.value),placeholder:"Search cards (name or id)…",style:{flex:1,minWidth:220,padding:"9px 10px",borderRadius:12,background:"rgba(0,0,0,0.25)",color:"white",border:"1px solid rgba(255,255,255,0.12)"}}),o.jsxs("select",{value:_a,onChange:_=>Qo(_.target.value),style:{padding:"9px 10px",borderRadius:12,background:"rgba(0,0,0,0.25)",color:"white",border:"1px solid rgba(255,255,255,0.12)"},children:[o.jsx("option",{value:"All",children:"All"}),o.jsx("option",{value:"Unit",children:"Units"}),o.jsx("option",{value:"Spell",children:"Spells"}),o.jsx("option",{value:"Gear",children:"Gear"})]})]}),o.jsxs("div",{className:"rb-softText",style:{marginTop:8},children:["Showing ",o.jsx("b",{children:ee.length})," cards (filtered to identity where possible)."]}),o.jsx("div",{style:{marginTop:10,maxHeight:480,overflow:"auto",border:"1px solid rgba(255,255,255,0.10)",borderRadius:12,padding:8},children:o.jsxs("div",{className:"rb-row",style:{flexWrap:"wrap",gap:8},children:[ee.map(_=>{const U=Math.floor((r.main||{})[_.id]||0),ie=H(_,"browse");return o.jsxs("div",{style:{width:118,display:"flex",flexDirection:"column",alignItems:"center",gap:4,padding:4,borderRadius:8,background:U>0?"rgba(130, 210, 255, 0.1)":"transparent"},children:[o.jsx(jt,{card:ie,size:"xs",showReadyDot:!1,onClick:()=>Bt(ie)}),o.jsx("div",{style:{fontSize:10,fontWeight:800,textAlign:"center",maxWidth:110,lineHeight:1.1,overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"},children:_.name}),o.jsxs("div",{style:{display:"flex",gap:4,alignItems:"center",marginTop:2},children:[o.jsx("button",{className:"rb-miniButton",style:{padding:"4px 10px",fontSize:14,fontWeight:900},onClick:J=>{J.stopPropagation(),kn(i,re=>({...re,main:Un(re.main||{},_.id,-1,0,3)}))},disabled:U<=0,children:"−"}),o.jsx("div",{style:{minWidth:20,textAlign:"center",fontWeight:900,fontSize:12},children:U}),o.jsx("button",{className:"rb-miniButton",style:{padding:"4px 10px",fontSize:14,fontWeight:900},onClick:J=>{J.stopPropagation(),kn(i,re=>({...re,main:Un(re.main||{},_.id,1,0,3)}))},disabled:U>=3,children:"+"})]})]},_.id)}),ee.length===0?o.jsx("div",{className:"rb-softText",children:"No results."}):null]})})]}),o.jsxs("div",{className:"rb-panel",children:[o.jsx("div",{className:"rb-panelTitle",children:"Main deck list"}),o.jsx("div",{className:"rb-softText",children:"Click + / − to adjust (max 3 copies per card). Your chosen Champion must be included at least once."}),o.jsxs("div",{style:{marginTop:10,maxHeight:400,overflow:"auto",border:"1px solid rgba(255,255,255,0.10)",borderRadius:12,padding:8},children:[Re.length===0?o.jsx("div",{className:"rb-softText",children:"—"}):null,Re.map(_=>{const U=_.card,ie=Math.floor(_.n||0),J=H(U,"deck");return o.jsxs("div",{style:{display:"flex",gap:8,alignItems:"center",padding:"6px 4px",borderRadius:10},children:[o.jsx("div",{style:{width:36},children:o.jsx(jt,{card:J,size:"xs",showReadyDot:!1,onClick:()=>Bt(J)})}),o.jsxs("div",{style:{flex:1,minWidth:0},children:[o.jsx("div",{style:{fontSize:12,fontWeight:900,whiteSpace:"nowrap",overflow:"hidden",textOverflow:"ellipsis"},children:U.name}),o.jsxs("div",{style:{fontSize:11,opacity:.8},children:[U.type," • cost ",U.cost," • ",U.domain]})]}),o.jsx("button",{className:"rb-miniButton",onClick:()=>kn(i,re=>({...re,main:Un(re.main||{},U.id,-1,0,3)})),children:"−"}),o.jsx("div",{style:{width:26,textAlign:"center",fontWeight:900},children:ie}),o.jsx("button",{className:"rb-miniButton",onClick:()=>kn(i,re=>({...re,main:Un(re.main||{},U.id,1,0,3)})),children:"+"}),o.jsx("button",{className:"rb-miniButton",style:{fontSize:10,padding:"2px 6px"},title:"Move to sideboard",onClick:()=>kn(i,re=>{const Me=Un(re.main||{},U.id,-1,0,3),qe=Un(re.sideboard||{},U.id,1,0,8-ls(re.sideboard||{}));return{...re,main:Me,sideboard:qe}}),children:"→SB"})]},_.id)})]}),o.jsxs("div",{style:{marginTop:16},children:[o.jsxs("div",{className:"rb-panelTitle",children:["Sideboard (",G,"/8)"]}),o.jsx("div",{className:"rb-softText",style:{fontSize:11},children:"Up to 8 cards for Bo3 sideboarding between games."}),o.jsxs("div",{style:{marginTop:8,maxHeight:180,overflow:"auto",border:"1px solid rgba(255,255,255,0.10)",borderRadius:12,padding:8},children:[Se.length===0?o.jsx("div",{className:"rb-softText",children:"—"}):null,Se.map(_=>{const U=_.card,ie=Math.floor(_.n||0),J=H(U,"deck");return o.jsxs("div",{style:{display:"flex",gap:8,alignItems:"center",padding:"6px 4px",borderRadius:10},children:[o.jsx("div",{style:{width:36},children:o.jsx(jt,{card:J,size:"xs",showReadyDot:!1,onClick:()=>Bt(J)})}),o.jsxs("div",{style:{flex:1,minWidth:0},children:[o.jsx("div",{style:{fontSize:12,fontWeight:900,whiteSpace:"nowrap",overflow:"hidden",textOverflow:"ellipsis"},children:U.name}),o.jsxs("div",{style:{fontSize:11,opacity:.8},children:[U.type," • cost ",U.cost," • ",U.domain]})]}),o.jsx("button",{className:"rb-miniButton",style:{fontSize:10,padding:"2px 6px"},title:"Move to main deck",onClick:()=>kn(i,re=>{const Me=Un(re.sideboard||{},U.id,-1,0,8),qe=Un(re.main||{},U.id,1,0,3);return{...re,main:qe,sideboard:Me}}),children:"←Main"}),o.jsx("button",{className:"rb-miniButton",onClick:()=>kn(i,re=>({...re,sideboard:Un(re.sideboard||{},U.id,-1,0,8)})),children:"−"}),o.jsx("div",{style:{width:26,textAlign:"center",fontWeight:900},children:ie}),o.jsx("button",{className:"rb-miniButton",disabled:G>=8,onClick:()=>kn(i,re=>({...re,sideboard:Un(re.sideboard||{},U.id,1,0,8-ls(re.sideboard||{})+ie)})),children:"+"})]},_.id)})]})]}),Ii?o.jsxs("div",{style:{marginTop:12},children:[o.jsx("div",{className:"rb-panelTitle",children:"Preview"}),"instanceId"in Ii?o.jsx("div",{className:"rb-row rb-rowCenter",children:o.jsx(jt,{card:Ii,size:"sm",showReadyDot:!1})}):null,o.jsx("div",{className:"rb-softText",style:{marginTop:8},children:Ii.name})]}):null]})]}),ue.length>0?o.jsxs("div",{style:{marginTop:14},children:[o.jsxs("div",{className:"rb-panelTitle",children:["Issues for ",i]}),o.jsx("ul",{style:{margin:0,paddingLeft:18},children:ue.map((_,U)=>o.jsx("li",{style:{color:"#ffb4b4"},children:_},U))})]}):null,($.length>0||j.length>0)&&ve===!1?o.jsx("div",{className:"rb-softText",style:{marginTop:10},children:"Fix both decks before starting. (You can use “Auto-fill” as a starting point.)"}):null]})})},v1=()=>{if(!A||!bl)return null;const i=bl.player,r=bl.zone,f=A.players[i],u=r==="TRASH"?f.trash:f.banishment,h=r==="TRASH"?"Trash (discard pile)":"Banishment";return o.jsx("div",{className:"rb-modalOverlay",onClick:()=>ks(null),children:o.jsxs("div",{className:"rb-modal",onClick:p=>p.stopPropagation(),children:[o.jsxs("div",{className:"rb-modalHeader",children:[o.jsxs("div",{style:{fontWeight:900},children:[i," — ",h," (",u.length,")"]}),o.jsxs("div",{style:{display:"flex",gap:8,flexWrap:"wrap",justifyContent:"flex-end"},children:[o.jsx("button",{className:"rb-miniButton",onClick:()=>ks({player:"P1",zone:r}),children:"View P1"}),o.jsx("button",{className:"rb-miniButton",onClick:()=>ks({player:"P2",zone:r}),children:"View P2"}),o.jsx("button",{className:"rb-miniButton",onClick:()=>ks(null),children:"Close"})]})]}),o.jsxs("div",{className:"rb-modalBody",children:[u.length===0?o.jsx("div",{className:"rb-softText",children:"—"}):null,o.jsx("div",{className:"rb-pileGrid",children:[...u].slice().reverse().map(p=>o.jsxs("div",{style:{width:120,display:"flex",flexDirection:"column",alignItems:"center",gap:6},children:[o.jsx(jt,{card:p,size:"xs",showReadyDot:!1,onClick:()=>Bt(p)}),o.jsx("div",{style:{fontSize:11,fontWeight:800,textAlign:"center",maxWidth:118,lineHeight:1.1,opacity:.95},children:p.name})]},p.instanceId))})]})]})})},C1=()=>{if(!A||!A.pendingRevealWindow)return null;const i=A.pendingRevealWindow,r=i.requiredAcknowledger,f=rt===r&&!Ln(r),u=i.mode==="REVEAL"?"Revealed cards":"Looked-at cards";return o.jsx("div",{className:"rb-modalOverlay",children:o.jsxs("div",{className:"rb-modal",onClick:h=>h.stopPropagation(),children:[o.jsxs("div",{className:"rb-modalHeader",children:[o.jsxs("div",{style:{fontWeight:900},children:[u," (",i.cards.length,")"]}),o.jsxs("div",{className:"rb-softText",children:[i.player," ",i.mode==="REVEAL"?"revealed":"looked at"," top cards from ",i.deckKind," deck."]})]}),o.jsxs("div",{className:"rb-modalBody",children:[o.jsx("div",{className:"rb-pileGrid",children:i.cards.map(h=>o.jsxs("div",{style:{width:128,display:"flex",flexDirection:"column",gap:6,alignItems:"center"},children:[o.jsx("div",{style:{width:112,height:156,borderRadius:10,border:"1px solid rgba(255,255,255,0.2)",background:"rgba(20,28,44,0.9)",overflow:"hidden",display:"flex",alignItems:"center",justifyContent:"center"},children:h.image_url||h.image?o.jsx("img",{src:h.image_url||h.image,alt:h.name,style:{width:"100%",height:"100%",objectFit:"cover"}}):o.jsx("div",{style:{fontSize:12,opacity:.9,textAlign:"center",padding:8},children:h.name})}),o.jsx("div",{style:{fontSize:11,fontWeight:800,textAlign:"center",lineHeight:1.2},children:h.name}),o.jsx("div",{style:{fontSize:10,opacity:.75},children:h.type})]},h.key))}),o.jsxs("div",{style:{marginTop:12,display:"flex",justifyContent:"space-between",alignItems:"center",gap:10,flexWrap:"wrap"},children:[o.jsx("div",{className:"rb-softText",children:i.mode==="REVEAL"?`Waiting for ${r} to pass before these cards are hidden.`:`Waiting for ${r} to acknowledge this look effect.`}),o.jsx("button",{className:"rb-miniButton",disabled:!f,onClick:()=>Ze({type:"REVEAL_WINDOW_ACK",player:r,windowId:i.id}),children:i.mode==="REVEAL"?"Pass and Hide Cards":"Close"})]})]})]})})},w1=()=>{if(!A||!A.pendingTrashSelection)return null;const i=A.pendingTrashSelection,r=i.player,f=rt===r&&Ye(r)&&!Ln(r),u=A.players[La].trash,h=new Set(xl),p=m=>{f&&El(v=>v.includes(m)?v.filter(w=>w!==m):v.length>=i.maxCards?v:[...v,m])},b=()=>{Ze({type:"TRASH_SELECTION_CONFIRM",player:r,selectionId:i.id,selectedKeys:xl.slice(0,i.maxCards)})};return o.jsx("div",{className:"rb-modalOverlay",children:o.jsxs("div",{className:"rb-modal",onClick:m=>m.stopPropagation(),children:[o.jsxs("div",{className:"rb-modalHeader",children:[o.jsx("div",{style:{fontWeight:900},children:"Trash Selection"}),o.jsx("div",{className:"rb-softText",children:i.prompt})]}),o.jsxs("div",{className:"rb-modalBody",children:[o.jsxs("div",{style:{display:"flex",gap:8,alignItems:"center",marginBottom:10,flexWrap:"wrap"},children:[o.jsxs("button",{className:"rb-miniButton",style:{background:La==="P1"?"rgba(80,130,220,0.45)":void 0},onClick:()=>ml("P1"),children:["P1 Trash (",A.players.P1.trash.length,")"]}),o.jsxs("button",{className:"rb-miniButton",style:{background:La==="P2"?"rgba(80,130,220,0.45)":void 0},onClick:()=>ml("P2"),children:["P2 Trash (",A.players.P2.trash.length,")"]}),o.jsxs("div",{className:"rb-softText",children:["Selected ",xl.length,"/",i.maxCards]})]}),u.length===0?o.jsx("div",{className:"rb-softText",children:"Selected trash pile is empty."}):null,o.jsx("div",{className:"rb-pileGrid",children:[...u].slice().reverse().map(m=>{const v=`${La}:${m.instanceId}`,C=h.has(v);return o.jsxs("div",{style:{width:120,display:"flex",flexDirection:"column",alignItems:"center",gap:6},children:[o.jsx("button",{className:"rb-miniButton",style:{padding:4,borderRadius:10,border:C?"2px solid #22c55e":"1px solid rgba(255,255,255,0.22)",background:C?"rgba(34,197,94,0.18)":"rgba(20,28,44,0.85)",cursor:f?"pointer":"default"},onClick:()=>p(v),disabled:!f,children:o.jsx(jt,{card:m,size:"xs",showReadyDot:!1})}),o.jsx("div",{style:{fontSize:11,fontWeight:800,textAlign:"center",lineHeight:1.2},children:m.name})]},v)})}),o.jsxs("div",{style:{marginTop:12,display:"flex",justifyContent:"space-between",alignItems:"center",gap:10,flexWrap:"wrap"},children:[f?o.jsx("div",{className:"rb-softText",children:"Point-and-click cards from either trash, then confirm."}):o.jsxs("div",{className:"rb-softText",children:["Waiting for ",r,"..."]}),o.jsx("button",{className:"rb-miniButton",disabled:!f,onClick:b,children:"Confirm Selection"})]})]})]})})},S1=()=>{if(!A||!A.pendingDiscardSelection)return null;const i=A.pendingDiscardSelection,r=i.player,f=rt===r&&Ye(r)&&!Ln(r),u=A.players[r].hand,h=new Set(ta),p=C=>{f&&Tl(w=>w.includes(C)?w.filter(X=>X!==C):w.length>=i.maxCards?w:[...w,C])},b=()=>{Ze({type:"DISCARD_SELECTION_CONFIRM",player:r,selectionId:i.id,selectedInstanceIds:ta.slice(0,i.maxCards)})},m=i.minCards===i.maxCards,v=f&&ta.length>=i.minCards&&ta.length<=i.maxCards;return o.jsx("div",{className:"rb-modalOverlay",children:o.jsxs("div",{className:"rb-modal",onClick:C=>C.stopPropagation(),children:[o.jsxs("div",{className:"rb-modalHeader",children:[o.jsx("div",{style:{fontWeight:900},children:"Discard Selection"}),o.jsx("div",{className:"rb-softText",children:i.prompt})]}),o.jsxs("div",{className:"rb-modalBody",children:[u.length===0?o.jsx("div",{className:"rb-softText",children:"Hand is empty."}):null,o.jsx("div",{className:"rb-pileGrid",children:u.map(C=>{const w=h.has(C.instanceId);return o.jsxs("div",{style:{width:120,display:"flex",flexDirection:"column",alignItems:"center",gap:6},children:[o.jsx("button",{className:"rb-miniButton",style:{padding:4,borderRadius:10,border:w?"2px solid #ef4444":"1px solid rgba(255,255,255,0.22)",background:w?"rgba(239,68,68,0.20)":"rgba(20,28,44,0.85)",cursor:f?"pointer":"default"},onClick:()=>p(C.instanceId),disabled:!f,children:o.jsx(jt,{card:C,size:"xs",showReadyDot:!1})}),o.jsx("div",{style:{fontSize:11,fontWeight:800,textAlign:"center",lineHeight:1.2},children:C.name})]},C.instanceId)})}),o.jsxs("div",{style:{marginTop:12,display:"flex",justifyContent:"space-between",alignItems:"center",gap:10,flexWrap:"wrap"},children:[f?o.jsxs("div",{className:"rb-softText",children:["Selected ",ta.length,"/",i.maxCards,m?` (must select exactly ${i.minCards})`:""]}):o.jsxs("div",{className:"rb-softText",children:["Waiting for ",r,"..."]}),o.jsx("button",{className:"rb-miniButton",disabled:!v,onClick:b,children:"Confirm Discard"})]})]})]})})},A1=()=>{if(!A||!A.pendingDeckChoiceSelection)return null;const i=A.pendingDeckChoiceSelection,r=i.player,f=rt===r&&Ye(r)&&!Ln(r),u=new Set(na),h=m=>{f&&Nl(v=>v.includes(m)?v.filter(w=>w!==m):v.length>=i.maxCards?v:[...v,m])},p=()=>{Ze({type:"DECK_CHOICE_SELECTION_CONFIRM",player:r,selectionId:i.id,selectedInstanceIds:na.slice(0,i.maxCards)})},b=f&&na.length>=i.minCards&&na.length<=i.maxCards;return o.jsx("div",{className:"rb-modalOverlay",children:o.jsxs("div",{className:"rb-modal",onClick:m=>m.stopPropagation(),children:[o.jsxs("div",{className:"rb-modalHeader",children:[o.jsx("div",{style:{fontWeight:900},children:"Deck Choice"}),o.jsx("div",{className:"rb-softText",children:i.prompt})]}),o.jsxs("div",{className:"rb-modalBody",children:[o.jsx("div",{className:"rb-pileGrid",children:i.cards.map(m=>{const v=u.has(m.instanceId);return o.jsxs("div",{style:{width:128,display:"flex",flexDirection:"column",alignItems:"center",gap:6},children:[o.jsx("button",{className:"rb-miniButton",style:{padding:4,borderRadius:10,border:v?"2px solid #22c55e":"1px solid rgba(255,255,255,0.22)",background:v?"rgba(34,197,94,0.20)":"rgba(20,28,44,0.85)",cursor:f?"pointer":"default"},onClick:()=>h(m.instanceId),disabled:!f,children:o.jsx("div",{style:{width:112,height:156,borderRadius:10,border:"1px solid rgba(255,255,255,0.2)",background:"rgba(20,28,44,0.9)",overflow:"hidden",display:"flex",alignItems:"center",justifyContent:"center"},children:m.image_url||m.image?o.jsx("img",{src:m.image_url||m.image,alt:m.name,style:{width:"100%",height:"100%",objectFit:"cover"}}):o.jsx("div",{style:{fontSize:12,opacity:.9,textAlign:"center",padding:8},children:m.name})})}),o.jsx("div",{style:{fontSize:11,fontWeight:800,textAlign:"center",lineHeight:1.2},children:m.name})]},m.key)})}),o.jsxs("div",{style:{marginTop:12,display:"flex",justifyContent:"space-between",alignItems:"center",gap:10,flexWrap:"wrap"},children:[f?o.jsxs("div",{className:"rb-softText",children:["Selected ",na.length,"/",i.maxCards]}):o.jsxs("div",{className:"rb-softText",children:["Waiting for ",r,"..."]}),o.jsx("button",{className:"rb-miniButton",disabled:!b,onClick:p,children:"Confirm Choice"})]})]})]})})},R1=()=>{if(!A||!A.pendingRuneSelection)return null;const i=A.pendingRuneSelection,r=i.player,f=rt===r&&Ye(r)&&!Ln(r),u=A.players[r].runesInPlay,h=new Set(sa),p=v=>{f&&Il(C=>C.includes(v)?C.filter(K=>K!==v):C.length>=i.maxRunes?C:[...C,v])},b=()=>{Ze({type:"RUNE_SELECTION_CONFIRM",player:r,selectionId:i.id,selectedInstanceIds:sa.slice(0,i.maxRunes)})},m=f&&sa.length>=i.minRunes&&sa.length<=i.maxRunes;return o.jsx("div",{className:"rb-modalOverlay",children:o.jsxs("div",{className:"rb-modal",onClick:v=>v.stopPropagation(),children:[o.jsxs("div",{className:"rb-modalHeader",children:[o.jsx("div",{style:{fontWeight:900},children:"Rune Selection"}),o.jsx("div",{className:"rb-softText",children:i.prompt})]}),o.jsxs("div",{className:"rb-modalBody",children:[u.length===0?o.jsx("div",{className:"rb-softText",children:"No runes in play."}):null,o.jsx("div",{className:"rb-pileGrid",children:u.map(v=>{const C=h.has(v.instanceId);return o.jsxs("div",{style:{width:120,display:"flex",flexDirection:"column",alignItems:"center",gap:6},children:[o.jsxs("button",{className:"rb-miniButton",style:{width:112,minHeight:72,borderRadius:10,border:C?"2px solid #22c55e":"1px solid rgba(255,255,255,0.22)",background:C?"rgba(34,197,94,0.20)":"rgba(20,28,44,0.85)",cursor:f?"pointer":"default",display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",gap:4},onClick:()=>p(v.instanceId),disabled:!f,children:[o.jsx("div",{style:{fontSize:12,fontWeight:800},children:v.domain}),o.jsx("div",{style:{fontSize:11,opacity:.9},children:v.isReady?"Ready":"Exhausted"})]}),o.jsx("div",{style:{fontSize:11,fontWeight:700,textAlign:"center",lineHeight:1.2},children:v.name})]},v.instanceId)})}),o.jsxs("div",{style:{marginTop:12,display:"flex",justifyContent:"space-between",alignItems:"center",gap:10,flexWrap:"wrap"},children:[f?o.jsxs("div",{className:"rb-softText",children:["Selected ",sa.length,"/",i.maxRunes]}):o.jsxs("div",{className:"rb-softText",children:["Waiting for ",r,"..."]}),o.jsx("button",{className:"rb-miniButton",disabled:!m,onClick:b,children:"Confirm Rune"})]})]})]})})},vc=i=>(i||"").replace(/_/g," ").replace(/\[\s*add\s*\]\s*/gi,"add ").replace(/\s+/g," ").trim(),k1=i=>{const r=vc(i);if(!r)return[];r.toLowerCase();const f=[];return Uh(r)&&f.push("DISCARD"),Wu(r)&&f.push("DRAW"),$h(r)&&f.push("CHANNEL"),/\badd\s+\d+\s+energy\b/i.test(r)&&f.push("ADD_ENERGY"),/\badd\s+\d+\s+[a-z]+\s+rune\b/i.test(r)&&f.push("ADD_RUNE"),/\badd\s+\d+\s+rune\s+of\s+any\s+type\b/i.test(r)&&f.push("ADD_ANY_RUNE"),/\bplay\s+(?:(\d+|one|two|three|four|five|six|seven|eight|nine|ten)\s+)?(?:an?\s+)?\d+\s+might\s+[a-z]+\s+unit\s+token/i.test(r)&&f.push("TOKENS"),/\bgive\b/i.test(r)&&/\[[^\]]+\]/.test(r)&&f.push("KEYWORD_GRANT"),Gh(r)&&f.push("STUN"),zh(r)&&f.push("READY"),Yh(r)&&f.push("BUFF"),Hh(r)&&f.push("KILL"),Fh(r)&&f.push("BANISH"),qh(r)&&f.push("RETURN"),/\bgive\s+(?:a\s+)?(?:friendly\s+|enemy\s+|your\s+|opposing\s+)?(unit|units|me|it|this)\s+[+-]\s*\d+\s+might\s+this\s+turn\b/i.test(r)&&f.push("MIGHT_THIS_TURN"),(bu(r)!=null||/\bdeal\s+its\s+energy\s+cost\s+as\s+damage\b/i.test(r))&&f.push("DAMAGE"),f},D1=i=>{const r=String(i||"").trim();return r?r.split(/\s+/)[0]||r:""},P1=i=>{const r={one:1,two:2,three:3,four:4,five:5,six:6,seven:7,eight:8,nine:9,ten:10};if(!i)return null;if(/^\d+$/.test(i)){const f=parseInt(i,10);return Number.isFinite(f)?f:null}return r[i.toLowerCase()]??null},Wd=i=>{const r=[],f=new Set;for(const u of i){const h=String(u||"").trim();h&&(f.has(h)||(f.add(h),r.push(h)))}return r},_1=i=>{const r=(i||"").toLowerCase(),f=[];if(!r.trim())return{needsTargets:!1,count:0,restriction:"ANY",location:"ANY",notes:f};if(/\b(all|each)\s+(friendly|enemy|opposing|your)?\s*units\b/.test(r)){const X=/\benemy\b|\bopposing\b/.test(r)?"ENEMY":/\bfriendly\b|\byour\b/.test(r)?"FRIENDLY":"ANY",q=/\bhere\b/.test(r)?"HERE":/\bbattlefield\b/.test(r)?"BATTLEFIELD":"ANY";return f.push("global-units"),{needsTargets:!1,count:0,restriction:X,location:q,notes:f}}const u=r.match(/\bchoose\s+(?:up\s+to\s+)?(\d+|one|two|three|four|five)\s+units\b/),h=u?P1(u[1])??1:1,p=/\bunit\b/.test(r)||/\bunits\b/.test(r),b=/\bbattlefield\b/.test(r),m=/\bchoose\b/.test(r),v=p&&/\b(stun|kill|banish|ready|buff|deal|give|move|return|recall|heal)\b/.test(r)&&!/\b(all|each)\b/.test(r),C=b&&m&&/\b(battlefield)\b/.test(r),w=/\benemy\b|\bopposing\b/.test(r)?"ENEMY":/\bfriendly\b|\byour\b/.test(r)?"FRIENDLY":"ANY",K=/\bhere\b/.test(r)?"HERE":/\bat\s+a\s+battlefield\b/.test(r)?"BATTLEFIELD":"ANY";return h>1&&f.push(`multi-${h}`),w!=="ANY"&&f.push(w==="ENEMY"?"enemy-only":"friendly-only"),K!=="ANY"&&f.push(K==="HERE"?"here":"at-battlefield"),/\b(choose|target)\b/.test(r)&&f.push("explicit-select"),C?{needsTargets:!0,count:1,restriction:"ANY",location:"BATTLEFIELD",notes:[...f,"battlefield-target"]}:v?{needsTargets:!0,count:h,restriction:w,location:K,notes:f}:{needsTargets:!1,count:0,restriction:w,location:K,notes:f}},O1=(i,r,f)=>{const u=vc(i),h=u.toLowerCase(),p=String(r||"").trim(),b=[],m=[];p&&(/^When you play (me|this)$/i.test(p)||/^When this is played$/i.test(p)||/^When I'm played$/i.test(p)||/^When I attack$/i.test(p)||/^When I defend$/i.test(p)||/^When I attack or defend$/i.test(p)||/^When I defend or I'm played from$/i.test(p)||/^When I move$/i.test(p)||/^When I move to a battlefield$/i.test(p)||/^When you play a spell$/i.test(p)||/^When you play a spell that costs 5 energy or more$/i.test(p)||/^When you play a gear$/i.test(p)||/^When you play a unit$/i.test(p)||/^When you play another unit$/i.test(p)||/^When you play a \[Mighty\] unit$/i.test(p)||/^When you play your second card in a turn$/i.test(p)||/^When you play a card on an opponent's turn$/i.test(p)||/^When you play me to a battlefield$/i.test(p)||/^When you discard me$/i.test(p)||/^When you discard a card$/i.test(p)||/^When you discard one or more cards$/i.test(p)||/^When you stun an enemy unit$/i.test(p)||/^When you stun one or more enemy units$/i.test(p)||/^When a friendly unit attacks or defends alone$/i.test(p)||/^When you ready a friendly unit$/i.test(p)||/^When you buff a friendly unit$/i.test(p)||/^When a buffed friendly unit dies$/i.test(p)||/^When another non-Recruit unit you control dies$/i.test(p)||/^When a unit moves from here$/i.test(p)||/^When a friendly unit moves from my location$/i.test(p)||/^When you defend here$/i.test(p)||/^When an enemy unit attacks a battlefield you control$/i.test(p)||/^When you conquer$/i.test(p)||/^When you conquer here$/i.test(p)||/^When you hold here$/i.test(p)||/^When you kill a unit with a spell$/i.test(p)||/^When you kill a stunned enemy unit$/i.test(p)||/^If you've discarded a card this turn$/i.test(p)||/^If I have moved twice this turn$/i.test(p)||/^While I'm buffed$/i.test(p)||/^While I'm attacking or defending alone$/i.test(p)||/^While I'm \[Mighty\]$/i.test(p)||/^While I'm at a battlefield$/i.test(p)||/^While you have 8\+ runes$/i.test(p)||/^If an opponent's score is within 3 points of the Victory Score$/i.test(p)||/^If an enemy unit has died this turn$/i.test(p)||/^When you play a card from/i.test(p)||/^When you kill$/i.test(p)||/^When I conquer$/i.test(p)||/^When I conquer after an attack$/i.test(p)||/^When I hold$/i.test(p)||/^At the end of your turn$/i.test(p)||/^At the start of your Beginning Phase$/i.test(p)||/^At start of your Beginning Phase$/i.test(p)||/^At the start of each player's first Beginning Phase$/i.test(p)||m.push(`TRIGGER_UNSUPPORTED: ${p}`));const v=/\bif\s+this\s+kills\s+it,\s*draw\s+\d+\b/i.test(u),C=/if you do/i.test(h)||/if you control a poro/i.test(h)||/if you control a facedown card at a battlefield/i.test(h)||/if you have one or fewer cards in your hand/i.test(h)||/if you have 4\+ units at that battlefield/i.test(h)||/if you have 7\+ units here/i.test(h)||/if there is a ready enemy unit here/i.test(h)||/only unit you control there/i.test(h)||/if you can't/i.test(h)||/if you couldn't channel/i.test(h)||/if you've played another card this turn/i.test(h)||/if its might is less than another friendly unit's/i.test(h)||/if you assigned 5 or more excess damage to enemy units/i.test(h)||/if you paid (?:the )?additional cost/i.test(h)||/if it's already attached/i.test(h)||/if it's equipped/i.test(h)||/if the played card is a unit/i.test(h)||/if you would reveal cards from a deck/i.test(h)||/if you've discarded a card this turn/i.test(h)||/if i have moved twice this turn/i.test(h)||/if an opponent's score is within 3 points of the victory score/i.test(h)||/if an enemy unit has died this turn/i.test(h);/\bif\b/.test(h)&&!v&&!C&&m.push("CONDITIONAL_GENERAL"),/\bif\s+you\s+do\b/.test(h)&&m.push("IF_YOU_DO_BRANCH");const w=/next time it dies this turn/i.test(h)||/kill it the next time it takes damage this turn/i.test(h)||/kill this instead/i.test(h);/\binstead\b/.test(h)&&!w&&m.push("REPLACEMENT_EFFECT");const K=/draw 1 for each of your mighty units/i.test(h)||/for each buff spent, channel/i.test(h)||/for each friendly unit, you may spend its buff/i.test(h)||/for each friendly gear/i.test(h);/\bfor\s+each\b|\bfor\s+every\b/.test(h)&&!K&&m.push("SCALING_EFFECT"),/\bthis\s+turn\b/.test(h)&&/\b(when|whenever|each\s+time|the\s+next\s+time)\b/.test(h)&&(/\btakes\s+damage\b/.test(h)||/\bis\s+dealt\s+damage\b/.test(h)?m.push("TURN_SCOPED_DAMAGE_HOOK"):m.push("TURN_SCOPED_TRIGGER")),/\b(other|all)\s+friendly\s+units\s+enter\s+ready\b/i.test(u)&&m.push("CONTINUOUS_ENTER_READY"),/\b(other|all)\s+friendly\s+units\b/i.test(u)&&/\benter\s+ready\b/i.test(u)&&m.push("CONTINUOUS_ENTER_READY"),(/\bas\s+(?:an\s+)?additional\s+cost\b/.test(h)||/\bas\s+you\s+play\s+(?:me|this)\b/.test(h))&&m.push("ADDITIONAL_COST"),(/\bcost\s+\d+\s+(?:energy\s+)?less\b/.test(h)||/\breduce\s+my\s+cost\s+by\s+\d+\s+energy\b/.test(h))&&m.push("COST_MODIFIER"),Uh(u)!=null&&b.push("DISCARD_HAND_N"),Wu(u)!=null&&b.push("DRAW_N"),$h(u)!=null&&b.push("CHANNEL_N"),/\badd\s+\d+\s+energy\b/.test(h)&&b.push("ADD_ENERGY_N"),/\badd\s+\d+\s+[a-z]+\s+rune\b/.test(h)&&b.push("ADD_POWER_DOMAIN_N"),/\badd\s+\d+\s+rune\s+of\s+any\s+type\b/.test(h)&&b.push("ADD_POWER_ANY_N"),/\bplay\b/.test(h)&&/\bunit\s+token\b/.test(h)&&b.push("PLAY_TOKENS"),/\bgive\b/.test(h)&&/\[[^\]]+\]/.test(u)&&(/\bunits\b/.test(h)?b.push("GRANT_KEYWORD_MULTI"):b.push("GRANT_KEYWORD_SINGLE")),Gh(u)&&b.push("STUN_UNIT_SINGLE"),zh(u)&&b.push("READY_UNIT_SINGLE"),Yh(u)&&b.push("BUFF_PLUS1_PERM"),qh(u)&&b.push("RETURN_TO_BASE_SINGLE"),Hh(u)&&b.push("KILL_UNIT_SINGLE"),Fh(u)&&b.push("BANISH_UNIT_SINGLE");const X=h.match(/\bgive\s+(?:a\s+)?(?:friendly\s+|enemy\s+|your\s+|opposing\s+)?(unit|units|me|it|this)\s+([+-])\s*(\d+)\s+might\s+this\s+turn\b/);X&&(X[1]==="units"?/\benemy\b|\bopposing\b/.test(h)?b.push("MIGHT_THIS_TURN_UNITS_ENEMY"):/\bfriendly\b|\byour\b/.test(h)?b.push("MIGHT_THIS_TURN_UNITS_FRIENDLY"):b.push("MIGHT_THIS_TURN_UNITS_UNSPEC"):b.push("MIGHT_THIS_TURN_SINGLE"));const q=/\bdeal\s+its\s+energy\s+cost\s+as\s+damage\b/i.test(u),oe=bu(u);(q||oe!=null&&oe>0)&&(/\ball\s+units\s+at\s+battlefields\b/i.test(u)?b.push("DAMAGE_AOE_ALL_BATTLEFIELDS"):/\ball\s+units\s+here\b/i.test(u)?b.push("DAMAGE_AOE_HERE"):/\ball\s+enemy\s+units\b/i.test(u)||/\beach\s+enemy\s+unit\b/i.test(u)?b.push("DAMAGE_AOE_ENEMY"):q?b.push("DAMAGE_FROM_DISCARD_ENERGY_COST"):b.push("DAMAGE_SINGLE"),/\bif\s+this\s+kills\s+it,\s*draw\s+\d+\b/i.test(u)&&b.push("DRAW_ON_KILL")),/\bsearch\b/.test(h)&&m.push("SEARCH_NOT_SUPPORTED");const H=new Set(["Action","Reaction","Accelerate","Hidden","Legion","Vision","Assault","Shield","Tank","Deflect","Ganking","Add","Deathknell","Temporary","Mighty","Burn","Burnout","Play","Equip","Alone","Weaponmaster","Quick-Draw","Repeat","Fated","Overwhelm","Lifesteal"].map($=>$.toLowerCase())),O=Wd((f||[]).map($=>D1($)).filter(Boolean).filter($=>!H.has($.toLowerCase())));for(const $ of O)m.push(`KEYWORD_UNSUPPORTED: ${$}`);return/\bchoose\s+(?:up\s+to\s+)?(\d+|one|two|three|four|five)\s+units\b/.test(h)&&m.push("MULTI_TARGET_UNITS"),{text:u,primitives:Wd(b),flags:Wd(m)}},Ds=De.useMemo(()=>{var oe,H,O,$;const i=[],r=new Set(["DISCARD_HAND_N","DRAW_N","CHANNEL_N","ADD_ENERGY_N","ADD_POWER_DOMAIN_N","ADD_POWER_ANY_N","PLAY_TOKENS","GRANT_KEYWORD_SINGLE","STUN_UNIT_SINGLE","READY_UNIT_SINGLE","BUFF_PLUS1_PERM","RETURN_TO_BASE_SINGLE","KILL_UNIT_SINGLE","BANISH_UNIT_SINGLE","MIGHT_THIS_TURN_SINGLE","MIGHT_THIS_TURN_UNITS_FRIENDLY","MIGHT_THIS_TURN_UNITS_ENEMY","DAMAGE_SINGLE","DAMAGE_AOE_ENEMY","DAMAGE_AOE_ALL_BATTLEFIELDS","DAMAGE_AOE_HERE","DAMAGE_FROM_DISCARD_ENERGY_COST","DRAW_ON_KILL"]),f=["TRIGGER_UNSUPPORTED","CONDITIONAL_GENERAL","IF_YOU_DO_BRANCH","REPLACEMENT_EFFECT","SCALING_EFFECT","TURN_SCOPED_TRIGGER","TURN_SCOPED_DAMAGE_HOOK","CONTINUOUS_ENTER_READY","SEARCH_NOT_SUPPORTED","KEYWORD_UNSUPPORTED","MULTI_TARGET_UNITS"],u=j=>{const ue=String(j||"");return f.some(ve=>ue.startsWith(ve))};for(const j of e){const ue=(((oe=j.ability)==null?void 0:oe.effect_text)||"").trim(),ve=(((H=j.ability)==null?void 0:H.raw_text)||"").trim(),he=(((O=j.ability)==null?void 0:O.trigger)||"").trim(),Y=((($=j.ability)==null?void 0:$.keywords)||[]).slice(),ge=vc(ue||ve),R=O1(ge,he,Y),W=R.primitives,I=R.flags,Z=W.filter(ne=>r.has(ne)),ee=W.filter(ne=>!r.has(ne)),de=_1(ge),Re=I.filter(u),Se=Z.length,G=ee.length+Re.length;let be="NO_TEXT";ge?G===0?be="FULL":Se>0?be="PARTIAL":be="UNSUPPORTED":G===0?be="NO_TEXT":be=Se>0?"PARTIAL":"UNSUPPORTED",i.push({id:j.id,name:j.name,type:j.type,domain:j.domain,cost:Number(j.cost||0),trigger:he,keywords:Y,text:ge,raw:ve,primitives:W,primitivesSupported:Z,primitivesMissing:ee,flags:I,targetProfile:de,status:be})}const h=i.length,p=i.filter(j=>!!j.text).length,b=i.filter(j=>j.status==="FULL").length,m=i.filter(j=>j.status==="PARTIAL").length,v=i.filter(j=>j.status==="UNSUPPORTED").length,C=i.filter(j=>j.status==="NO_TEXT").length,w={},K={};for(const j of i){for(const ue of j.primitivesMissing)w[ue]=(w[ue]||0)+1;for(const ue of j.flags.filter(ve=>ve&&u(ve))){const ve=String(ue);K[ve]=(K[ve]||0)+1}}const X=Object.entries(w).sort((j,ue)=>ue[1]-j[1]).slice(0,12).map(([j,ue])=>({k:j,v:ue})),q=Object.entries(K).sort((j,ue)=>ue[1]-j[1]).slice(0,12).map(([j,ue])=>({k:j,v:ue}));return{total:h,withText:p,full:b,partial:m,unsupported:v,noText:C,rows:i,topMissingPrimitives:X,topMissingFlags:q}},[e]),Cc=De.useMemo(()=>{var u,h,p;const i=[];for(const b of e){const m=(((u=b.ability)==null?void 0:u.effect_text)||"").trim(),v=(((h=b.ability)==null?void 0:h.raw_text)||"").trim(),C=(((p=b.ability)==null?void 0:p.keywords)||[]).slice(),w=vc(m||v);if(!w)continue;const K=k1(w),X=K.length>0;i.push({id:b.id,name:b.name,text:w,keywords:C,supported:X,tags:K})}const r=i.filter(b=>b.supported).length,f=i.filter(b=>!b.supported);return{totalWithText:i.length,supportedCount:r,unsupportedCount:f.length,unsupportedRows:f}},[e]),B1=()=>{if(!tc)return null;const i=(Cl||"").toLowerCase().trim(),r=m=>({padding:"6px 10px",borderRadius:999,border:"1px solid rgba(255,255,255,0.18)",background:m?"rgba(255,255,255,0.12)":"rgba(0,0,0,0.22)",color:"#eef1f5",fontWeight:m?900:700,cursor:"pointer"}),f=m=>{const v={padding:"2px 8px",borderRadius:999,fontSize:11,fontWeight:900,border:"1px solid rgba(255,255,255,0.14)"};return m==="FULL"?{...v,background:"rgba(64, 220, 140, 0.18)",color:"#bff7da"}:m==="PARTIAL"?{...v,background:"rgba(250, 200, 70, 0.18)",color:"#ffe7b8"}:m==="UNSUPPORTED"?{...v,background:"rgba(250, 90, 90, 0.18)",color:"#ffd1d1"}:{...v,background:"rgba(160, 160, 160, 0.16)",color:"#d7dde7"}},u=Cc.unsupportedRows.filter(m=>i?m.name.toLowerCase().includes(i)||m.text.toLowerCase().includes(i):!0).slice(0,250),h=(()=>{let m=Ds.rows;return ia!=="ALL"&&(ia==="PROBLEMS"?m=m.filter(v=>v.status==="PARTIAL"||v.status==="UNSUPPORTED"):m=m.filter(v=>v.status===ia)),i&&(m=m.filter(v=>{const C=(v.name||"").toLowerCase(),w=(v.text||"").toLowerCase(),K=(v.trigger||"").toLowerCase(),X=v.primitives.join(" ").toLowerCase(),q=v.flags.join(" ").toLowerCase();return C.includes(i)||w.includes(i)||K.includes(i)||X.includes(i)||q.includes(i)})),m.slice(0,350)})(),p=async()=>{const m=JSON.stringify(Ds,null,2);try{await navigator.clipboard.writeText(m),alert("Audit JSON copied to clipboard.")}catch{window.prompt("Copy audit JSON:",m)}},b=async()=>{const m=JSON.stringify({meta:{filter:ia,search:Cl,generatedAt:new Date().toISOString()},rows:h},null,2);try{await navigator.clipboard.writeText(m),alert("Filtered audit JSON copied to clipboard.")}catch{window.prompt("Copy filtered audit JSON:",m)}};return o.jsx("div",{className:"rb-modalOverlay",onClick:()=>vl(!1),children:o.jsxs("div",{className:"rb-modal",onClick:m=>m.stopPropagation(),children:[o.jsxs("div",{className:"rb-modalHeader",children:[o.jsxs("div",{style:{display:"flex",gap:10,alignItems:"center",flexWrap:"wrap"},children:[o.jsx("div",{style:{fontWeight:900},children:"Effect Diagnostics"}),o.jsxs("div",{style:{display:"flex",gap:8,flexWrap:"wrap"},children:[o.jsx("button",{style:r(Xs==="UNSUPPORTED"),onClick:()=>Or("UNSUPPORTED"),children:"Unsupported List"}),o.jsx("button",{style:r(Xs==="AUDIT"),onClick:()=>Or("AUDIT"),children:"Full Audit"})]})]}),o.jsxs("div",{style:{display:"flex",gap:8,flexWrap:"wrap",justifyContent:"flex-end"},children:[Xs==="AUDIT"?o.jsxs(o.Fragment,{children:[o.jsx("button",{className:"rb-miniButton",onClick:b,children:"Copy filtered JSON"}),o.jsx("button",{className:"rb-miniButton",onClick:p,children:"Copy full JSON"})]}):null,o.jsx("button",{className:"rb-miniButton",onClick:()=>vl(!1),children:"Close"})]})]}),o.jsxs("div",{className:"rb-modalBody",children:[o.jsxs("div",{style:{display:"flex",gap:12,flexWrap:"wrap",alignItems:"center",marginBottom:10},children:[Xs==="UNSUPPORTED"?o.jsxs("div",{className:"rb-softTextSmall",children:["Cards with ability text: ",o.jsx("b",{children:Cc.totalWithText})," • Supported: ",o.jsx("b",{children:Cc.supportedCount})," • Unsupported: ",o.jsx("b",{children:Cc.unsupportedCount})]}):o.jsxs("div",{className:"rb-softTextSmall",children:["Total cards: ",o.jsx("b",{children:Ds.total})," • With text: ",o.jsx("b",{children:Ds.withText})," • Full: ",o.jsx("b",{children:Ds.full})," • Partial: ",o.jsx("b",{children:Ds.partial})," • Unsupported: ",o.jsx("b",{children:Ds.unsupported})," • No-text: ",o.jsx("b",{children:Ds.noText})]}),o.jsx("input",{value:Cl,onChange:m=>nc(m.target.value),placeholder:Xs==="AUDIT"?"Search card / primitive / flag...":"Search card/effect...",style:{flex:"1 1 280px",padding:"8px 10px",borderRadius:10,border:"1px solid rgba(255,255,255,0.16)",background:"rgba(0,0,0,0.25)",color:"#eef1f5"}}),Xs==="AUDIT"?o.jsxs("span",{style:{display:"flex",gap:8,alignItems:"center"},children:[o.jsx("span",{className:"rb-softTextSmall",children:"Status:"}),o.jsxs("select",{value:ia,onChange:m=>sc(m.target.value),style:{padding:"6px 8px",borderRadius:10,border:"1px solid rgba(255,255,255,0.18)",background:"rgba(0,0,0,0.25)",color:"#eef1f5"},children:[o.jsx("option",{value:"PROBLEMS",children:"Problems (Partial + Unsupported)"}),o.jsx("option",{value:"ALL",children:"All"}),o.jsx("option",{value:"FULL",children:"Full"}),o.jsx("option",{value:"PARTIAL",children:"Partial"}),o.jsx("option",{value:"UNSUPPORTED",children:"Unsupported"}),o.jsx("option",{value:"NO_TEXT",children:"No text"})]})]}):null]}),Xs==="UNSUPPORTED"?u.length===0?o.jsx("div",{className:"rb-softText",children:"No unsupported effects match the filter."}):o.jsx("div",{style:{display:"flex",flexDirection:"column",gap:10},children:u.map(m=>o.jsxs("div",{style:{border:"1px solid rgba(255,255,255,0.10)",borderRadius:12,padding:10,background:"rgba(0,0,0,0.18)"},children:[o.jsxs("div",{style:{display:"flex",justifyContent:"space-between",gap:10,alignItems:"center"},children:[o.jsx("div",{style:{fontWeight:900},children:m.name}),o.jsx("div",{className:"rb-softTextSmall",children:m.keywords&&m.keywords.length?m.keywords.join(" • "):""})]}),o.jsx("div",{className:"rb-softTextSmall",style:{marginTop:6,whiteSpace:"pre-wrap"},children:m.text})]},m.id))}):o.jsxs(o.Fragment,{children:[o.jsxs("div",{style:{display:"grid",gridTemplateColumns:"1fr 1fr",gap:10,marginBottom:10},children:[o.jsxs("div",{style:{border:"1px solid rgba(255,255,255,0.10)",borderRadius:12,padding:10,background:"rgba(0,0,0,0.16)"},children:[o.jsx("div",{style:{fontWeight:900,marginBottom:6},children:"Top missing primitives"}),Ds.topMissingPrimitives.length===0?o.jsx("div",{className:"rb-softTextSmall",children:"(none)"}):o.jsx("div",{style:{display:"flex",flexWrap:"wrap",gap:6},children:Ds.topMissingPrimitives.map(m=>o.jsxs("span",{style:{padding:"3px 8px",borderRadius:999,border:"1px solid rgba(255,255,255,0.14)",fontSize:11,background:"rgba(0,0,0,0.22)"},children:[m.k," • ",m.v]},m.k))})]}),o.jsxs("div",{style:{border:"1px solid rgba(255,255,255,0.10)",borderRadius:12,padding:10,background:"rgba(0,0,0,0.16)"},children:[o.jsx("div",{style:{fontWeight:900,marginBottom:6},children:"Top missing structural flags"}),Ds.topMissingFlags.length===0?o.jsx("div",{className:"rb-softTextSmall",children:"(none)"}):o.jsx("div",{style:{display:"flex",flexWrap:"wrap",gap:6},children:Ds.topMissingFlags.map(m=>o.jsxs("span",{style:{padding:"3px 8px",borderRadius:999,border:"1px solid rgba(255,255,255,0.14)",fontSize:11,background:"rgba(0,0,0,0.22)"},children:[m.k," • ",m.v]},m.k))})]})]}),h.length===0?o.jsx("div",{className:"rb-softText",children:"No cards match the current audit filter."}):o.jsx("div",{style:{display:"flex",flexDirection:"column",gap:10},children:h.map(m=>{const v=ic===m.id,C=[...m.primitivesMissing,...m.flags.filter(w=>/^TRIGGER_UNSUPPORTED|^CONDITIONAL_GENERAL|^IF_YOU_DO_BRANCH|^REPLACEMENT_EFFECT|^SCALING_EFFECT|^TURN_SCOPED_TRIGGER|^TURN_SCOPED_DAMAGE_HOOK|^CONTINUOUS_ENTER_READY|^ADDITIONAL_COST|^COST_MODIFIER|^SEARCH_NOT_SUPPORTED|^REVEAL_NOT_SUPPORTED|^MOVE_EFFECT_NOT_SUPPORTED|^KEYWORD_UNSUPPORTED|^MULTI_TARGET_UNITS/.test(w))];return o.jsxs("div",{style:{border:"1px solid rgba(255,255,255,0.10)",borderRadius:12,padding:10,background:"rgba(0,0,0,0.18)"},children:[o.jsxs("div",{style:{display:"flex",justifyContent:"space-between",gap:10,alignItems:"center"},children:[o.jsxs("div",{style:{display:"flex",gap:10,alignItems:"center",minWidth:0},children:[o.jsx("button",{className:"rb-miniButton",onClick:()=>y(w=>w===m.id?null:m.id),style:{padding:"6px 10px"},children:v?"Hide":"Details"}),o.jsxs("div",{style:{minWidth:0},children:[o.jsx("div",{style:{fontWeight:900,whiteSpace:"nowrap",overflow:"hidden",textOverflow:"ellipsis"},children:m.name}),o.jsxs("div",{className:"rb-softTextSmall",children:[m.type," • ",m.domain," • Cost ",m.cost,m.targetProfile.needsTargets?` • Targets: ${m.targetProfile.count} (${m.targetProfile.restriction}, ${m.targetProfile.location})`:""]})]})]}),o.jsx("div",{style:{display:"flex",gap:8,alignItems:"center",flexWrap:"wrap",justifyContent:"flex-end"},children:o.jsx("span",{style:f(m.status),children:m.status})})]}),o.jsxs("div",{style:{display:"flex",flexWrap:"wrap",gap:6,marginTop:8},children:[C.slice(0,10).map(w=>o.jsx("span",{style:{padding:"3px 8px",borderRadius:999,border:"1px solid rgba(255,255,255,0.12)",fontSize:11,background:"rgba(255, 120, 120, 0.10)"},children:w},w)),C.length>10?o.jsxs("span",{style:{padding:"3px 8px",borderRadius:999,border:"1px solid rgba(255,255,255,0.12)",fontSize:11,background:"rgba(0,0,0,0.22)"},children:["+",C.length-10," more"]}):null]}),v?o.jsxs("div",{style:{marginTop:10,display:"grid",gridTemplateColumns:"1fr",gap:8},children:[m.trigger?o.jsxs("div",{className:"rb-softTextSmall",children:[o.jsx("b",{children:"Trigger:"})," ",m.trigger]}):null,m.keywords&&m.keywords.length?o.jsxs("div",{className:"rb-softTextSmall",children:[o.jsx("b",{children:"Keywords:"})," ",m.keywords.join(" • ")]}):null,m.text?o.jsxs("div",{className:"rb-softTextSmall",style:{whiteSpace:"pre-wrap"},children:[o.jsx("b",{children:"Text:"})," ",m.text]}):o.jsx("div",{className:"rb-softTextSmall",children:"(No effect text)"}),o.jsxs("div",{className:"rb-softTextSmall",children:[o.jsx("b",{children:"Primitives:"})," ",m.primitives.length?m.primitives.join(", "):"(none)"]}),o.jsxs("div",{className:"rb-softTextSmall",children:[o.jsx("b",{children:"Supported primitives:"})," ",m.primitivesSupported.length?m.primitivesSupported.join(", "):"(none)"]}),o.jsxs("div",{className:"rb-softTextSmall",children:[o.jsx("b",{children:"Missing primitives:"})," ",m.primitivesMissing.length?m.primitivesMissing.join(", "):"(none)"]}),o.jsxs("div",{className:"rb-softTextSmall",children:[o.jsx("b",{children:"Flags:"})," ",m.flags.length?m.flags.join(" • "):"(none)"]}),o.jsx("div",{style:{display:"flex",gap:8,flexWrap:"wrap"},children:o.jsx("button",{className:"rb-miniButton",onClick:async()=>{const w=JSON.stringify(m,null,2);try{await navigator.clipboard.writeText(w),alert("Card audit JSON copied.")}catch{window.prompt("Copy card audit JSON:",w)}},children:"Copy card JSON"})})]}):null]},m.id)})}),o.jsxs("div",{className:"rb-softTextSmall",style:{marginTop:12},children:["Notes:",o.jsxs("ul",{style:{margin:"6px 0 0 18px"},children:[o.jsx("li",{children:"“Primitives” are the small effect operations the emulator can (or can’t) execute today. A single card may need multiple primitives."}),o.jsx("li",{children:"“Flags” are structural capabilities that typically require new engine hooks (e.g., continuous effects, turn-scoped triggers, multi-target selection)."}),o.jsx("li",{children:"This audit is heuristic and may produce false positives; it’s designed to guide implementation work quickly, not to be an oracle."})]})]})]}),Xs==="UNSUPPORTED"?o.jsx("div",{className:"rb-softTextSmall",style:{marginTop:12},children:"Note: “Supported” here means the emulator has a parser/handler for at least one operation in the text. Many cards still have static / continuous effects that are not yet fully modeled."}):null]})]})})},M1=()=>A?o.jsxs("div",{style:{padding:16},children:[o.jsxs("div",{style:{marginTop:12,display:"flex",gap:10,alignItems:"center"},children:[o.jsx("button",{onClick:fy,children:"Reset Game"}),o.jsx("button",{onClick:cy,children:Ei?"Hide Hands (hotseat)":"Reveal Hands (hotseat)"}),o.jsx("button",{onClick:uy,children:Ws?"Hide Facedown (hotseat)":"Reveal Facedown (hotseat)"}),o.jsx("button",{onClick:dy,children:Ti?"Hide Decks (hotseat)":"Reveal Decks (hotseat)"}),o.jsxs("span",{style:{fontSize:12,color:"#ddd"},children:["You are “playing as”:",o.jsxs("select",{value:rt,onChange:i=>Ji(i.target.value),style:{marginLeft:6},children:[o.jsx("option",{value:"P1",children:"P1"}),o.jsx("option",{value:"P2",children:"P2"})]})]}),o.jsx("button",{disabled:!Ye(rt)||A.turnPlayer!==rt||A.chain.length>0||A.windowKind!=="NONE"||A.state!=="OPEN",onClick:()=>Gd(),children:"Next Step"})]}),o.jsxs("div",{style:{marginTop:12,display:"flex",gap:12},children:[ky("P1"),ky("P2")]}),f1(),g1(),h1(),p1(),b1()]}):null,L1=()=>{var m;if(!V)return null;const{chooser:i,gameNumber:r}=V,f=B!==null,u=(B==null?void 0:B.P1)??0,h=(B==null?void 0:B.P2)??0,p=(B==null?void 0:B.winner)??i,b=(m=Ot[i])==null?void 0:m.enabled;return o.jsx("div",{style:{position:"fixed",inset:0,background:"rgba(0,0,0,0.8)",display:"flex",alignItems:"center",justifyContent:"center",padding:16,zIndex:100},children:o.jsxs("div",{style:{width:500,maxWidth:"95vw",background:"#111827",border:"2px solid #374151",borderRadius:16,padding:24,textAlign:"center"},children:[f?o.jsxs(o.Fragment,{children:[o.jsxs("div",{style:{fontSize:24,fontWeight:900,marginBottom:16},children:["Dice Roll - Game ",r]}),o.jsxs("div",{style:{display:"flex",justifyContent:"center",gap:40,marginBottom:20},children:[o.jsxs("div",{style:{textAlign:"center"},children:[o.jsx("div",{style:{fontSize:14,opacity:.8,marginBottom:8},children:"P1"}),o.jsx("div",{style:{width:80,height:80,background:p==="P1"?"#10b981":"#374151",borderRadius:12,display:"flex",alignItems:"center",justifyContent:"center",fontSize:36,fontWeight:900,border:p==="P1"?"3px solid #34d399":"3px solid #4b5563"},children:u})]}),o.jsxs("div",{style:{textAlign:"center"},children:[o.jsx("div",{style:{fontSize:14,opacity:.8,marginBottom:8},children:"P2"}),o.jsx("div",{style:{width:80,height:80,background:p==="P2"?"#10b981":"#374151",borderRadius:12,display:"flex",alignItems:"center",justifyContent:"center",fontSize:36,fontWeight:900,border:p==="P2"?"3px solid #34d399":"3px solid #4b5563"},children:h})]})]}),o.jsxs("div",{style:{fontSize:16,marginBottom:20},children:[o.jsx("b",{children:p})," wins the dice roll and chooses who goes first!"]})]}):o.jsxs(o.Fragment,{children:[o.jsxs("div",{style:{fontSize:24,fontWeight:900,marginBottom:16},children:["Choose Starting Player - Game ",r]}),o.jsxs("div",{style:{fontSize:16,marginBottom:20},children:[o.jsx("b",{children:i})," lost the previous game and chooses who goes first."]})]}),b?o.jsx("div",{style:{fontSize:14,opacity:.8},children:"AI is choosing..."}):o.jsxs("div",{style:{display:"flex",justifyContent:"center",gap:16},children:[o.jsx("button",{style:{padding:"12px 24px",borderRadius:8,border:"none",background:"#10b981",color:"white",fontSize:16,fontWeight:700,cursor:"pointer"},onClick:()=>vd(i),children:"I go first"}),o.jsx("button",{style:{padding:"12px 24px",borderRadius:8,border:"none",background:"#6366f1",color:"white",fontSize:16,fontWeight:700,cursor:"pointer"},onClick:()=>vd(i==="P1"?"P2":"P1"),children:"Opponent goes first"})]})]})})},j1=()=>{if(!A||A.step!=="GAME_OVER"||(D==null?void 0:D.format)==="BO3")return null;const i=Nd(A);return o.jsx("div",{style:{position:"fixed",inset:0,background:"rgba(0,0,0,0.8)",display:"flex",alignItems:"center",justifyContent:"center",padding:16,zIndex:100},children:o.jsxs("div",{style:{width:500,maxWidth:"95vw",background:"#111827",border:"2px solid #374151",borderRadius:16,padding:24,textAlign:"center"},children:[o.jsx("div",{style:{fontSize:28,fontWeight:900,marginBottom:12},children:"Game Over"}),o.jsx("div",{style:{fontSize:20,marginBottom:24},children:i?o.jsxs(o.Fragment,{children:[o.jsx("b",{style:{color:"#10b981"},children:i})," wins!"]}):"Draw!"}),o.jsxs("div",{style:{fontSize:14,opacity:.8,marginBottom:20},children:["P1: ",A.players.P1.points," points | P2: ",A.players.P2.points," points"]}),o.jsxs("div",{style:{display:"flex",justifyContent:"center",gap:16,flexWrap:"wrap"},children:[o.jsx("button",{style:{padding:"12px 24px",borderRadius:8,border:"none",background:"#374151",color:"white",fontSize:14,fontWeight:600,cursor:"pointer"},onClick:()=>{fe(null),s(null),d("DECK_BUILDER")},children:"Return to Deck Building"}),o.jsx("button",{style:{padding:"12px 24px",borderRadius:8,border:"none",background:"#10b981",color:"white",fontSize:14,fontWeight:600,cursor:"pointer"},onClick:()=>{fe(null),s(null),Id()},children:"Play Again (Same Decks)"})]})]})})},$1=()=>{if(!A||A.step!=="GAME_OVER"||!le)return null;const i=le.matchStateAfterCommit,r=i.gamesCompleted+1,f=(b,m)=>{const v=[];ls(m.sideboard||{})>8&&v.push("Sideboard must contain at most 8 cards.");try{Ml(e,b,m,1)}catch(w){v.push(String((w==null?void 0:w.message)||w))}return v},u={P1:f("P1",ye.P1||vn()),P2:f("P2",ye.P2||vn())},h=u.P1.length===0&&u.P2.length===0,p=b=>{const m=ye[b]||vn(),v=m.main||{},C=m.sideboard||{},w=ls(v),K=ls(C),X=Object.entries(v).map(([H,O])=>({id:H,n:Math.floor(O||0),card:wn(e,H)})).filter(H=>!!H.card&&H.n>0&&lr(H.card.type)).sort((H,O)=>H.card.name.localeCompare(O.card.name)),q=Object.entries(C).map(([H,O])=>({id:H,n:Math.floor(O||0),card:wn(e,H)})).filter(H=>!!H.card&&H.n>0&&lr(H.card.type)).sort((H,O)=>H.card.name.localeCompare(O.card.name)),oe=u[b];return o.jsxs("div",{style:{flex:1,minWidth:280,border:"1px solid #374151",borderRadius:10,padding:12,background:"#0f172a"},children:[o.jsxs("div",{style:{fontWeight:800,marginBottom:6},children:[b," Sideboarding"]}),o.jsxs("div",{className:"rb-softText",style:{marginBottom:8},children:["Main ",w," cards • Sideboard ",K,"/8"]}),o.jsxs("div",{style:{display:"grid",gridTemplateColumns:"1fr 1fr",gap:10},children:[o.jsxs("div",{style:{border:"1px solid rgba(255,255,255,0.08)",borderRadius:8,padding:8,maxHeight:280,overflow:"auto"},children:[o.jsx("div",{style:{fontWeight:700,fontSize:12,marginBottom:6},children:"Main Deck"}),X.length===0?o.jsx("div",{className:"rb-softText",children:"—"}):null,X.map(H=>o.jsxs("div",{style:{display:"flex",justifyContent:"space-between",gap:8,alignItems:"center",marginBottom:6},children:[o.jsxs("div",{style:{fontSize:12,minWidth:0,overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"},children:[H.card.name," ×",H.n]}),o.jsx("button",{className:"rb-miniButton",disabled:K>=8,onClick:()=>kn(b,O=>{const $=Math.floor((O.main||{})[H.id]||0),j=ls(O.sideboard||{});return $<=0||j>=8?O:{...O,main:Un(O.main||{},H.id,-1,0,3),sideboard:Un(O.sideboard||{},H.id,1,0,null)}}),title:"Move one copy to sideboard",children:"To Side"})]},`main_${b}_${H.id}`))]}),o.jsxs("div",{style:{border:"1px solid rgba(255,255,255,0.08)",borderRadius:8,padding:8,maxHeight:280,overflow:"auto"},children:[o.jsx("div",{style:{fontWeight:700,fontSize:12,marginBottom:6},children:"Sideboard"}),q.length===0?o.jsx("div",{className:"rb-softText",children:"—"}):null,q.map(H=>o.jsxs("div",{style:{display:"flex",justifyContent:"space-between",gap:8,alignItems:"center",marginBottom:6},children:[o.jsxs("div",{style:{fontSize:12,minWidth:0,overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"},children:[H.card.name," ×",H.n]}),o.jsx("button",{className:"rb-miniButton",disabled:Math.floor(v[H.id]||0)>=3,onClick:()=>kn(b,O=>{const $=Math.floor((O.sideboard||{})[H.id]||0),j=Math.floor((O.main||{})[H.id]||0);return $<=0||j>=3?O:{...O,main:Un(O.main||{},H.id,1,0,3),sideboard:Un(O.sideboard||{},H.id,-1,0,null)}}),title:"Move one copy to main deck",children:"To Main"})]},`side_${b}_${H.id}`))]})]}),oe.length>0?o.jsx("div",{style:{marginTop:8,fontSize:12,color:"#fca5a5"},children:oe.map((H,O)=>o.jsx("div",{children:H},`${b}_err_${O}`))}):null]})};return o.jsx("div",{style:{position:"fixed",inset:0,background:"rgba(0,0,0,0.86)",display:"flex",alignItems:"center",justifyContent:"center",padding:16,zIndex:120},children:o.jsxs("div",{style:{width:1120,maxWidth:"98vw",maxHeight:"95vh",overflow:"auto",background:"#111827",border:"2px solid #374151",borderRadius:14,padding:16},children:[o.jsx("div",{style:{fontSize:22,fontWeight:900,marginBottom:8},children:"Between Games: Sideboarding"}),o.jsxs("div",{className:"rb-softText",style:{marginBottom:10},children:["Game ",i.gamesCompleted," complete. Winner: ",o.jsx("b",{children:le.lastGameWinner??"Unknown"}),". Next game: ",o.jsxs("b",{children:["Game ",r]})," • Match score P1 ",i.wins.P1,"-",i.wins.P2," P2."]}),o.jsx("div",{className:"rb-softText",style:{marginBottom:12},children:"Swap cards between main and sideboard, then start the next game."}),o.jsxs("div",{style:{display:"flex",gap:12,flexWrap:"wrap"},children:[p("P1"),p("P2")]}),o.jsxs("div",{style:{marginTop:14,display:"flex",justifyContent:"space-between",gap:12,flexWrap:"wrap",alignItems:"center"},children:[o.jsx("div",{className:"rb-softText",children:h?"Decks valid for next game.":"Fix deck errors before starting the next game."}),o.jsxs("button",{className:"rb-bigButton",style:{maxWidth:320},disabled:!h,onClick:Gx,children:["Start Game ",r]})]})]})})},U1=()=>{var q,oe;if(!A||!D||D.format!=="BO3")return null;const i=D.wins.P1>=2||D.wins.P2>=2,r=D.gamesCompleted+1,f=wl("P1"),u=wl("P2"),h=f.filter(H=>!D.usedBattlefieldIds.P1.includes(H.id)),p=u.filter(H=>!D.usedBattlefieldIds.P2.includes(H.id)),b=h.length>0?h:f,m=p.length>0?p:u,v=A.step==="GAME_OVER"?Nd(A):null,C={...D.wins};A.step==="GAME_OVER"&&v&&!i&&(C[v]=(C[v]||0)+1);const w=C.P1>=2||C.P2>=2,K=!!le,X=D.wins.P1>=2?"P1":D.wins.P2>=2?"P2":null;return o.jsx("div",{style:{maxWidth:1150,margin:"10px auto 0"},className:"rb-panel",children:o.jsxs("div",{style:{display:"flex",gap:14,alignItems:"center",justifyContent:"space-between",flexWrap:"wrap"},children:[o.jsxs("div",{style:{minWidth:240},children:[o.jsx("div",{style:{fontWeight:900,fontSize:14},children:"Best of 3 Match"}),o.jsxs("div",{className:"rb-softText",children:["Game ",r," • Score P1 ",D.wins.P1,"-",D.wins.P2," P2"]}),A.step==="GAME_OVER"?o.jsxs("div",{className:"rb-softText",style:{marginTop:4},children:["Game winner: ",o.jsx("b",{children:v??"Unknown"})]}):null,X?o.jsxs("div",{className:"rb-softText",style:{marginTop:4},children:["Match winner: ",o.jsx("b",{children:X})]}):null]}),A.step==="GAME_OVER"&&!i&&!K?o.jsxs("div",{style:{display:"flex",gap:10,alignItems:"center",flexWrap:"wrap"},children:[o.jsx("span",{className:"rb-softText",children:"Next game battlefields:"}),o.jsx("span",{className:"rb-softText",children:"P1"}),o.jsx("select",{value:me.P1??((q=b[0])==null?void 0:q.id)??"",onChange:H=>M(O=>({...O,P1:H.target.value||null})),disabled:b.length===0,children:b.map(H=>o.jsx("option",{value:H.id,children:H.name},H.id))}),o.jsx("span",{className:"rb-softText",children:"P2"}),o.jsx("select",{value:me.P2??((oe=m[0])==null?void 0:oe.id)??"",onChange:H=>M(O=>({...O,P2:H.target.value||null})),disabled:m.length===0,children:m.map(H=>o.jsx("option",{value:H.id,children:H.name},H.id))}),o.jsx("button",{className:"rb-miniButton",onClick:Ux,children:w?"Commit result":"Commit result & sideboard"}),h.length===0||p.length===0?o.jsx("span",{className:"rb-softText",style:{opacity:.8},children:"(No unused battlefields left for at least one player; reusing is allowed as a fallback.)"}):null]}):null,A.step==="GAME_OVER"&&!i&&K?o.jsxs("div",{className:"rb-softText",children:["Result committed. Complete sideboarding in the modal to start Game ",D.gamesCompleted+1,"."]}):null,A.step==="GAME_OVER"&&X?o.jsx("div",{style:{display:"flex",gap:10,alignItems:"center",flexWrap:"wrap"},children:o.jsx("button",{className:"rb-miniButton",onClick:()=>{var $,j;N("BO3"),z(null),fe(null);const H=wl("P1"),O=wl("P2");M({P1:(($=H[0])==null?void 0:$.id)??null,P2:((j=O[0])==null?void 0:j.id)??null}),Id("BO3")},children:"Start new BO3 match"})}):null]})})};return o.jsxs("div",{className:"rb-root",children:[o.jsx("style",{children:m1}),o.jsxs("div",{className:"rb-topbar",children:[o.jsxs("div",{style:{display:"flex",gap:12,alignItems:"baseline",minWidth:0},children:[o.jsx("div",{className:"rb-title",children:"Riftbound Duel Emulator"}),o.jsx("div",{style:{fontSize:12,opacity:.85,whiteSpace:"nowrap",overflow:"hidden",textOverflow:"ellipsis"},children:A?`Turn ${A.turnNumber} • Step: ${A.step} • Turn player: ${A.turnPlayer}`:"Load card data to begin"})]}),o.jsxs("div",{className:"rb-topbarControls",children:[o.jsxs("span",{style:{fontSize:12,opacity:.9},children:["UI:",o.jsxs("select",{value:Qs,onChange:i=>gl(i.target.value),style:{marginLeft:6},children:[o.jsx("option",{value:"Arena",children:"Arena"}),o.jsx("option",{value:"Classic",children:"Classic"})]})]}),o.jsx("button",{onClick:fy,disabled:!A,children:"Reset"}),o.jsx("button",{onClick:cy,disabled:!A,children:Ei?"Hide Hands (hotseat)":"Reveal Hands (hotseat)"}),o.jsx("button",{onClick:uy,disabled:!A,children:Ws?"Hide Facedown (hotseat)":"Reveal Facedown (hotseat)"}),o.jsx("button",{onClick:dy,disabled:!A,children:Ti?"Hide Decks (hotseat)":"Reveal Decks (hotseat)"}),o.jsx("button",{onClick:()=>vl(!0),disabled:e.length===0,children:"Diagnostics"}),o.jsxs("span",{style:{fontSize:12,opacity:.9},children:["Playing as:",o.jsxs("select",{value:rt,onChange:i=>Ji(i.target.value),style:{marginLeft:6},children:[o.jsx("option",{value:"P1",children:"P1"}),o.jsx("option",{value:"P2",children:"P2"})]})]}),o.jsxs("span",{style:{fontSize:12,opacity:.9},children:["AI P1:",o.jsxs("select",{value:Ot.P1.enabled?Ot.P1.difficulty:"HUMAN",onChange:i=>{const r=i.target.value;Xi(f=>({...f,P1:r==="HUMAN"?{...f.P1,enabled:!1}:{...f.P1,enabled:!0,difficulty:r}}))},style:{marginLeft:6},children:[o.jsx("option",{value:"HUMAN",children:"Human"}),o.jsx("option",{value:"EASY",children:"Easy"}),o.jsx("option",{value:"MEDIUM",children:"Medium"}),o.jsx("option",{value:"HARD",children:"Hard"}),o.jsx("option",{value:"VERY_HARD",children:"Very Hard"})]})]}),o.jsxs("span",{style:{fontSize:12,opacity:.9},children:["AI P2:",o.jsxs("select",{value:Ot.P2.enabled?Ot.P2.difficulty:"HUMAN",onChange:i=>{const r=i.target.value;Xi(f=>({...f,P2:r==="HUMAN"?{...f.P2,enabled:!1}:{...f.P2,enabled:!0,difficulty:r}}))},style:{marginLeft:6},children:[o.jsx("option",{value:"HUMAN",children:"Human"}),o.jsx("option",{value:"EASY",children:"Easy"}),o.jsx("option",{value:"MEDIUM",children:"Medium"}),o.jsx("option",{value:"HARD",children:"Hard"}),o.jsx("option",{value:"VERY_HARD",children:"Very Hard"})]})]}),o.jsxs("span",{style:{fontSize:12,opacity:.9},children:["AI delay:",o.jsx("input",{type:"number",min:0,max:2500,step:50,value:Ot.P2.thinkMs,onChange:i=>{const r=Math.max(0,Math.min(2500,Number(i.target.value)||0));Xi(f=>({P1:{...f.P1,thinkMs:r},P2:{...f.P2,thinkMs:r}}))},style:{width:72,marginLeft:6}}),"ms"]}),o.jsx("button",{onClick:()=>pl(i=>!i),disabled:!A,children:qn?"Resume AI":"Pause AI"})]})]}),U1(),o.jsx("div",{className:"rb-content",children:A?Qs==="Arena"?T1():M1():c==="SETUP"?N1():I1()}),v1(),C1(),w1(),S1(),A1(),R1(),B1(),y1(),L1(),$1(),j1()]})}function kI(){return o.jsx(RI,{})}$N.createRoot(document.getElementById("root")).render(o.jsx(aE.StrictMode,{children:o.jsx(kI,{})}));
RBv24old.tsx:6682:    .rb-panelTitle {
RBv24old.tsx:7037:    .rb-log {
RBv24old.tsx:7569:            <div className="rb-panelTitle">Preview</div>
RBv24old.tsx:7571:            <div className="rb-panelTitle" style={{ marginTop: 12 }}>
RBv24old.tsx:7574:            <div className="rb-log">
RBv24old.tsx:7584:                Clear log
RBv24old.tsx:7656:            <div className="rb-panelTitle">Actions</div>
RBv24old.tsx:7701:              <div className="rb-panelTitle">Legend</div>
RBv24old.tsx:7744:              <div className="rb-panelTitle">Champion</div>
RBv24old.tsx:7761:              <div className="rb-panelTitle">Runes in play</div>
RBv24old.tsx:7819:              <div className="rb-panelTitle">Gear (Seals)</div>
RBv24old.tsx:7836:              <div className="rb-panelTitle">Piles</div>
RBv24old.tsx:7848:              <div className="rb-panelTitle">UI</div>
RBv24old.tsx:7867:          <div className="rb-panelTitle">Setup</div>
RBv24old.tsx:8348:            <div className="rb-panelTitle">Deck Builder</div>
RBv24old.tsx:8659:                <div className="rb-panelTitle">Deck configuration</div>
RBv24old.tsx:8756:                <div className="rb-panelTitle">Card browser</div>
RBv24old.tsx:8822:                <div className="rb-panelTitle">Main deck list</div>
RBv24old.tsx:8859:                      <div className="rb-panelTitle">Preview</div>
RBv24old.tsx:8875:                  <div className="rb-panelTitle">Issues for {pid}</div>
RBv23 (1).tsx:6363:    .rb-panelTitle {
RBv23 (1).tsx:6718:    .rb-log {
RBv23 (1).tsx:7250:          <div className="rb-panelTitle">Preview</div>
RBv23 (1).tsx:7252:          <div className="rb-panelTitle" style={{ marginTop: 12 }}>
RBv23 (1).tsx:7255:          <div className="rb-log">
RBv23 (1).tsx:7265:              Clear log
RBv23 (1).tsx:7337:          <div className="rb-panelTitle">Actions</div>
RBv23 (1).tsx:7382:            <div className="rb-panelTitle">Legend</div>
RBv23 (1).tsx:7425:            <div className="rb-panelTitle">Champion</div>
RBv23 (1).tsx:7442:            <div className="rb-panelTitle">Runes in play</div>
RBv23 (1).tsx:7500:            <div className="rb-panelTitle">Gear (Seals)</div>
RBv23 (1).tsx:7517:            <div className="rb-panelTitle">Piles</div>
RBv23 (1).tsx:7529:            <div className="rb-panelTitle">UI</div>
RBv23 (1).tsx:7548:        <div className="rb-panelTitle">Setup</div>
RBv23 (1).tsx:8027:          <div className="rb-panelTitle">Deck Builder</div>
RBv23 (1).tsx:8338:              <div className="rb-panelTitle">Deck configuration</div>
RBv23 (1).tsx:8435:              <div className="rb-panelTitle">Card browser</div>
RBv23 (1).tsx:8501:              <div className="rb-panelTitle">Main deck list</div>
RBv23 (1).tsx:8538:                  <div className="rb-panelTitle">Preview</div>
RBv23 (1).tsx:8554:              <div className="rb-panelTitle">Issues for {pid}</div>
node_modules/source-map-js/README.md:9:This journey starts from [source-map@0.7.0](https://github.com/mozilla/source-map/blob/master/CHANGELOG.md#070). Some part of it was rewritten to Rust and WASM and API became async.
node_modules/playwright/lib/transform/babelBundleImpl.js:5:`);case 114:return o("\r");case 120:{let u;return{code:u,pos:t}=Bd(e,t,r,n,2,!1,a,i),o(u===null?null:String.fromCharCode(u))}case 117:{let u;return{code:u,pos:t}=jT(e,t,r,n,a,i),o(u===null?null:String.fromCodePoint(u))}case 116:return o("	");case 98:return o("\b");case 118:return o("\v");case 102:return o("\f");case 13:e.charCodeAt(t)===10&&++t;case 10:r=t,++n;case 8232:case 8233:return o("");case 56:case 57:if(s)return o(null);i.strictNumericEscape(t-1,r,n);default:if(l>=48&&l<=55){let u=t-1,p=/^[0-7]+/.exec(e.slice(u,t+2))[0],d=parseInt(p,8);d>255&&(p=p.slice(0,-1),d=parseInt(p,8)),t+=p.length-1;let m=e.charCodeAt(t);if(p!=="0"||m===56||m===57){if(s)return o(null);i.strictNumericEscape(u,r,n)}return o(String.fromCharCode(d))}return o(String.fromCharCode(l))}}function Bd(e,t,r,n,s,i,a,o){let l=t,u;return{n:u,pos:t}=LT(e,t,r,n,16,s,i,!1,o,!a),u===null&&(a?o.invalidEscapeSequence(l,r,n):t=l-1),{code:u,pos:t}}function LT(e,t,r,n,s,i,a,o,l,u){let c=t,p=s===16?FT.hex:FT.decBinOct,d=s===16?uu.hex:s===10?uu.dec:s===8?uu.oct:uu.bin,m=!1,g=0;for(let f=0,b=i==null?1/0:i;f<b;++f){let T=e.charCodeAt(t),w;if(T===95&&o!=="bail"){let I=e.charCodeAt(t-1),N=e.charCodeAt(t+1);if(o){if(Number.isNaN(N)||!d(N)||p.has(I)||p.has(N)){if(u)return{n:null,pos:t};l.unexpectedNumericSeparator(t,r,n)}}else{if(u)return{n:null,pos:t};l.numericSeparatorInEscapeSequence(t,r,n)}++t;continue}if(T>=97?w=T-97+10:T>=65?w=T-65+10:M6(T)?w=T-48:w=1/0,w>=s){if(w<=9&&u)return{n:null,pos:t};if(w<=9&&l.invalidDigit(t,r,n,s))w=0;else if(a)w=0,m=!0;else break}++t,g=g*s+w}return t===c||i!=null&&t-c!==i||m?{n:null,pos:t}:{n:g,pos:t}}function jT(e,t,r,n,s,i){let a=e.charCodeAt(t),o;if(a===123){if(++t,{code:o,pos:t}=Bd(e,t,r,n,e.indexOf("}",t)-t,!0,s,i),++t,o!==null&&o>1114111)if(s)i.invalidCodePoint(t,r,n);else return{code:null,pos:t}}else({code:o,pos:t}=Bd(e,t,r,n,4,!1,s,i));return{code:o,pos:t}}});var la=x(He=>{"use strict";Object.defineProperty(He,"__esModule",{value:!0});He.UPDATE_OPERATORS=He.UNARY_OPERATORS=He.STRING_UNARY_OPERATORS=He.STATEMENT_OR_BLOCK_KEYS=He.NUMBER_UNARY_OPERATORS=He.NUMBER_BINARY_OPERATORS=He.LOGICAL_OPERATORS=He.INHERIT_KEYS=He.FOR_INIT_KEYS=He.FLATTENABLE_KEYS=He.EQUALITY_BINARY_OPERATORS=He.COMPARISON_BINARY_OPERATORS=He.COMMENT_KEYS=He.BOOLEAN_UNARY_OPERATORS=He.BOOLEAN_NUMBER_BINARY_OPERATORS=He.BOOLEAN_BINARY_OPERATORS=He.BINARY_OPERATORS=He.ASSIGNMENT_OPERATORS=void 0;var dve=He.STATEMENT_OR_BLOCK_KEYS=["consequent","body","alternate"],hve=He.FLATTENABLE_KEYS=["body","expressions"],mve=He.FOR_INIT_KEYS=["left","init"],yve=He.COMMENT_KEYS=["leadingComments","trailingComments","innerComments"],V6=He.LOGICAL_OPERATORS=["||","&&","??"],gve=He.UPDATE_OPERATORS=["++","--"],$6=He.BOOLEAN_NUMBER_BINARY_OPERATORS=[">","<",">=","<="],W6=He.EQUALITY_BINARY_OPERATORS=["==","===","!=","!=="],K6=He.COMPARISON_BINARY_OPERATORS=[...W6,"in","instanceof"],H6=He.BOOLEAN_BINARY_OPERATORS=[...K6,...$6],RT=He.NUMBER_BINARY_OPERATORS=["-","/","%","*","**","&","|",">>",">>>","<<","^"],bve=He.BINARY_OPERATORS=["+",...RT,...H6,"|>"],Eve=He.ASSIGNMENT_OPERATORS=["=","+=",...RT.map(e=>e+"="),...V6.map(e=>e+"=")],G6=He.BOOLEAN_UNARY_OPERATORS=["delete","!"],X6=He.NUMBER_UNARY_OPERATORS=["+","-","~"],Y6=He.STRING_UNARY_OPERATORS=["typeof"],Tve=He.UNARY_OPERATORS=["void","throw",...G6,...X6,...Y6],xve=He.INHERIT_KEYS={optional:["typeAnnotation","typeParameters","returnType"],force:["start","loc","end"]};He.BLOCK_SCOPED_SYMBOL=Symbol.for("var used to be block scoped"),He.NOT_LOCAL_BINDING=Symbol.for("should not be considered a local binding")});var Un=x(at=>{"use strict";Object.defineProperty(at,"__esModule",{value:!0});at.allExpandedTypes=at.VISITOR_KEYS=at.NODE_PARENT_VALIDATIONS=at.NODE_FIELDS=at.FLIPPED_ALIAS_KEYS=at.DEPRECATED_KEYS=at.BUILDER_KEYS=at.ALIAS_KEYS=void 0;at.arrayOf=UT;at.arrayOfType=VT;at.assertEach=$T;at.assertNodeOrValueType=lj;at.assertNodeType=pu;at.assertOneOf=aj;at.assertOptionalChainStart=cj;at.assertShape=uj;at.assertValueType=jd;at.chain=WT;at.default=KT;at.defineAliasedType=dj;at.validate=Ld;at.validateArrayOfType=ij;at.validateOptional=nj;at.validateOptionalType=sj;at.validateType=rj;var qT=ia(),xo=fu(),J6=at.VISITOR_KEYS={},z6=at.ALIAS_KEYS={},kd=at.FLIPPED_ALIAS_KEYS={},Q6=at.NODE_FIELDS={},Z6=at.BUILDER_KEYS={},ej=at.DEPRECATED_KEYS={},tj=at.NODE_PARENT_VALIDATIONS={};function cu(e){return Array.isArray(e)?"array":e===null?"null":typeof e}function Ld(e){return{validate:e}}function rj(...e){return Ld(pu(...e))}function nj(e){return{validate:e,optional:!0}}function sj(...e){return{validate:pu(...e),optional:!0}}function UT(e){return WT(jd("array"),$T(e))}function VT(...e){return UT(pu(...e))}function ij(...e){return Ld(VT(...e))}function $T(e){let t=process.env.BABEL_TYPES_8_BREAKING?xo.validateChild:()=>{};function r(n,s,i){if(!Array.isArray(i))return;let a=0,o={toString(){return`${s}[${a}]`}};for(;a<i.length;a++){let l=i[a];e(n,o,l),t(n,o,l)}}return r.each=e,r}function aj(...e){function t(r,n,s){if(!e.includes(s))throw new TypeError(`Property ${n} expected value to be one of ${JSON.stringify(e)} but got ${JSON.stringify(s)}`)}return t.oneOf=e,t}var oj=at.allExpandedTypes=[];function pu(...e){let t=new Set;oj.push({types:e,set:t});function r(n,s,i){let a=i==null?void 0:i.type;if(a!=null){if(t.has(a)){(0,xo.validateChild)(n,s,i);return}if(a==="Placeholder"){for(let o of e)if((0,qT.default)(o,i)){(0,xo.validateChild)(n,s,i);return}}}throw new TypeError(`Property ${s} of ${n.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(a)}`)}return r.oneOfNodeTypes=e,r}function lj(...e){function t(r,n,s){let i=cu(s);for(let a of e)if(i===a||(0,qT.default)(a,s)){(0,xo.validateChild)(r,n,s);return}throw new TypeError(`Property ${n} of ${r.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(s==null?void 0:s.type)}`)}return t.oneOfNodeOrValueTypes=e,t}function jd(e){function t(r,n,s){if(cu(s)!==e)throw new TypeError(`Property ${n} expected type of ${e} but got ${cu(s)}`)}return t.type=e,t}function uj(e){let t=Object.keys(e);function r(n,s,i){let a=[];for(let o of t)try{(0,xo.validateField)(n,o,i[o],e[o])}catch(l){if(l instanceof TypeError){a.push(l.message);continue}throw l}if(a.length)throw new TypeError(`Property ${s} of ${n.type} expected to have the following:
node_modules/playwright/lib/transform/babelBundleImpl.js:7:`)}`)}return r.shapeOf=e,r}function cj(){function e(t){var r;let n=t;for(;t;){let{type:s}=n;if(s==="OptionalCallExpression"){if(n.optional)return;n=n.callee;continue}if(s==="OptionalMemberExpression"){if(n.optional)return;n=n.object;continue}break}throw new TypeError(`Non-optional ${t.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(r=n)==null?void 0:r.type}`)}return e}function WT(...e){function t(...r){for(let n of e)n(...r)}if(t.chainOf=e,e.length>=2&&"type"in e[0]&&e[0].type==="array"&&!("each"in e[1]))throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');return t}var pj=new Set(["aliases","builder","deprecatedAlias","fields","inherits","visitor","validate"]),fj=new Set(["default","optional","deprecated","validate"]),Fd={};function dj(...e){return(t,r={})=>{let n=r.aliases;if(!n){var s;r.inherits&&(n=(s=Fd[r.inherits].aliases)==null?void 0:s.slice()),n!=null||(n=[]),r.aliases=n}let i=e.filter(a=>!n.includes(a));n.unshift(...i),KT(t,r)}}function KT(e,t={}){let r=t.inherits&&Fd[t.inherits]||{},n=t.fields;if(!n&&(n={},r.fields)){let o=Object.getOwnPropertyNames(r.fields);for(let l of o){let u=r.fields[l],c=u.default;if(Array.isArray(c)?c.length>0:c&&typeof c=="object")throw new Error("field defaults can only be primitives or empty arrays currently");n[l]={default:Array.isArray(c)?[]:c,optional:u.optional,deprecated:u.deprecated,validate:u.validate}}}let s=t.visitor||r.visitor||[],i=t.aliases||r.aliases||[],a=t.builder||r.builder||t.visitor||[];for(let o of Object.keys(t))if(!pj.has(o))throw new Error(`Unknown type option "${o}" on ${e}`);t.deprecatedAlias&&(ej[t.deprecatedAlias]=e);for(let o of s.concat(a))n[o]=n[o]||{};for(let o of Object.keys(n)){let l=n[o];l.default!==void 0&&!a.includes(o)&&(l.optional=!0),l.default===void 0?l.default=null:!l.validate&&l.default!=null&&(l.validate=jd(cu(l.default)));for(let u of Object.keys(l))if(!fj.has(u))throw new Error(`Unknown field key "${u}" on ${e}.${o}`)}J6[e]=t.visitor=s,Z6[e]=t.builder=a,Q6[e]=t.fields=n,z6[e]=t.aliases=i,i.forEach(o=>{kd[o]=kd[o]||[],kd[o].push(e)}),t.validate&&(tj[e]=t.validate),Fd[e]=t}});var So=x(Pr=>{"use strict";Object.defineProperty(Pr,"__esModule",{value:!0});Pr.patternLikeCommon=Pr.importAttributes=Pr.functionTypeAnnotationCommon=Pr.functionDeclarationCommon=Pr.functionCommon=Pr.classMethodOrPropertyCommon=Pr.classMethodOrDeclareMethodCommon=void 0;var Or=ia(),hj=oa(),HT=aa(),mj=MT(),ua=la(),D=Un(),oe=(0,D.defineAliasedType)("Standardized");oe("ArrayExpression",{fields:{elements:{validate:(0,D.arrayOf)((0,D.assertNodeOrValueType)("null","Expression","SpreadElement")),default:process.env.BABEL_TYPES_8_BREAKING?void 0:[]}},visitor:["elements"],aliases:["Expression"]});oe("AssignmentExpression",{fields:{operator:{validate:process.env.BABEL_TYPES_8_BREAKING?Object.assign((function(){let e=(0,D.assertOneOf)(...ua.ASSIGNMENT_OPERATORS),t=(0,D.assertOneOf)("=");return function(r,n,s){((0,Or.default)("Pattern",r.left)?t:e)(r,n,s)}})(),{oneOf:ua.ASSIGNMENT_OPERATORS}):(0,D.assertValueType)("string")},left:{validate:process.env.BABEL_TYPES_8_BREAKING?(0,D.assertNodeType)("Identifier","MemberExpression","OptionalMemberExpression","ArrayPattern","ObjectPattern","TSAsExpression","TSSatisfiesExpression","TSTypeAssertion","TSNonNullExpression"):(0,D.assertNodeType)("LVal","OptionalMemberExpression")},right:{validate:(0,D.assertNodeType)("Expression")}},builder:["operator","left","right"],visitor:["left","right"],aliases:["Expression"]});oe("BinaryExpression",{builder:["operator","left","right"],fields:{operator:{validate:(0,D.assertOneOf)(...ua.BINARY_OPERATORS)},left:{validate:(function(){let e=(0,D.assertNodeType)("Expression"),t=(0,D.assertNodeType)("Expression","PrivateName");return Object.assign(function(n,s,i){(n.operator==="in"?t:e)(n,s,i)},{oneOfNodeTypes:["Expression","PrivateName"]})})()},right:{validate:(0,D.assertNodeType)("Expression")}},visitor:["left","right"],aliases:["Binary","Expression"]});oe("InterpreterDirective",{builder:["value"],fields:{value:{validate:(0,D.assertValueType)("string")}}});oe("Directive",{visitor:["value"],fields:{value:{validate:(0,D.assertNodeType)("DirectiveLiteral")}}});oe("DirectiveLiteral",{builder:["value"],fields:{value:{validate:(0,D.assertValueType)("string")}}});oe("BlockStatement",{builder:["body","directives"],visitor:["directives","body"],fields:{directives:{validate:(0,D.arrayOfType)("Directive"),default:[]},body:(0,D.validateArrayOfType)("Statement")},aliases:["Scopable","BlockParent","Block","Statement"]});oe("BreakStatement",{visitor:["label"],fields:{label:{validate:(0,D.assertNodeType)("Identifier"),optional:!0}},aliases:["Statement","Terminatorless","CompletionStatement"]});oe("CallExpression",{visitor:["callee","typeParameters","typeArguments","arguments"],builder:["callee","arguments"],aliases:["Expression"],fields:Object.assign({callee:{validate:(0,D.assertNodeType)("Expression","Super","V8IntrinsicIdentifier")},arguments:(0,D.validateArrayOfType)("Expression","SpreadElement","ArgumentPlaceholder"),typeArguments:{validate:(0,D.assertNodeType)("TypeParameterInstantiation"),optional:!0}},process.env.BABEL_TYPES_8_BREAKING?{}:{optional:{validate:(0,D.assertValueType)("boolean"),optional:!0},typeParameters:{validate:(0,D.assertNodeType)("TSTypeParameterInstantiation"),optional:!0}})});oe("CatchClause",{visitor:["param","body"],fields:{param:{validate:(0,D.assertNodeType)("Identifier","ArrayPattern","ObjectPattern"),optional:!0},body:{validate:(0,D.assertNodeType)("BlockStatement")}},aliases:["Scopable","BlockParent"]});oe("ConditionalExpression",{visitor:["test","consequent","alternate"],fields:{test:{validate:(0,D.assertNodeType)("Expression")},consequent:{validate:(0,D.assertNodeType)("Expression")},alternate:{validate:(0,D.assertNodeType)("Expression")}},aliases:["Expression","Conditional"]});oe("ContinueStatement",{visitor:["label"],fields:{label:{validate:(0,D.assertNodeType)("Identifier"),optional:!0}},aliases:["Statement","Terminatorless","CompletionStatement"]});oe("DebuggerStatement",{aliases:["Statement"]});oe("DoWhileStatement",{builder:["test","body"],visitor:["body","test"],fields:{test:{validate:(0,D.assertNodeType)("Expression")},body:{validate:(0,D.assertNodeType)("Statement")}},aliases:["Statement","BlockParent","Loop","While","Scopable"]});oe("EmptyStatement",{aliases:["Statement"]});oe("ExpressionStatement",{visitor:["expression"],fields:{expression:{validate:(0,D.assertNodeType)("Expression")}},aliases:["Statement","ExpressionWrapper"]});oe("File",{builder:["program","comments","tokens"],visitor:["program"],fields:{program:{validate:(0,D.assertNodeType)("Program")},comments:{validate:process.env.BABEL_TYPES_8_BREAKING?(0,D.assertEach)((0,D.assertNodeType)("CommentBlock","CommentLine")):Object.assign(()=>{},{each:{oneOfNodeTypes:["CommentBlock","CommentLine"]}}),optional:!0},tokens:{validate:(0,D.assertEach)(Object.assign(()=>{},{type:"any"})),optional:!0}}});oe("ForInStatement",{visitor:["left","right","body"],aliases:["Scopable","Statement","For","BlockParent","Loop","ForXStatement"],fields:{left:{validate:process.env.BABEL_TYPES_8_BREAKING?(0,D.assertNodeType)("VariableDeclaration","Identifier","MemberExpression","ArrayPattern","ObjectPattern","TSAsExpression","TSSatisfiesExpression","TSTypeAssertion","TSNonNullExpression"):(0,D.assertNodeType)("VariableDeclaration","LVal")},right:{validate:(0,D.assertNodeType)("Expression")},body:{validate:(0,D.assertNodeType)("Statement")}}});oe("ForStatement",{visitor:["init","test","update","body"],aliases:["Scopable","Statement","For","BlockParent","Loop"],fields:{init:{validate:(0,D.assertNodeType)("VariableDeclaration","Expression"),optional:!0},test:{validate:(0,D.assertNodeType)("Expression"),optional:!0},update:{validate:(0,D.assertNodeType)("Expression"),optional:!0},body:{validate:(0,D.assertNodeType)("Statement")}}});var ca=()=>({params:(0,D.validateArrayOfType)("FunctionParameter"),generator:{default:!1},async:{default:!1}});Pr.functionCommon=ca;var hi=()=>({returnType:{validate:(0,D.assertNodeType)("TypeAnnotation","TSTypeAnnotation","Noop"),optional:!0},typeParameters:{validate:(0,D.assertNodeType)("TypeParameterDeclaration","TSTypeParameterDeclaration","Noop"),optional:!0}});Pr.functionTypeAnnotationCommon=hi;var GT=()=>Object.assign({},ca(),{declare:{validate:(0,D.assertValueType)("boolean"),optional:!0},id:{validate:(0,D.assertNodeType)("Identifier"),optional:!0}});Pr.functionDeclarationCommon=GT;oe("FunctionDeclaration",{builder:["id","params","body","generator","async"],visitor:["id","typeParameters","params","predicate","returnType","body"],fields:Object.assign({},GT(),hi(),{body:{validate:(0,D.assertNodeType)("BlockStatement")},predicate:{validate:(0,D.assertNodeType)("DeclaredPredicate","InferredPredicate"),optional:!0}}),aliases:["Scopable","Function","BlockParent","FunctionParent","Statement","Pureish","Declaration"],validate:process.env.BABEL_TYPES_8_BREAKING?(function(){let e=(0,D.assertNodeType)("Identifier");return function(t,r,n){(0,Or.default)("ExportDefaultDeclaration",t)||e(n,"id",n.id)}})():void 0});oe("FunctionExpression",{inherits:"FunctionDeclaration",aliases:["Scopable","Function","BlockParent","FunctionParent","Expression","Pureish"],fields:Object.assign({},ca(),hi(),{id:{validate:(0,D.assertNodeType)("Identifier"),optional:!0},body:{validate:(0,D.assertNodeType)("BlockStatement")},predicate:{validate:(0,D.assertNodeType)("DeclaredPredicate","InferredPredicate"),optional:!0}})});var pa=()=>({typeAnnotation:{validate:(0,D.assertNodeType)("TypeAnnotation","TSTypeAnnotation","Noop"),optional:!0},optional:{validate:(0,D.assertValueType)("boolean"),optional:!0},decorators:{validate:(0,D.arrayOfType)("Decorator"),optional:!0}});Pr.patternLikeCommon=pa;oe("Identifier",{builder:["name"],visitor:["typeAnnotation","decorators"],aliases:["Expression","FunctionParameter","PatternLike","LVal","TSEntityName"],fields:Object.assign({},pa(),{name:{validate:process.env.BABEL_TYPES_8_BREAKING?(0,D.chain)((0,D.assertValueType)("string"),Object.assign(function(e,t,r){if(!(0,hj.default)(r,!1))throw new TypeError(`"${r}" is not a valid identifier name`)},{type:"string"})):(0,D.assertValueType)("string")}}),validate:process.env.BABEL_TYPES_8_BREAKING?function(e,t,r){let n=/\.(\w+)$/.exec(t.toString());if(!n)return;let[,s]=n,i={computed:!1};if(s==="property"){if((0,Or.default)("MemberExpression",e,i)||(0,Or.default)("OptionalMemberExpression",e,i))return}else if(s==="key"){if((0,Or.default)("Property",e,i)||(0,Or.default)("Method",e,i))return}else if(s==="exported"){if((0,Or.default)("ExportSpecifier",e))return}else if(s==="imported"){if((0,Or.default)("ImportSpecifier",e,{imported:r}))return}else if(s==="meta"&&(0,Or.default)("MetaProperty",e,{meta:r}))return;if(((0,HT.isKeyword)(r.name)||(0,HT.isReservedWord)(r.name,!1))&&r.name!=="this")throw new TypeError(`"${r.name}" is not a valid identifier`)}:void 0});oe("IfStatement",{visitor:["test","consequent","alternate"],aliases:["Statement","Conditional"],fields:{test:{validate:(0,D.assertNodeType)("Expression")},consequent:{validate:(0,D.assertNodeType)("Statement")},alternate:{optional:!0,validate:(0,D.assertNodeType)("Statement")}}});oe("LabeledStatement",{visitor:["label","body"],aliases:["Statement"],fields:{label:{validate:(0,D.assertNodeType)("Identifier")},body:{validate:(0,D.assertNodeType)("Statement")}}});oe("StringLiteral",{builder:["value"],fields:{value:{validate:(0,D.assertValueType)("string")}},aliases:["Expression","Pureish","Literal","Immutable"]});oe("NumericLiteral",{builder:["value"],deprecatedAlias:"NumberLiteral",fields:{value:{validate:(0,D.chain)((0,D.assertValueType)("number"),Object.assign(function(e,t,r){if(1/r<0||!Number.isFinite(r)){let n=new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${r}) instead.`)}},{type:"number"}))}},aliases:["Expression","Pureish","Literal","Immutable"]});oe("NullLiteral",{aliases:["Expression","Pureish","Literal","Immutable"]});oe("BooleanLiteral",{builder:["value"],fields:{value:{validate:(0,D.assertValueType)("boolean")}},aliases:["Expression","Pureish","Literal","Immutable"]});oe("RegExpLiteral",{builder:["pattern","flags"],deprecatedAlias:"RegexLiteral",aliases:["Expression","Pureish","Literal"],fields:{pattern:{validate:(0,D.assertValueType)("string")},flags:{validate:process.env.BABEL_TYPES_8_BREAKING?(0,D.chain)((0,D.assertValueType)("string"),Object.assign(function(e,t,r){let n=/[^gimsuy]/.exec(r);if(n)throw new TypeError(`"${n[0]}" is not a valid RegExp flag`)},{type:"string"})):(0,D.assertValueType)("string"),default:""}}});oe("LogicalExpression",{builder:["operator","left","right"],visitor:["left","right"],aliases:["Binary","Expression"],fields:{operator:{validate:(0,D.assertOneOf)(...ua.LOGICAL_OPERATORS)},left:{validate:(0,D.assertNodeType)("Expression")},right:{validate:(0,D.assertNodeType)("Expression")}}});oe("MemberExpression",{builder:["object","property","computed",...process.env.BABEL_TYPES_8_BREAKING?[]:["optional"]],visitor:["object","property"],aliases:["Expression","LVal","PatternLike"],fields:Object.assign({object:{validate:(0,D.assertNodeType)("Expression","Super")},property:{validate:(function(){let e=(0,D.assertNodeType)("Identifier","PrivateName"),t=(0,D.assertNodeType)("Expression"),r=function(n,s,i){(n.computed?t:e)(n,s,i)};return r.oneOfNodeTypes=["Expression","Identifier","PrivateName"],r})()},computed:{default:!1}},process.env.BABEL_TYPES_8_BREAKING?{}:{optional:{validate:(0,D.assertValueType)("boolean"),optional:!0}})});oe("NewExpression",{inherits:"CallExpression"});oe("Program",{visitor:["directives","body"],builder:["body","directives","sourceType","interpreter"],fields:{sourceType:{validate:(0,D.assertOneOf)("script","module"),default:"script"},interpreter:{validate:(0,D.assertNodeType)("InterpreterDirective"),default:null,optional:!0},directives:{validate:(0,D.arrayOfType)("Directive"),default:[]},body:(0,D.validateArrayOfType)("Statement")},aliases:["Scopable","BlockParent","Block"]});oe("ObjectExpression",{visitor:["properties"],aliases:["Expression"],fields:{properties:(0,D.validateArrayOfType)("ObjectMethod","ObjectProperty","SpreadElement")}});oe("ObjectMethod",{builder:["kind","key","params","body","computed","generator","async"],visitor:["decorators","key","typeParameters","params","returnType","body"],fields:Object.assign({},ca(),hi(),{kind:Object.assign({validate:(0,D.assertOneOf)("method","get","set")},process.env.BABEL_TYPES_8_BREAKING?{}:{default:"method"}),computed:{default:!1},key:{validate:(function(){let e=(0,D.assertNodeType)("Identifier","StringLiteral","NumericLiteral","BigIntLiteral"),t=(0,D.assertNodeType)("Expression"),r=function(n,s,i){(n.computed?t:e)(n,s,i)};return r.oneOfNodeTypes=["Expression","Identifier","StringLiteral","NumericLiteral","BigIntLiteral"],r})()},decorators:{validate:(0,D.arrayOfType)("Decorator"),optional:!0},body:{validate:(0,D.assertNodeType)("BlockStatement")}}),aliases:["UserWhitespacable","Function","Scopable","BlockParent","FunctionParent","Method","ObjectMember"]});oe("ObjectProperty",{builder:["key","value","computed","shorthand",...process.env.BABEL_TYPES_8_BREAKING?[]:["decorators"]],fields:{computed:{default:!1},key:{validate:(function(){let e=(0,D.assertNodeType)("Identifier","StringLiteral","NumericLiteral","BigIntLiteral","DecimalLiteral","PrivateName"),t=(0,D.assertNodeType)("Expression");return Object.assign(function(n,s,i){(n.computed?t:e)(n,s,i)},{oneOfNodeTypes:["Expression","Identifier","StringLiteral","NumericLiteral","BigIntLiteral","DecimalLiteral","PrivateName"]})})()},value:{validate:(0,D.assertNodeType)("Expression","PatternLike")},shorthand:{validate:process.env.BABEL_TYPES_8_BREAKING?(0,D.chain)((0,D.assertValueType)("boolean"),Object.assign(function(e,t,r){if(r){if(e.computed)throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");if(!(0,Or.default)("Identifier",e.key))throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier")}},{type:"boolean"})):(0,D.assertValueType)("boolean"),default:!1},decorators:{validate:(0,D.arrayOfType)("Decorator"),optional:!0}},visitor:["decorators","key","value"],aliases:["UserWhitespacable","Property","ObjectMember"],validate:process.env.BABEL_TYPES_8_BREAKING?(function(){let e=(0,D.assertNodeType)("Identifier","Pattern","TSAsExpression","TSSatisfiesExpression","TSNonNullExpression","TSTypeAssertion"),t=(0,D.assertNodeType)("Expression");return function(r,n,s){((0,Or.default)("ObjectPattern",r)?e:t)(s,"value",s.value)}})():void 0});oe("RestElement",{visitor:["argument","typeAnnotation"],builder:["argument"],aliases:["FunctionParameter","PatternLike","LVal"],deprecatedAlias:"RestProperty",fields:Object.assign({},pa(),{argument:{validate:process.env.BABEL_TYPES_8_BREAKING?(0,D.assertNodeType)("Identifier","ArrayPattern","ObjectPattern","MemberExpression","TSAsExpression","TSSatisfiesExpression","TSTypeAssertion","TSNonNullExpression"):(0,D.assertNodeType)("Identifier","ArrayPattern","ObjectPattern","MemberExpression","TSAsExpression","TSSatisfiesExpression","TSTypeAssertion","TSNonNullExpression","RestElement","AssignmentPattern")}}),validate:process.env.BABEL_TYPES_8_BREAKING?function(e,t){let r=/(\w+)\[(\d+)\]/.exec(t.toString());if(!r)throw new Error("Internal Babel error: malformed key.");let[,n,s]=r;if(e[n].length>+s+1)throw new TypeError(`RestElement must be last element of ${n}`)}:void 0});oe("ReturnStatement",{visitor:["argument"],aliases:["Statement","Terminatorless","CompletionStatement"],fields:{argument:{validate:(0,D.assertNodeType)("Expression"),optional:!0}}});oe("SequenceExpression",{visitor:["expressions"],fields:{expressions:(0,D.validateArrayOfType)("Expression")},aliases:["Expression"]});oe("ParenthesizedExpression",{visitor:["expression"],aliases:["Expression","ExpressionWrapper"],fields:{expression:{validate:(0,D.assertNodeType)("Expression")}}});oe("SwitchCase",{visitor:["test","consequent"],fields:{test:{validate:(0,D.assertNodeType)("Expression"),optional:!0},consequent:(0,D.validateArrayOfType)("Statement")}});oe("SwitchStatement",{visitor:["discriminant","cases"],aliases:["Statement","BlockParent","Scopable"],fields:{discriminant:{validate:(0,D.assertNodeType)("Expression")},cases:(0,D.validateArrayOfType)("SwitchCase")}});oe("ThisExpression",{aliases:["Expression"]});oe("ThrowStatement",{visitor:["argument"],aliases:["Statement","Terminatorless","CompletionStatement"],fields:{argument:{validate:(0,D.assertNodeType)("Expression")}}});oe("TryStatement",{visitor:["block","handler","finalizer"],aliases:["Statement"],fields:{block:{validate:process.env.BABEL_TYPES_8_BREAKING?(0,D.chain)((0,D.assertNodeType)("BlockStatement"),Object.assign(function(e){if(!e.handler&&!e.finalizer)throw new TypeError("TryStatement expects either a handler or finalizer, or both")},{oneOfNodeTypes:["BlockStatement"]})):(0,D.assertNodeType)("BlockStatement")},handler:{optional:!0,validate:(0,D.assertNodeType)("CatchClause")},finalizer:{optional:!0,validate:(0,D.assertNodeType)("BlockStatement")}}});oe("UnaryExpression",{builder:["operator","argument","prefix"],fields:{prefix:{default:!0},argument:{validate:(0,D.assertNodeType)("Expression")},operator:{validate:(0,D.assertOneOf)(...ua.UNARY_OPERATORS)}},visitor:["argument"],aliases:["UnaryLike","Expression"]});oe("UpdateExpression",{builder:["operator","argument","prefix"],fields:{prefix:{default:!1},argument:{validate:process.env.BABEL_TYPES_8_BREAKING?(0,D.assertNodeType)("Identifier","MemberExpression"):(0,D.assertNodeType)("Expression")},operator:{validate:(0,D.assertOneOf)(...ua.UPDATE_OPERATORS)}},visitor:["argument"],aliases:["Expression"]});oe("VariableDeclaration",{builder:["kind","declarations"],visitor:["declarations"],aliases:["Statement","Declaration"],fields:{declare:{validate:(0,D.assertValueType)("boolean"),optional:!0},kind:{validate:(0,D.assertOneOf)("var","let","const","using","await using")},declarations:(0,D.validateArrayOfType)("VariableDeclarator")},validate:process.env.BABEL_TYPES_8_BREAKING?(()=>{let e=(0,D.assertNodeType)("Identifier","Placeholder"),t=(0,D.assertNodeType)("Identifier","ArrayPattern","ObjectPattern","Placeholder"),r=(0,D.assertNodeType)("Identifier","VoidPattern","Placeholder");return function(n,s,i){let{kind:a,declarations:o}=i,l=(0,Or.default)("ForXStatement",n,{left:i});if(l&&o.length!==1)throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${n.type}`);for(let u of o)a==="const"||a==="let"||a==="var"?!l&&!u.init?e(u,"id",u.id):t(u,"id",u.id):r(u,"id",u.id)}})():void 0});oe("VariableDeclarator",{visitor:["id","init"],fields:{id:{validate:process.env.BABEL_TYPES_8_BREAKING?(0,D.assertNodeType)("Identifier","ArrayPattern","ObjectPattern","VoidPattern"):(0,D.assertNodeType)("LVal","VoidPattern")},definite:{optional:!0,validate:(0,D.assertValueType)("boolean")},init:{optional:!0,validate:(0,D.assertNodeType)("Expression")}}});oe("WhileStatement",{visitor:["test","body"],aliases:["Statement","BlockParent","Loop","While","Scopable"],fields:{test:{validate:(0,D.assertNodeType)("Expression")},body:{validate:(0,D.assertNodeType)("Statement")}}});oe("WithStatement",{visitor:["object","body"],aliases:["Statement"],fields:{object:{validate:(0,D.assertNodeType)("Expression")},body:{validate:(0,D.assertNodeType)("Statement")}}});oe("AssignmentPattern",{visitor:["left","right","decorators"],builder:["left","right"],aliases:["FunctionParameter","Pattern","PatternLike","LVal"],fields:Object.assign({},pa(),{left:{validate:(0,D.assertNodeType)("Identifier","ObjectPattern","ArrayPattern","MemberExpression","TSAsExpression","TSSatisfiesExpression","TSTypeAssertion","TSNonNullExpression")},right:{validate:(0,D.assertNodeType)("Expression")},decorators:{validate:(0,D.arrayOfType)("Decorator"),optional:!0}})});oe("ArrayPattern",{visitor:["elements","typeAnnotation"],builder:["elements"],aliases:["FunctionParameter","Pattern","PatternLike","LVal"],fields:Object.assign({},pa(),{elements:{validate:(0,D.chain)((0,D.assertValueType)("array"),(0,D.assertEach)((0,D.assertNodeOrValueType)("null","PatternLike")))}})});oe("ArrowFunctionExpression",{builder:["params","body","async"],visitor:["typeParameters","params","predicate","returnType","body"],aliases:["Scopable","Function","BlockParent","FunctionParent","Expression","Pureish"],fields:Object.assign({},ca(),hi(),{expression:{validate:(0,D.assertValueType)("boolean")},body:{validate:(0,D.assertNodeType)("BlockStatement","Expression")},predicate:{validate:(0,D.assertNodeType)("DeclaredPredicate","InferredPredicate"),optional:!0}})});oe("ClassBody",{visitor:["body"],fields:{body:(0,D.validateArrayOfType)("ClassMethod","ClassPrivateMethod","ClassProperty","ClassPrivateProperty","ClassAccessorProperty","TSDeclareMethod","TSIndexSignature","StaticBlock")}});oe("ClassExpression",{builder:["id","superClass","body","decorators"],visitor:["decorators","id","typeParameters","superClass","superTypeParameters","mixins","implements","body"],aliases:["Scopable","Class","Expression"],fields:{id:{validate:(0,D.assertNodeType)("Identifier"),optional:!0},typeParameters:{validate:(0,D.assertNodeType)("TypeParameterDeclaration","TSTypeParameterDeclaration","Noop"),optional:!0},body:{validate:(0,D.assertNodeType)("ClassBody")},superClass:{optional:!0,validate:(0,D.assertNodeType)("Expression")},superTypeParameters:{validate:(0,D.assertNodeType)("TypeParameterInstantiation","TSTypeParameterInstantiation"),optional:!0},implements:{validate:(0,D.arrayOfType)("TSExpressionWithTypeArguments","ClassImplements"),optional:!0},decorators:{validate:(0,D.arrayOfType)("Decorator"),optional:!0},mixins:{validate:(0,D.assertNodeType)("InterfaceExtends"),optional:!0}}});oe("ClassDeclaration",{inherits:"ClassExpression",aliases:["Scopable","Class","Statement","Declaration"],fields:{id:{validate:(0,D.assertNodeType)("Identifier"),optional:!0},typeParameters:{validate:(0,D.assertNodeType)("TypeParameterDeclaration","TSTypeParameterDeclaration","Noop"),optional:!0},body:{validate:(0,D.assertNodeType)("ClassBody")},superClass:{optional:!0,validate:(0,D.assertNodeType)("Expression")},superTypeParameters:{validate:(0,D.assertNodeType)("TypeParameterInstantiation","TSTypeParameterInstantiation"),optional:!0},implements:{validate:(0,D.arrayOfType)("TSExpressionWithTypeArguments","ClassImplements"),optional:!0},decorators:{validate:(0,D.arrayOfType)("Decorator"),optional:!0},mixins:{validate:(0,D.assertNodeType)("InterfaceExtends"),optional:!0},declare:{validate:(0,D.assertValueType)("boolean"),optional:!0},abstract:{validate:(0,D.assertValueType)("boolean"),optional:!0}},validate:process.env.BABEL_TYPES_8_BREAKING?(function(){let e=(0,D.assertNodeType)("Identifier");return function(t,r,n){(0,Or.default)("ExportDefaultDeclaration",t)||e(n,"id",n.id)}})():void 0});var Md=Pr.importAttributes={attributes:{optional:!0,validate:(0,D.arrayOfType)("ImportAttribute")},assertions:{deprecated:!0,optional:!0,validate:(0,D.arrayOfType)("ImportAttribute")}};oe("ExportAllDeclaration",{builder:["source"],visitor:["source","attributes","assertions"],aliases:["Statement","Declaration","ImportOrExportDeclaration","ExportDeclaration"],fields:Object.assign({source:{validate:(0,D.assertNodeType)("StringLiteral")},exportKind:(0,D.validateOptional)((0,D.assertOneOf)("type","value"))},Md)});oe("ExportDefaultDeclaration",{visitor:["declaration"],aliases:["Statement","Declaration","ImportOrExportDeclaration","ExportDeclaration"],fields:{declaration:(0,D.validateType)("TSDeclareFunction","FunctionDeclaration","ClassDeclaration","Expression"),exportKind:(0,D.validateOptional)((0,D.assertOneOf)("value"))}});oe("ExportNamedDeclaration",{builder:["declaration","specifiers","source"],visitor:["declaration","specifiers","source","attributes","assertions"],aliases:["Statement","Declaration","ImportOrExportDeclaration","ExportDeclaration"],fields:Object.assign({declaration:{optional:!0,validate:process.env.BABEL_TYPES_8_BREAKING?(0,D.chain)((0,D.assertNodeType)("Declaration"),Object.assign(function(e,t,r){if(r&&e.specifiers.length)throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");if(r&&e.source)throw new TypeError("Cannot export a declaration from a source")},{oneOfNodeTypes:["Declaration"]})):(0,D.assertNodeType)("Declaration")}},Md,{specifiers:{default:[],validate:(0,D.arrayOf)((function(){let e=(0,D.assertNodeType)("ExportSpecifier","ExportDefaultSpecifier","ExportNamespaceSpecifier"),t=(0,D.assertNodeType)("ExportSpecifier");return process.env.BABEL_TYPES_8_BREAKING?Object.assign(function(r,n,s){(r.source?e:t)(r,n,s)},{oneOfNodeTypes:["ExportSpecifier","ExportDefaultSpecifier","ExportNamespaceSpecifier"]}):e})())},source:{validate:(0,D.assertNodeType)("StringLiteral"),optional:!0},exportKind:(0,D.validateOptional)((0,D.assertOneOf)("type","value"))})});oe("ExportSpecifier",{visitor:["local","exported"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0,D.assertNodeType)("Identifier")},exported:{validate:(0,D.assertNodeType)("Identifier","StringLiteral")},exportKind:{validate:(0,D.assertOneOf)("type","value"),optional:!0}}});oe("ForOfStatement",{visitor:["left","right","body"],builder:["left","right","body","await"],aliases:["Scopable","Statement","For","BlockParent","Loop","ForXStatement"],fields:{left:{validate:(function(){if(!process.env.BABEL_TYPES_8_BREAKING)return(0,D.assertNodeType)("VariableDeclaration","LVal");let e=(0,D.assertNodeType)("VariableDeclaration"),t=(0,D.assertNodeType)("Identifier","MemberExpression","ArrayPattern","ObjectPattern","TSAsExpression","TSSatisfiesExpression","TSTypeAssertion","TSNonNullExpression");return Object.assign(function(r,n,s){(0,Or.default)("VariableDeclaration",s)?e(r,n,s):t(r,n,s)},{oneOfNodeTypes:["VariableDeclaration","Identifier","MemberExpression","ArrayPattern","ObjectPattern","TSAsExpression","TSSatisfiesExpression","TSTypeAssertion","TSNonNullExpression"]})})()},right:{validate:(0,D.assertNodeType)("Expression")},body:{validate:(0,D.assertNodeType)("Statement")},await:{default:!1}}});oe("ImportDeclaration",{builder:["specifiers","source"],visitor:["specifiers","source","attributes","assertions"],aliases:["Statement","Declaration","ImportOrExportDeclaration"],fields:Object.assign({},Md,{module:{optional:!0,validate:(0,D.assertValueType)("boolean")},phase:{default:null,validate:(0,D.assertOneOf)("source","defer")},specifiers:(0,D.validateArrayOfType)("ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier"),source:{validate:(0,D.assertNodeType)("StringLiteral")},importKind:{validate:(0,D.assertOneOf)("type","typeof","value"),optional:!0}})});oe("ImportDefaultSpecifier",{visitor:["local"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0,D.assertNodeType)("Identifier")}}});oe("ImportNamespaceSpecifier",{visitor:["local"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0,D.assertNodeType)("Identifier")}}});oe("ImportSpecifier",{visitor:["imported","local"],builder:["local","imported"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0,D.assertNodeType)("Identifier")},imported:{validate:(0,D.assertNodeType)("Identifier","StringLiteral")},importKind:{validate:(0,D.assertOneOf)("type","typeof","value"),optional:!0}}});oe("ImportExpression",{visitor:["source","options"],aliases:["Expression"],fields:{phase:{default:null,validate:(0,D.assertOneOf)("source","defer")},source:{validate:(0,D.assertNodeType)("Expression")},options:{validate:(0,D.assertNodeType)("Expression"),optional:!0}}});oe("MetaProperty",{visitor:["meta","property"],aliases:["Expression"],fields:{meta:{validate:process.env.BABEL_TYPES_8_BREAKING?(0,D.chain)((0,D.assertNodeType)("Identifier"),Object.assign(function(e,t,r){let n;switch(r.name){case"function":n="sent";break;case"new":n="target";break;case"import":n="meta";break}if(!(0,Or.default)("Identifier",e.property,{name:n}))throw new TypeError("Unrecognised MetaProperty")},{oneOfNodeTypes:["Identifier"]})):(0,D.assertNodeType)("Identifier")},property:{validate:(0,D.assertNodeType)("Identifier")}}});var du=()=>({abstract:{validate:(0,D.assertValueType)("boolean"),optional:!0},accessibility:{validate:(0,D.assertOneOf)("public","private","protected"),optional:!0},static:{default:!1},override:{default:!1},computed:{default:!1},optional:{validate:(0,D.assertValueType)("boolean"),optional:!0},key:{validate:(0,D.chain)((function(){let e=(0,D.assertNodeType)("Identifier","StringLiteral","NumericLiteral","BigIntLiteral"),t=(0,D.assertNodeType)("Expression");return function(r,n,s){(r.computed?t:e)(r,n,s)}})(),(0,D.assertNodeType)("Identifier","StringLiteral","NumericLiteral","BigIntLiteral","Expression"))}});Pr.classMethodOrPropertyCommon=du;var Rd=()=>Object.assign({},ca(),du(),{params:(0,D.validateArrayOfType)("FunctionParameter","TSParameterProperty"),kind:{validate:(0,D.assertOneOf)("get","set","method","constructor"),default:"method"},access:{validate:(0,D.chain)((0,D.assertValueType)("string"),(0,D.assertOneOf)("public","private","protected")),optional:!0},decorators:{validate:(0,D.arrayOfType)("Decorator"),optional:!0}});Pr.classMethodOrDeclareMethodCommon=Rd;oe("ClassMethod",{aliases:["Function","Scopable","BlockParent","FunctionParent","Method"],builder:["kind","key","params","body","computed","static","generator","async"],visitor:["decorators","key","typeParameters","params","returnType","body"],fields:Object.assign({},Rd(),hi(),{body:{validate:(0,D.assertNodeType)("BlockStatement")}})});oe("ObjectPattern",{visitor:["decorators","properties","typeAnnotation"],builder:["properties"],aliases:["FunctionParameter","Pattern","PatternLike","LVal"],fields:Object.assign({},pa(),{properties:(0,D.validateArrayOfType)("RestElement","ObjectProperty")})});oe("SpreadElement",{visitor:["argument"],aliases:["UnaryLike"],deprecatedAlias:"SpreadProperty",fields:{argument:{validate:(0,D.assertNodeType)("Expression")}}});oe("Super",{aliases:["Expression"]});oe("TaggedTemplateExpression",{visitor:["tag","typeParameters","quasi"],builder:["tag","quasi"],aliases:["Expression"],fields:{tag:{validate:(0,D.assertNodeType)("Expression")},quasi:{validate:(0,D.assertNodeType)("TemplateLiteral")},typeParameters:{validate:(0,D.assertNodeType)("TypeParameterInstantiation","TSTypeParameterInstantiation"),optional:!0}}});oe("TemplateElement",{builder:["value","tail"],fields:{value:{validate:(0,D.chain)((0,D.assertShape)({raw:{validate:(0,D.assertValueType)("string")},cooked:{validate:(0,D.assertValueType)("string"),optional:!0}}),function(t){let r=t.value.raw,n=!1,s=()=>{throw new Error("Internal @babel/types error.")},{str:i,firstInvalidLoc:a}=(0,mj.readStringContents)("template",r,0,0,0,{unterminated(){n=!0},strictNumericEscape:s,invalidEscapeSequence:s,numericSeparatorInEscapeSequence:s,unexpectedNumericSeparator:s,invalidDigit:s,invalidCodePoint:s});if(!n)throw new Error("Invalid raw");t.value.cooked=a?null:i})},tail:{default:!1}}});oe("TemplateLiteral",{visitor:["quasis","expressions"],aliases:["Expression","Literal"],fields:{quasis:(0,D.validateArrayOfType)("TemplateElement"),expressions:{validate:(0,D.chain)((0,D.assertValueType)("array"),(0,D.assertEach)((0,D.assertNodeType)("Expression","TSType")),function(e,t,r){if(e.quasis.length!==r.length+1)throw new TypeError(`Number of ${e.type} quasis should be exactly one more than the number of expressions.
node_modules/playwright/lib/transform/babelBundleImpl.js:44:`+(0,sle.codeFrameColumns)(e,{start:{line:s.line,column:s.column+1}}),n.code="BABEL_REPLACE_SOURCE_ERROR"),n}let r=t.program.body[0].expression;return _0.default.removeProperties(r),this.replaceWith(r)}function _le(e){if(Ia.resync.call(this),this.removed)throw new Error("You can't replace this node, we've already removed it");let t=e instanceof ile.default?e.node:e;if(!t)throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");if(this.node===t)return[this];if(this.isProgram()&&!Sle(t))throw new Error("You can only replace a Program root node with another Program node");if(Array.isArray(t))throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");if(typeof t=="string")throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");let r="";if(this.isNodeType("Statement")&&cC(t)&&!this.canHaveVariableDeclarationOrExpression()&&!this.canSwapBetweenExpressionAndStatement(t)&&!this.parentPath.isExportDefaultDeclaration()&&(t=dle(t),r="expression"),this.isNodeType("Expression")&&vle(t)&&!this.canHaveVariableDeclarationOrExpression()&&!this.canSwapBetweenExpressionAndStatement(t))return this.replaceExpressionWithStatements([t]);let n=this.node;return n&&(ble(t,n),Ale(n)),pC.call(this,t),this.type=t.type,Ia.setScope.call(this),this.requeue(),[r?this.get(r):this]}function pC(e){var t;if(!this.container)throw new ReferenceError("Container is falsy");this.inList?oC(this.parent,this.key,[e]):oC(this.parent,this.key,e),this.debug(`Replace with ${e==null?void 0:e.type}`),(t=(0,lC.getCachedPaths)(this))==null||t.set(e,this).delete(this.node),this.node=this.container[this.key]=e}function Nle(e){Ia.resync.call(this);let t=[],r=_c(e,t);if(r){for(let d of t)this.scope.push({id:d});return this.replaceWith(r)[0].get("expressions")}let n=this.getFunctionParent(),s=n==null?void 0:n.node.async,i=n==null?void 0:n.node.generator,a=lle([],cle(e));this.replaceWith(ple(a,[]));let o=this.get("callee");o.get("body").scope.hoistVariables(d=>this.scope.push({id:d}));let l=o.getCompletionRecords();for(let d of l){if(!d.isExpressionStatement())continue;let m=d.findParent(g=>g.isLoop());if(m){let g=m.getData("expressionReplacementReturnUid");g?g=mle(g.name):(g=o.scope.generateDeclaredUidIdentifier("ret"),o.get("body").pushContainer("body",aC(O0(g))),m.setData("expressionReplacementReturnUid",g)),d.get("expression").replaceWith(uC("=",O0(g),d.node.expression))}else d.replaceWith(aC(d.node.expression))}o.arrowFunctionToExpression();let u=o,c=s&&_0.default.hasType(this.get("callee.body").node,"AwaitExpression",sC),p=i&&_0.default.hasType(this.get("callee.body").node,"YieldExpression",sC);return c&&(u.set("async",!0),p||this.replaceWith(ule(this.node))),p&&(u.set("generator",!0),this.replaceWith(Dle(this.node,!0))),u.get("body.body")}function _c(e,t){let r=[],n=!0;for(let s of e)if(iC(s)||(n=!1),cC(s))r.push(s);else if(Tle(s))r.push(s.expression);else if(Ple(s)){if(s.kind!=="var")return;for(let i of s.declarations){let a=hle(i);for(let o of Object.keys(a))t.push(O0(a[o]));i.init&&r.push(uC("=",i.id,i.init))}n=!0}else if(xle(s)){let i=s.consequent?_c([s.consequent],t):I0(),a=s.alternate?_c([s.alternate],t):I0();if(!i||!a)return;r.push(fle(s.test,i,a))}else if(Ele(s)){let i=_c(s.body,t);if(!i)return;r.push(i)}else if(iC(s))e.indexOf(s)===0&&(n=!0);else return;return n&&r.push(I0()),r.length===1?r[0]:Cle(r)}function Ole(e){if(Ia.resync.call(this),Array.isArray(e))if(Array.isArray(this.container)){e=N0._verifyNodeList.call(this,e);let t=N0._containerInsertAfter.call(this,e);return this.remove(),t}else return this.replaceWithMultiple(e);else return this.replaceWith(e)}});var mC=x(Nc=>{"use strict";Object.defineProperty(Nc,"__esModule",{value:!0});Nc.evaluate=qle;Nc.evaluateTruthy=Mle;var Ble=["Number","String","Math"],kle=["isFinite","isNaN","parseFloat","parseInt","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent",null,null],Fle=["random"];function fC(e){return Ble.includes(e)}function Lle(e){return kle.includes(e)}function jle(e){return Fle.includes(e)}function Mle(){let e=this.evaluate();if(e.confident)return!!e.value}function Dn(e,t){t.confident&&(t.deoptPath=e,t.confident=!1)}var dC=new Map([["undefined",void 0],["Infinity",1/0],["NaN",NaN]]);function Mr(e,t){let{node:r}=e,{seen:n}=t;if(n.has(r)){let s=n.get(r);if(s.resolved)return s.value;Dn(e,t);return}else{let s={resolved:!1};n.set(r,s);let i=Rle(e,t);return t.confident&&(s.resolved=!0,s.value=i),i}}function Rle(e,t){if(t.confident){if(e.isSequenceExpression()){let n=e.get("expressions");return Mr(n[n.length-1],t)}if(e.isStringLiteral()||e.isNumericLiteral()||e.isBooleanLiteral())return e.node.value;if(e.isNullLiteral())return null;if(e.isTemplateLiteral())return hC(e,e.node.quasis,t);if(e.isTaggedTemplateExpression()&&e.get("tag").isMemberExpression()){let n=e.get("tag.object"),{node:{name:s}}=n,i=e.get("tag.property");if(n.isIdentifier()&&s==="String"&&!e.scope.getBinding(s)&&i.isIdentifier()&&i.node.name==="raw")return hC(e,e.node.quasi.quasis,t,!0)}if(e.isConditionalExpression()){let n=Mr(e.get("test"),t);return t.confident?Mr(n?e.get("consequent"):e.get("alternate"),t):void 0}if(e.isExpressionWrapper())return Mr(e.get("expression"),t);if(e.isMemberExpression()&&!e.parentPath.isCallExpression({callee:e.node})){let n=e.get("property"),s=e.get("object");if(s.isLiteral()){let i=s.node.value,a=typeof i,o=null;if(e.node.computed){if(o=Mr(n,t),!t.confident)return}else n.isIdentifier()&&(o=n.node.name);if((a==="number"||a==="string")&&o!=null&&(typeof o=="number"||typeof o=="string"))return i[o]}}if(e.isReferencedIdentifier()){let n=e.scope.getBinding(e.node.name);if(n){if(n.constantViolations.length>0||e.node.start<n.path.node.end){Dn(n.path,t);return}let o=n.path.scope;if(n.kind==="var"&&o!==n.scope){let l=!o.path.parentPath.isBlockStatement();for(let u=o.parent;u;u=u.parent){var r;if(u===e.scope){if(l){Dn(n.path,t);return}break}(r=u.path.parentPath)!=null&&r.isBlockStatement()&&(l=!0)}}if(n.hasValue)return n.value}let s=e.node.name;if(dC.has(s)){if(!n)return dC.get(s);Dn(n.path,t);return}let i=e.resolve();if(i===e){Dn(e,t);return}let a=Mr(i,t);if(typeof a=="object"&&a!==null&&n.references>1){Dn(i,t);return}return a}if(e.isUnaryExpression({prefix:!0})){if(e.node.operator==="void")return;let n=e.get("argument");if(e.node.operator==="typeof"&&(n.isFunction()||n.isClass()))return"function";let s=Mr(n,t);if(!t.confident)return;switch(e.node.operator){case"!":return!s;case"+":return+s;case"-":return-s;case"~":return~s;case"typeof":return typeof s}}if(e.isArrayExpression()){let n=[],s=e.get("elements");for(let i of s){let a=i.evaluate();if(a.confident)n.push(a.value);else{Dn(a.deopt,t);return}}return n}if(e.isObjectExpression()){let n={},s=e.get("properties");for(let i of s){if(i.isObjectMethod()||i.isSpreadElement()){Dn(i,t);return}let a=i.get("key"),o;if(i.node.computed){if(o=a.evaluate(),!o.confident){Dn(o.deopt,t);return}o=o.value}else a.isIdentifier()?o=a.node.name:o=a.node.value;let u=i.get("value").evaluate();if(!u.confident){Dn(u.deopt,t);return}u=u.value,n[o]=u}return n}if(e.isLogicalExpression()){let n=t.confident,s=Mr(e.get("left"),t),i=t.confident;t.confident=n;let a=Mr(e.get("right"),t),o=t.confident;switch(e.node.operator){case"||":return t.confident=i&&(!!s||o),t.confident?s||a:void 0;case"&&":return t.confident=i&&(!s||o),t.confident?s&&a:void 0;case"??":return t.confident=i&&(s!=null||o),t.confident?s!=null?s:a:void 0}}if(e.isBinaryExpression()){let n=Mr(e.get("left"),t);if(!t.confident)return;let s=Mr(e.get("right"),t);if(!t.confident)return;switch(e.node.operator){case"-":return n-s;case"+":return n+s;case"/":return n/s;case"*":return n*s;case"%":return n%s;case"**":return Math.pow(n,s);case"<":return n<s;case">":return n>s;case"<=":return n<=s;case">=":return n>=s;case"==":return n==s;case"!=":return n!=s;case"===":return n===s;case"!==":return n!==s;case"|":return n|s;case"&":return n&s;case"^":return n^s;case"<<":return n<<s;case">>":return n>>s;case">>>":return n>>>s}}if(e.isCallExpression()){let n=e.get("callee"),s,i;if(n.isIdentifier()&&!e.scope.getBinding(n.node.name)&&(fC(n.node.name)||Lle(n.node.name))&&(i=global[n.node.name]),n.isMemberExpression()){let a=n.get("object"),o=n.get("property");if(a.isIdentifier()&&o.isIdentifier()&&fC(a.node.name)&&!jle(o.node.name)){s=global[a.node.name];let l=o.node.name;hasOwnProperty.call(s,l)&&(i=s[l])}if(a.isLiteral()&&o.isIdentifier()){let l=typeof a.node.value;(l==="string"||l==="number")&&(s=a.node.value,i=s[o.node.name])}}if(i){let a=e.get("arguments").map(o=>Mr(o,t));return t.confident?i.apply(s,a):void 0}}Dn(e,t)}}function hC(e,t,r,n=!1){let s="",i=0,a=e.isTemplateLiteral()?e.get("expressions"):e.get("quasi.expressions");for(let o of t){if(!r.confident)break;s+=n?o.value.raw:o.value.cooked;let l=a[i++];l&&(s+=String(Mr(l,r)))}if(r.confident)return s}function qle(){let e={confident:!0,deoptPath:null,seen:new Map},t=Mr(this,e);return e.confident||(t=void 0),{confident:e.confident,deopt:e.deoptPath,value:t}}});var vC=x(ls=>{"use strict";Object.defineProperty(ls,"__esModule",{value:!0});ls.arrowFunctionToExpression=yue;ls.ensureBlock=due;ls.ensureFunctionName=wue;ls.splitExportDeclaration=Cue;ls.toComputedKey=fue;ls.unwrapFunctionEnvironment=hue;var Ule=Fe(),Vle=Ko(),F0=Zu(),$le=An(),{arrowFunctionExpression:L0,assignmentExpression:Ni,binaryExpression:B0,blockStatement:Wle,callExpression:_a,conditionalExpression:Kle,expressionStatement:bC,identifier:St,isIdentifier:Hle,jsxIdentifier:Gle,logicalExpression:Xle,LOGICAL_OPERATORS:Yle,memberExpression:wn,metaProperty:Jle,numericLiteral:zle,objectExpression:Qle,restElement:Zle,returnStatement:eue,sequenceExpression:tue,spreadElement:rue,stringLiteral:EC,super:k0,thisExpression:el,toExpression:TC,unaryExpression:nue,toBindingIdentifierName:sue,isFunction:iue,isAssignmentPattern:aue,isRestElement:oue,getFunctionName:lue,cloneNode:Oi,variableDeclaration:uue,variableDeclarator:cue,exportNamedDeclaration:yC,exportSpecifier:gC,inherits:pue}=Ule;function fue(){let e;if(this.isMemberExpression())e=this.node.property;else if(this.isProperty()||this.isMethod())e=this.node.key;else throw new ReferenceError("todo");return this.node.computed||Hle(e)&&(e=EC(e.name)),e}function due(){let e=this.get("body"),t=e.node;if(Array.isArray(e))throw new Error("Can't convert array path to a block statement");if(!t)throw new Error("Can't convert node without a body");if(e.isBlockStatement())return t;let r=[],n="body",s,i;e.isStatement()?(i="body",s=0,r.push(e.node)):(n+=".body.0",this.isFunction()?(s="argument",r.push(eue(e.node))):(s="expression",r.push(bC(e.node)))),this.node.body=Wle(r);let a=this.get(n);return $le.setup.call(e,a,i?a.node[i]:a.node,i,s),this.node}ls.arrowFunctionToShadowed=function(){this.isArrowFunctionExpression()&&this.arrowFunctionToExpression()};function hue(){if(!this.isArrowFunctionExpression()&&!this.isFunctionExpression()&&!this.isFunctionDeclaration())throw this.buildCodeFrameError("Can only unwrap the environment of a function.");xC(this)}function mue(e,t){e.node.type=t}function yue({allowInsertArrow:e=!0,allowInsertArrowWithRest:t=e,noNewArrows:r=!(n=>(n=arguments[0])==null?void 0:n.specCompliant)()}={}){if(!this.isArrowFunctionExpression())throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");let n=this;if(!r){var s;n=(s=n.ensureFunctionName(!1))!=null?s:n}let{thisBinding:i,fnPath:a}=xC(n,r,e,t);if(a.ensureBlock(),mue(a,"FunctionExpression"),!r){let o=i?null:a.scope.generateUidIdentifier("arrowCheckId");return o&&a.parentPath.scope.push({id:o,init:Qle([])}),a.get("body").unshiftContainer("body",bC(_a(this.hub.addHelper("newArrowCheck"),[el(),St(o?o.name:i)]))),a.replaceWith(_a(wn(a.node,St("bind")),[o?St(o.name):el()])),a.get("callee.object")}return a}var gue=(0,F0.environmentVisitor)({CallExpression(e,{allSuperCalls:t}){e.get("callee").isSuper()&&t.push(e)}});function xC(e,t=!0,r=!0,n=!0){let s,i=e.findParent(m=>m.isArrowFunctionExpression()?(s!=null||(s=m),!1):m.isFunction()||m.isProgram()||m.isClassProperty({static:!1})||m.isClassPrivateProperty({static:!1})),a=i.isClassMethod({kind:"constructor"});if(i.isClassProperty()||i.isClassPrivateProperty())if(s)i=s;else if(r)e.replaceWith(_a(L0([],TC(e.node)),[])),i=e.get("callee"),e=i.get("body");else throw e.buildCodeFrameError("Unable to transform arrow inside class property");let{thisPaths:o,argumentsPaths:l,newTargetPaths:u,superProps:c,superCalls:p}=Aue(e);if(a&&p.length>0){if(!r)throw p[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");if(!n)throw p[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");let m=[];i.traverse(gue,{allSuperCalls:m});let g=Sue(i);m.forEach(f=>{let b=St(g);b.loc=f.node.callee.loc,f.get("callee").replaceWith(b)})}if(l.length>0){let m=tl(i,"arguments",()=>{let g=()=>St("arguments");return i.scope.path.isProgram()?Kle(B0("===",nue("typeof",g()),EC("undefined")),i.scope.buildUndefinedNode(),g()):g()});l.forEach(g=>{let f=St(m);f.loc=g.node.loc,g.replaceWith(f)})}if(u.length>0){let m=tl(i,"newtarget",()=>Jle(St("new"),St("target")));u.forEach(g=>{let f=St(m);f.loc=g.node.loc,g.replaceWith(f)})}if(c.length>0){if(!r)throw c[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");c.reduce((g,f)=>g.concat(Eue(f)),[]).forEach(g=>{let f=g.node.computed?"":g.get("property").node.name,b=g.parentPath,T=b.isAssignmentExpression({left:g.node}),w=b.isCallExpression({callee:g.node}),I=b.isTaggedTemplateExpression({tag:g.node}),N=vue(i,T,f),L=[];if(g.node.computed&&L.push(g.get("property").node),T){let U=b.node.right;L.push(U)}let W=_a(St(N),L);w?(b.unshiftContainer("arguments",el()),g.replaceWith(wn(W,St("call"))),o.push(b.get("arguments.0"))):T?b.replaceWith(W):I?(g.replaceWith(_a(wn(W,St("bind"),!1),[el()])),o.push(g.get("arguments.0"))):g.replaceWith(W)})}let d;return(o.length>0||!t)&&(d=xue(i,a),(t||a&&SC(i))&&(o.forEach(m=>{let g=m.isJSX()?Gle(d):St(d);g.loc=m.node.loc,m.replaceWith(g)}),t||(d=null))),{thisBinding:d,fnPath:e}}function bue(e){return Yle.includes(e)}function Eue(e){if(e.parentPath.isAssignmentExpression()&&e.parentPath.node.operator!=="="){let r=e.parentPath,n=r.node.operator.slice(0,-1),s=r.node.right,i=bue(n);if(e.node.computed){let a=e.scope.generateDeclaredUidIdentifier("tmp"),o=e.node.object,l=e.node.property;r.get("left").replaceWith(wn(o,Ni("=",a,l),!0)),r.get("right").replaceWith(t(i?"=":n,wn(o,St(a.name),!0),s))}else{let a=e.node.object,o=e.node.property;r.get("left").replaceWith(wn(a,o)),r.get("right").replaceWith(t(i?"=":n,wn(a,St(o.name)),s))}return i?r.replaceWith(Xle(n,r.node.left,r.node.right)):r.node.operator="=",[r.get("left"),r.get("right").get("left")]}else if(e.parentPath.isUpdateExpression()){let r=e.parentPath,n=e.scope.generateDeclaredUidIdentifier("tmp"),s=e.node.computed?e.scope.generateDeclaredUidIdentifier("prop"):null,i=[Ni("=",n,wn(e.node.object,s?Ni("=",s,e.node.property):e.node.property,e.node.computed)),Ni("=",wn(e.node.object,s?St(s.name):e.node.property,e.node.computed),B0(e.parentPath.node.operator[0],St(n.name),zle(1)))];e.parentPath.node.prefix||i.push(St(n.name)),r.replaceWith(tue(i));let a=r.get("expressions.0.right"),o=r.get("expressions.1.left");return[a,o]}return[e];function t(r,n,s){return r==="="?Ni("=",n,s):B0(r,n,s)}}function SC(e){return e.isClassMethod()&&!!e.parentPath.parentPath.node.superClass}var Tue=(0,F0.environmentVisitor)({CallExpression(e,{supers:t,thisBinding:r}){e.get("callee").isSuper()&&(t.has(e.node)||(t.add(e.node),e.replaceWithMultiple([e.node,Ni("=",St(r),St("this"))])))}});function xue(e,t){return tl(e,"this",r=>{if(!t||!SC(e))return el();e.traverse(Tue,{supers:new WeakSet,thisBinding:r})})}function Sue(e){return tl(e,"supercall",()=>{let t=e.scope.generateUidIdentifier("args");return L0([Zle(t)],_a(k0(),[rue(St(t.name))]))})}function vue(e,t,r){return tl(e,`superprop_${t?"set":"get"}:${r||""}`,()=>{let s=[],i;if(r)i=wn(k0(),St(r));else{let a=e.scope.generateUidIdentifier("prop");s.unshift(a),i=wn(k0(),St(a.name),!0)}if(t){let a=e.scope.generateUidIdentifier("value");s.push(a),i=Ni("=",i,St(a.name))}return L0(s,i)})}function tl(e,t,r){let n="binding:"+t,s=e.getData(n);if(!s){let i=e.scope.generateUidIdentifier(t);s=i.name,e.setData(n,s),e.scope.push({id:i,init:r(s)})}return s}var Pue=(0,F0.environmentVisitor)({ThisExpression(e,{thisPaths:t}){t.push(e)},JSXIdentifier(e,{thisPaths:t}){e.node.name==="this"&&(!e.parentPath.isJSXMemberExpression({object:e.node})&&!e.parentPath.isJSXOpeningElement({name:e.node})||t.push(e))},CallExpression(e,{superCalls:t}){e.get("callee").isSuper()&&t.push(e)},MemberExpression(e,{superProps:t}){e.get("object").isSuper()&&t.push(e)},Identifier(e,{argumentsPaths:t}){if(!e.isReferencedIdentifier({name:"arguments"}))return;let r=e.scope;do{if(r.hasOwnBinding("arguments")){r.rename("arguments");return}if(r.path.isFunction()&&!r.path.isArrowFunctionExpression())break}while(r=r.parent);t.push(e)},MetaProperty(e,{newTargetPaths:t}){e.get("meta").isIdentifier({name:"new"})&&e.get("property").isIdentifier({name:"target"})&&t.push(e)}});function Aue(e){let t=[],r=[],n=[],s=[],i=[];return e.traverse(Pue,{thisPaths:t,argumentsPaths:r,newTargetPaths:n,superProps:s,superCalls:i}),{thisPaths:t,argumentsPaths:r,newTargetPaths:n,superProps:s,superCalls:i}}function Cue(){if(!this.isExportDeclaration()||this.isExportAllDeclaration())throw new Error("Only default and named export declarations can be split.");if(this.isExportNamedDeclaration()&&this.get("specifiers").length>0)throw new Error("It doesn't make sense to split exported specifiers.");let e=this.get("declaration");if(this.isExportDefaultDeclaration()){let s=e.isFunctionDeclaration()||e.isClassDeclaration(),i=e.isFunctionExpression()||e.isClassExpression(),a=e.isScope()?e.scope.parent:e.scope,o=e.node.id,l=!1;o?i&&a.hasBinding(o.name)&&(l=!0,o=a.generateUidIdentifier(o.name)):(l=!0,o=a.generateUidIdentifier("default"),(s||i)&&(e.node.id=Oi(o)));let u=s?e.node:uue("var",[cue(Oi(o),e.node)]),c=yC(null,[gC(Oi(o),St("default"))]);return this.insertAfter(c),this.replaceWith(u),l&&a.registerDeclaration(this),this}else if(this.get("specifiers").length>0)throw new Error("It doesn't make sense to split exported specifiers.");let t=e.getOuterBindingIdentifiers(),r=Object.keys(t).map(s=>gC(St(s),St(s))),n=yC(null,r);return this.insertAfter(n),this.replaceWith(e.node),this}var Due={"ReferencedIdentifier|BindingIdentifier"(e,t){e.node.name===t.name&&(t.needsRename=!0,e.stop())},Scope(e,t){e.scope.hasOwnBinding(t.name)&&e.skip()}};function wue(e){if(this.node.id)return this;let t=lue(this.node,this.parent);if(t==null)return this;let{name:r}=t;if(!e&&/[\uD800-\uDFFF]/.test(r)||r.startsWith("get ")||r.startsWith("set "))return null;r=sue(r.replace(/[/ ]/g,"_"));let n=St(r);pue(n,t.originalNode);let s={needsRename:!1,name:r},{scope:i}=this,a=i.getOwnBinding(r);if(a?a.kind==="param"&&(s.needsRename=!0):(i.parent.hasBinding(r)||i.hasGlobal(r))&&this.traverse(Due,s),!s.needsRename)return this.node.id=n,i.getProgramParent().references[n.name]=!0,this;if(i.hasBinding(n.name)&&!i.hasGlobal(n.name))return i.rename(n.name),this.node.id=n,i.getProgramParent().references[n.name]=!0,this;if(!iue(this.node))return null;let o=i.generateUidIdentifier(n.name),l=[];for(let c=0,p=Iue(this.node);c<p;c++)l.push(i.generateUidIdentifier("x"));let u=Vle.default.expression.ast`
node_modules/playwright/lib/transform/babelBundleImpl.js:199:`+I_().fromObject(c).toComment()),r.sourceMaps==="inline"&&(c=null),{outputCode:u,outputMap:c}}});var af=x(_1=>{"use strict";Object.defineProperty(_1,"__esModule",{value:!0});_1.run=tge;function I1(){let e=zt();return I1=function(){return e},e}var Y0e=o_(),J0e=f_(),z0e=c1(),Q0e=P_(),Z0e=__(),ege=mp(),w1=Xs();function*tge(e,t,r){let n=yield*(0,Q0e.default)(e.passes,(0,z0e.default)(e),t,r),s=n.opts;try{yield*rge(n,e.passes)}catch(u){var i;throw u.message=`${(i=s.filename)!=null?i:"unknown file"}: ${u.message}`,u.code||(u.code="BABEL_TRANSFORM_ERROR"),u}let a,o;try{s.code!==!1&&({outputCode:a,outputMap:o}=(0,Z0e.default)(e.passes,n))}catch(u){var l;throw u.message=`${(l=s.filename)!=null?l:"unknown file"}: ${u.message}`,u.code||(u.code="BABEL_GENERATE_ERROR"),u}return{metadata:n.metadata,options:s,ast:s.ast===!0?n.ast:null,code:a===void 0?null:a,map:o===void 0?null:o,sourceType:n.ast.program.sourceType,externalDependencies:(0,ege.flattenToSet)(e.externalDependencies)}}function*rge(e,t){let r=yield*(0,w1.isAsync)();for(let n of t){let s=[],i=[],a=[];for(let l of n.concat([(0,J0e.default)()])){let u=new Y0e.default(e,l.key,l.options,r);s.push([l,u]),i.push(u),a.push(l.visitor)}for(let[l,u]of s)l.pre&&(yield*(0,w1.maybeAsync)(l.pre,"You appear to be using an async plugin/preset, but Babel has been called synchronously").call(u,e));let o=I1().default.visitors.merge(a,i,e.opts.wrapPluginVisitorMethod);(0,I1().default)(e.ast,o,e.scope);for(let[l,u]of s)l.post&&(yield*(0,w1.maybeAsync)(l.post,"You appear to be using an async plugin/preset, but Babel has been called synchronously").call(u,e))}}});var O1=x(kl=>{"use strict";Object.defineProperty(kl,"__esModule",{value:!0});kl.transformFile=age;kl.transformFileAsync=lge;kl.transformFileSync=oge;function N_(){let e=en();return N_=function(){return e},e}var nge=Za(),sge=af(),ige=ip(),N1=N_()(function*(e,t){let r=Object.assign({},t,{filename:e}),n=yield*(0,nge.default)(r);if(n===null)return null;let s=yield*ige.readFile(e,"utf8");return yield*(0,sge.run)(n,s)});function age(...e){N1.errback(...e)}function oge(...e){return N1.sync(...e)}function lge(...e){return N1.async(...e)}});var B_=x((K3e,O_)=>{O_.exports=function(t){return import(t)}});var k_=x((H3e,uge)=>{uge.exports={name:"@babel/preset-typescript",version:"7.27.1",description:"Babel preset for TypeScript.",repository:{type:"git",url:"https://github.com/babel/babel.git",directory:"packages/babel-preset-typescript"},license:"MIT",publishConfig:{access:"public"},main:"./lib/index.js",keywords:["babel-preset","typescript"],dependencies:{"@babel/helper-plugin-utils":"^7.27.1","@babel/helper-validator-option":"^7.27.1","@babel/plugin-syntax-jsx":"^7.27.1","@babel/plugin-transform-modules-commonjs":"^7.27.1","@babel/plugin-transform-typescript":"^7.27.1"},peerDependencies:{"@babel/core":"^7.0.0-0"},devDependencies:{"@babel/core":"^7.27.1","@babel/helper-plugin-test-runner":"^7.27.1"},homepage:"https://babel.dev/docs/en/next/babel-preset-typescript",bugs:"https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22area%3A%20typescript%22+is%3Aopen",engines:{node:">=6.9.0"},author:"The Babel Team (https://babel.dev/team)",type:"commonjs"}});var Ft=x(Fl=>{"use strict";Object.defineProperty(Fl,"__esModule",{value:!0});Fl.declare=F_;Fl.declarePreset=void 0;var B1={assertVersion:e=>t=>{pge(t,e.version)}};Object.assign(B1,{targets:()=>()=>({}),assumption:()=>()=>{},addExternalDependency:()=>()=>{}});function F_(e){return(t,r,n)=>{let s;for(let i of Object.keys(B1))t[i]||(s!=null||(s=cge(t)),s[i]=B1[i](s));return e(s!=null?s:t,r||{},n)}}var G3e=Fl.declarePreset=F_;function cge(e){let t=null;return typeof e.version=="string"&&/^7\./.test(e.version)&&(t=Object.getPrototypeOf(e),t&&(!hasOwnProperty.call(t,"version")||!hasOwnProperty.call(t,"transform")||!hasOwnProperty.call(t,"template")||!hasOwnProperty.call(t,"types"))&&(t=null)),Object.assign({},t,e)}function pge(e,t){if(typeof e=="number"){if(!Number.isInteger(e))throw new Error("Expected string or integer value.");e=`^${e}.0.0-0`}if(typeof e!="string")throw new Error("Expected string or integer value.");let r=Error.stackTraceLimit;typeof r=="number"&&r<25&&(Error.stackTraceLimit=25);let n;throw t.slice(0,2)==="7."?n=new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${t}". You'll need to update your @babel/core version.`):n=new Error(`Requires Babel "${e}", but was loaded with "${t}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`),typeof r=="number"&&(Error.stackTraceLimit=r),Object.assign(n,{code:"BABEL_VERSION_UNSUPPORTED",version:t,range:e})}});var L_=x(of=>{"use strict";Object.defineProperty(of,"__esModule",{value:!0});of.default=void 0;var fge=Ft();k1=function(e,t){let r=[];e.forEach((n,s)=>{(Array.isArray(n)?n[0]:n)===t&&r.unshift(s)});for(let n of r)e.splice(n,1)};var k1,Y3e=of.default=(0,fge.declare)((e,t)=>{e.assertVersion(7);let{disallowAmbiguousJSXLike:r,dts:n}=t;var{isTSX:s}=t;return{name:"syntax-typescript",manipulateOptions(i,a){{let{plugins:o}=a;k1(o,"flow"),k1(o,"jsx"),o.push("objectRestSpread","classProperties"),s&&o.push("jsx")}a.plugins.push(["typescript",{disallowAmbiguousJSXLike:r,dts:n}])}}})});var R1=x(M1=>{"use strict";Object.defineProperty(M1,"__esModule",{value:!0});var dge=Fe();function hge(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach(function(r){if(r!=="default"){var n=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,n.get?n:{enumerable:!0,get:function(){return e[r]}})}}),t.default=e,Object.freeze(t)}var mge=hge(dge);function L1(e){let t=e,{node:r,parentPath:n}=t;if(n.isLogicalExpression()){let{operator:s,right:i}=n.node;if(s==="&&"||s==="||"||s==="??"&&r===i)return L1(n)}if(n.isSequenceExpression()){let{expressions:s}=n.node;return s[s.length-1]===r?L1(n):!0}return n.isConditional({test:r})||n.isUnaryExpression({operator:"!"})||n.isLoop({test:r})}var{LOGICAL_OPERATORS:yge,arrowFunctionExpression:j_,assignmentExpression:eo,binaryExpression:Gi,booleanLiteral:gge,callExpression:cf,cloneNode:En,conditionalExpression:bge,identifier:V_,isMemberExpression:Ege,isOptionalCallExpression:Tge,isOptionalMemberExpression:$_,isUpdateExpression:xge,logicalExpression:uf,memberExpression:M_,nullLiteral:lf,optionalCallExpression:Sge,optionalMemberExpression:vge,sequenceExpression:F1,updateExpression:R_}=mge,j1=class{constructor(){this._map=void 0,this._map=new WeakMap}has(t){return this._map.has(t)}get(t){if(!this.has(t))return;let r=this._map.get(t),{value:n}=r;return r.count--,r.count===0?eo("=",n,t):n}set(t,r,n){return this._map.set(t,{count:n,value:r})}};function q_(e,t){let{node:r}=e;if($_(r))return M_(t,r.property,r.computed);if(e.isOptionalCallExpression()){let n=e.get("callee");if(e.node.optional&&n.isOptionalMemberExpression()){let s=n.node.object,i=e.scope.maybeGenerateMemoised(s);return n.get("object").replaceWith(eo("=",i,s)),cf(M_(t,V_("call")),[i,...e.node.arguments])}return cf(t,e.node.arguments)}return e.node}function Pge(e){for(;e&&!e.isProgram();){let{parentPath:t,container:r,listKey:n}=e,s=t.node;if(n){if(r!==s[n])return!0}else if(r!==s)return!0;e=t}return!1}var Age={memoise(){},handle(e,t){let{node:r,parent:n,parentPath:s,scope:i}=e;if(e.isOptionalMemberExpression()){if(Pge(e))return;let a=e.find(({node:U,parent:H})=>$_(H)?H.optional||H.object!==U:Tge(H)?U!==e.node&&H.optional||H.callee!==U:!0);if(i.path.isPattern()){a.replaceWith(cf(j_([],a.node),[]));return}let o=L1(a),l=a.parentPath;if(l.isUpdateExpression({argument:r}))throw e.buildCodeFrameError("can't handle update expression");let u=l.isAssignmentExpression({left:a.node}),c=l.isUnaryExpression({operator:"delete"});if(c&&a.isOptionalMemberExpression()&&a.get("property").isPrivateName())throw e.buildCodeFrameError("can't delete a private class element");let p=e;for(;;){if(p.isOptionalMemberExpression()){if(p.node.optional)break;p=p.get("object");continue}else if(p.isOptionalCallExpression()){if(p.node.optional)break;p=p.get("callee");continue}throw new Error(`Internal error: unexpected ${p.node.type}`)}let d=p.isOptionalMemberExpression()?p.node.object:p.node.callee,m=i.maybeGenerateMemoised(d),g=m!=null?m:d,f=s.isOptionalCallExpression({callee:r}),b=U=>f,T=s.isCallExpression({callee:r});p.replaceWith(q_(p,g)),b()?n.optional?s.replaceWith(this.optionalCall(e,n.arguments)):s.replaceWith(this.call(e,n.arguments)):T?e.replaceWith(this.boundGet(e)):this.delete&&s.isUnaryExpression({operator:"delete"})?s.replaceWith(this.delete(e)):s.isAssignmentExpression()?U_(this,e,s):e.replaceWith(this.get(e));let w=e.node;for(let U=e;U!==a;){let H=U.parentPath;if(H===a&&b()&&n.optional){w=H.node;break}w=q_(H,w),U=H}let I,N=a.parentPath;if(Ege(w)&&N.isOptionalCallExpression({callee:a.node,optional:!0})){let{object:U}=w;I=e.scope.maybeGenerateMemoised(U),I&&(w.object=eo("=",I,U))}let L=a;(c||u)&&(L=N,w=N.node);let W=m?eo("=",En(g),En(d)):En(g);if(o){let U;t?U=Gi("!=",W,lf()):U=uf("&&",Gi("!==",W,lf()),Gi("!==",En(g),i.buildUndefinedNode())),L.replaceWith(uf("&&",U,w))}else{let U;t?U=Gi("==",W,lf()):U=uf("||",Gi("===",W,lf()),Gi("===",En(g),i.buildUndefinedNode())),L.replaceWith(bge(U,c?gge(!0):i.buildUndefinedNode(),w))}if(I){let U=N.node;N.replaceWith(Sge(vge(U.callee,V_("call"),!1,!0),[En(I),...U.arguments],!1))}return}if(xge(n,{argument:r})){if(this.simpleSet){e.replaceWith(this.simpleSet(e));return}let{operator:a,prefix:o}=n;this.memoise(e,2);let l=i.generateUidIdentifierBasedOnNode(r);i.push({id:l});let u=[eo("=",En(l),this.get(e))];if(o){u.push(R_(a,En(l),o));let c=F1(u);s.replaceWith(this.set(e,c));return}else{let c=i.generateUidIdentifierBasedOnNode(r);i.push({id:c}),u.push(eo("=",En(c),R_(a,En(l),o)),En(l));let p=F1(u);s.replaceWith(F1([this.set(e,p),En(c)]));return}}if(s.isAssignmentExpression({left:r})){U_(this,e,s);return}if(s.isCallExpression({callee:r})){s.replaceWith(this.call(e,s.node.arguments));return}if(s.isOptionalCallExpression({callee:r})){if(i.path.isPattern()){s.replaceWith(cf(j_([],s.node),[]));return}s.replaceWith(this.optionalCall(e,s.node.arguments));return}if(this.delete&&s.isUnaryExpression({operator:"delete"})){s.replaceWith(this.delete(e));return}if(s.isForXStatement({left:r})||s.isObjectProperty({value:r})&&s.parentPath.isObjectPattern()||s.isAssignmentPattern({left:r})&&s.parentPath.isObjectProperty({value:n})&&s.parentPath.parentPath.isObjectPattern()||s.isArrayPattern()||s.isAssignmentPattern({left:r})&&s.parentPath.isArrayPattern()||s.isRestElement()){e.replaceWith(this.destructureSet(e));return}s.isTaggedTemplateExpression()?e.replaceWith(this.boundGet(e)):e.replaceWith(this.get(e))}};function U_(e,t,r){if(e.simpleSet){t.replaceWith(e.simpleSet(t));return}let{operator:n,right:s}=r.node;if(n==="=")r.replaceWith(e.set(t,s));else{let i=n.slice(0,-1);yge.includes(i)?(e.memoise(t,1),r.replaceWith(uf(i,e.get(t),e.set(t,s)))):(e.memoise(t,2),r.replaceWith(e.set(t,Gi(i,e.get(t),s))))}}function Cge(e,t,r){e.traverse(t,Object.assign({},Age,r,{memoiser:new j1}))}M1.default=Cge});var U1=x(q1=>{"use strict";Object.defineProperty(q1,"__esModule",{value:!0});q1.default=_ge;var Dge=Fe(),{callExpression:W_,identifier:pf,isIdentifier:wge,isSpreadElement:Ige,memberExpression:K_,optionalCallExpression:H_,optionalMemberExpression:G_}=Dge;function _ge(e,t,r,n){return r.length===1&&Ige(r[0])&&wge(r[0].argument,{name:"arguments"})?n?H_(G_(e,pf("apply"),!1,!0),[t,r[0].argument],!1):W_(K_(e,pf("apply")),[t,r[0].argument]):n?H_(G_(e,pf("call"),!1,!0),[t,...r],!1):W_(K_(e,pf("call")),[t,...r])}});var df=x(ro=>{"use strict";Object.defineProperty(ro,"__esModule",{value:!0});ro.default=void 0;var Nge=R1(),ff=U1(),wr=vt(),$1=zt(),{assignmentExpression:Oge,callExpression:Ss,cloneNode:Er,identifier:to,memberExpression:Xi,sequenceExpression:Yi,stringLiteral:Y_,thisExpression:Ir}=wr.types;ro.environmentVisitor=$1.visitors.environmentVisitor({}),ro.skipAllButComputedKey=function(t){t.skip(),t.node.computed&&t.context.maybeQueue(t.get("key"))};var X_=$1.visitors.environmentVisitor({Super(e,t){let{node:r,parentPath:n}=e;n.isMemberExpression({object:r})&&t.handle(n)}}),Bge=$1.visitors.environmentVisitor({Scopable(e,{refName:t}){let r=e.scope.getOwnBinding(t);r&&r.identifier.name===t&&e.scope.rename(t)}}),J_={memoise(e,t){let{scope:r,node:n}=e,{computed:s,property:i}=n;if(!s)return;let a=r.maybeGenerateMemoised(i);a&&this.memoiser.set(i,a,t)},prop(e){let{computed:t,property:r}=e.node;return this.memoiser.has(r)?Er(this.memoiser.get(r)):t?Er(r):Y_(r.name)},_getPrototypeOfExpression(){let e=Er(this.getObjectRef()),t=this.isStatic||this.isPrivateMethod?e:Xi(e,to("prototype"));return Ss(this.file.addHelper("getPrototypeOf"),[t])},get(e){let t=Er(this.getObjectRef());return Ss(this.file.addHelper("superPropGet"),[this.isDerivedConstructor?Yi([Ir(),t]):t,this.prop(e),Ir(),...this.isStatic||this.isPrivateMethod?[]:[wr.types.numericLiteral(1)]])},_call(e,t,r){let n=Er(this.getObjectRef()),s;t.length===1&&wr.types.isSpreadElement(t[0])&&(wr.types.isIdentifier(t[0].argument)||wr.types.isArrayExpression(t[0].argument))?s=t[0].argument:s=wr.types.arrayExpression(t);let i=wr.types.callExpression(this.file.addHelper("superPropGet"),[this.isDerivedConstructor?Yi([Ir(),n]):n,this.prop(e),Ir(),wr.types.numericLiteral(2|(this.isStatic||this.isPrivateMethod?0:1))]);return r?wr.types.optionalCallExpression(i,[s],!0):Ss(i,[s])},set(e,t){let r=Er(this.getObjectRef());return Ss(this.file.addHelper("superPropSet"),[this.isDerivedConstructor?Yi([Ir(),r]):r,this.prop(e),t,Ir(),wr.types.numericLiteral(e.isInStrictMode()?1:0),...this.isStatic||this.isPrivateMethod?[]:[wr.types.numericLiteral(1)]])},destructureSet(e){throw e.buildCodeFrameError("Destructuring to a super field is not supported yet.")},call(e,t){return this._call(e,t,!1)},optionalCall(e,t){return this._call(e,t,!0)},delete(e){return e.node.computed?Yi([Ss(this.file.addHelper("toPropertyKey"),[Er(e.node.property)]),wr.template.expression.ast`
node_modules/playwright/lib/transform/babelBundleImpl.js:457:      `;Re.types.inherits(p,i.node);let{parentPath:d}=i;d.isFunction()||d.isTryStatement()||d.isCatchClause()?i.replaceWith(Re.types.blockStatement([p])):i.isStaticBlock()?i.node.body=[p]:i.replaceWith(p)}},s=Re.traverse.visitors.merge([n,{Function(i){i.skip()}}]);return{name:"transform-explicit-resource-management",manipulateOptions:(i,a)=>a.plugins.push("explicitResourceManagement"),visitor:Re.traverse.visitors.merge([n,{Program(i){if(t.clear(),i.node.sourceType!=="module"||!i.node.body.some(r))return;let a=[];for(let o of i.get("body")){if(o.isFunctionDeclaration()||o.isImportDeclaration())continue;let l=o.node,u=!0;if(o.isExportDefaultDeclaration()){let{declaration:c}=o.node,p;if(Re.types.isClassDeclaration(c))p=c.id,c.id=Re.types.cloneNode(p),c=Re.types.toExpression(c);else if(!Re.types.isExpression(c))continue;p!=null||(p=i.scope.generateUidIdentifier("_default")),a.push(Re.types.variableDeclaration("var",[Re.types.variableDeclarator(p,c)])),o.replaceWith(Re.types.exportNamedDeclaration(null,[Re.types.exportSpecifier(Re.types.cloneNode(p),Re.types.identifier("default"))]));continue}if(o.isExportNamedDeclaration()){if(l=o.node.declaration,!l||Re.types.isFunction(l))continue;o.replaceWith(Re.types.exportNamedDeclaration(null,Object.keys(Re.types.getOuterBindingIdentifiers(l,!1)).map(c=>Re.types.exportSpecifier(Re.types.identifier(c),Re.types.identifier(c))))),u=!1}else if(o.isExportDeclaration())continue;if(Re.types.isClassDeclaration(l)){let{id:c}=l;l.id=Re.types.cloneNode(c),a.push(Re.types.variableDeclaration("var",[Re.types.variableDeclarator(c,Re.types.toExpression(l))]))}else Re.types.isVariableDeclaration(l)?(l.kind==="using"?t.set(o.node,0):l.kind==="await using"&&t.set(o.node,1),l.kind="var",a.push(l)):a.push(o.node);u&&o.remove()}i.pushContainer("body",Re.types.blockStatement(a))},Function(i,a){i.node.async&&i.traverse(s,a)}}])}})});var G3=x(Qf=>{"use strict";Object.defineProperty(Qf,"__esModule",{value:!0});Qf.default=void 0;var cSe=Ft(),H3=io(),lke=Qf.default=(0,cSe.declare)((e,t)=>(e.assertVersion(7),(0,H3.createClassFeaturePlugin)({name:"transform-class-properties",api:e,feature:H3.FEATURES.fields,loose:t.loose,manipulateOptions(r,n){n.plugins.push("classProperties","classPrivateProperties")}})))});var Y3=x(Zf=>{"use strict";Object.defineProperty(Zf,"__esModule",{value:!0});Zf.default=void 0;var pSe=Ft(),X3=io();function fSe(e,t){let n,s=1;do n="_",s>1&&(n+=s),s++;while(t.has(n));return n}var cke=Zf.default=(0,pSe.declare)(({types:e,template:t,assertVersion:r})=>(r("^7.12.0 || >8.0.0-alpha <8.0.0-beta"),{name:"transform-class-static-block",manipulateOptions:(n,s)=>s.plugins.push("classStaticBlock"),pre(){(0,X3.enableFeature)(this.file,X3.FEATURES.staticBlocks,!1)},visitor:{ClassBody(n){let{scope:s}=n,i=new Set,a=n.get("body");for(let o of a)o.isPrivate()&&i.add(o.get("key.id").node.name);for(let o of a){if(!o.isStaticBlock())continue;let l=fSe(s,i);i.add(l);let u=e.privateName(e.identifier(l)),c,p=o.node.body;p.length===1&&e.isExpressionStatement(p[0])?c=e.inheritsComments(p[0].expression,p[0]):c=t.expression.ast`(() => { ${p} })()`,o.replaceWith(e.classPrivateProperty(u,c,[],!0))}}}}))});var z3=x(ed=>{"use strict";Object.defineProperty(ed,"__esModule",{value:!0});ed.default=void 0;var dSe=Ft();function J3({node:e}){var t;let{extra:r}=e;r!=null&&(t=r.raw)!=null&&t.includes("_")&&(r.raw=r.raw.replace(/_/g,""))}var fke=ed.default=(0,dSe.declare)(e=>(e.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta"),{name:"transform-numeric-separator",manipulateOptions:(t,r)=>r.plugins.push("numericSeparator"),visitor:{NumericLiteral:J3,BigIntLiteral:J3}}))});var Q3=x(td=>{"use strict";Object.defineProperty(td,"__esModule",{value:!0});td.default=void 0;var hSe=Ft(),ws=vt(),hke=td.default=(0,hSe.declare)(e=>(e.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta"),{name:"transform-logical-assignment-operators",manipulateOptions:(t,r)=>r.plugins.push("logicalAssignment"),visitor:{AssignmentExpression(t){let{node:r,scope:n}=t,{operator:s,left:i,right:a}=r,o=s.slice(0,-1);if(!ws.types.LOGICAL_OPERATORS.includes(o))return;let l=ws.types.cloneNode(i);if(ws.types.isMemberExpression(i)){let{object:u,property:c,computed:p}=i,d=n.maybeGenerateMemoised(u);if(d&&(i.object=d,l.object=ws.types.assignmentExpression("=",ws.types.cloneNode(d),u)),p){let m=n.maybeGenerateMemoised(c);m&&(i.property=m,l.property=ws.types.assignmentExpression("=",ws.types.cloneNode(m),c))}}t.replaceWith(ws.types.logicalExpression(o,l,ws.types.assignmentExpression("=",i,a)))}}}))});var Z3=x(rd=>{"use strict";Object.defineProperty(rd,"__esModule",{value:!0});rd.default=void 0;var mSe=Ft(),xr=vt(),yke=rd.default=(0,mSe.declare)((e,{loose:t=!1})=>{var r,n;e.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");let s=(r=e.assumption("noDocumentAll"))!=null?r:t,i=(n=e.assumption("pureGetters"))!=null?n:!1;return{name:"transform-nullish-coalescing-operator",manipulateOptions:(a,o)=>o.plugins.push("nullishCoalescingOperator"),visitor:{LogicalExpression(a){let{node:o,scope:l}=a;if(o.operator!=="??")return;let u,c;if(i&&l.path.isPattern()&&xr.types.isMemberExpression(o.left)&&!o.left.computed&&xr.types.isIdentifier(o.left.object)&&xr.types.isIdentifier(o.left.property)||xr.types.isIdentifier(o.left)&&(i||l.hasBinding(o.left.name)))u=o.left,c=xr.types.cloneNode(o.left);else if(l.path.isPattern()){a.replaceWith(xr.template.statement.ast`(() => ${a.node})()`);return}else u=l.generateUidIdentifierBasedOnNode(o.left),l.push({id:xr.types.cloneNode(u)}),c=xr.types.assignmentExpression("=",u,o.left);a.replaceWith(xr.types.conditionalExpression(s?xr.types.binaryExpression("!=",c,xr.types.nullLiteral()):xr.types.logicalExpression("&&",xr.types.binaryExpression("!==",c,xr.types.nullLiteral()),xr.types.binaryExpression("!==",xr.types.cloneNode(u),l.buildUndefinedNode())),xr.types.cloneNode(u),o.right))}}}})});var rB=x(tu=>{"use strict";Object.defineProperty(tu,"__esModule",{value:!0});var ySe=Ft(),et=vt(),ta=jl();function lT(e){let t=eB(e),{node:r,parentPath:n}=t;if(n.isLogicalExpression()){let{operator:s,right:i}=n.node;if(s==="&&"||s==="||"||s==="??"&&r===i)return lT(n)}if(n.isSequenceExpression()){let{expressions:s}=n.node;return s[s.length-1]===r?lT(n):!0}return n.isConditional({test:r})||n.isUnaryExpression({operator:"!"})||n.isLoop({test:r})}function eB(e){let t=e;return e.findParent(r=>{if(!ta.isTransparentExprWrapper(r.node))return!0;t=r}),t}var gSe=e=>e[e.length-1];function nd(e){return e=ta.skipTransparentExprWrapperNodes(e),et.types.isIdentifier(e)||et.types.isSuper(e)||et.types.isMemberExpression(e)&&!e.computed&&nd(e.object)}function bSe(e){let t=e,{scope:r}=e;for(;t.isOptionalMemberExpression()||t.isOptionalCallExpression();){let{node:n}=t,s=ta.skipTransparentExprWrappers(t.isOptionalMemberExpression()?t.get("object"):t.get("callee"));if(n.optional)return!r.isStatic(s.node);t=s}}var ESe=et.template.expression("%%check%% === null || %%ref%% === void 0"),TSe=et.template.expression("%%check%% == null"),xSe=et.template.expression("%%check%% !== null && %%ref%% !== void 0"),SSe=et.template.expression("%%check%% != null");function uT(e,{pureGetters:t,noDocumentAll:r},n,s,i){let{scope:a}=e;if(a.path.isPattern()&&bSe(e)){n.replaceWith(et.template.expression.ast`(() => ${n.node})()`);return}let o=[],l=e;for(;l.isOptionalMemberExpression()||l.isOptionalCallExpression();){let{node:I}=l;I.optional&&o.push(I),l.isOptionalMemberExpression()?(l.node.type="MemberExpression",l=ta.skipTransparentExprWrappers(l.get("object"))):l.isOptionalCallExpression()&&(l.node.type="CallExpression",l=ta.skipTransparentExprWrappers(l.get("callee")))}if(o.length===0)return;let u=[],c;for(let I=o.length-1;I>=0;I--){let N=o[I],L=et.types.isCallExpression(N),W=L?N.callee:N.object,U=ta.skipTransparentExprWrapperNodes(W),H,pe;if(L&&et.types.isIdentifier(U,{name:"eval"})?(pe=H=U,N.callee=et.types.sequenceExpression([et.types.numericLiteral(0),H])):t&&L&&nd(U)?pe=H=N.callee:a.isStatic(U)?pe=H=W:((!c||L)&&(c=a.generateUidIdentifierBasedOnNode(U),a.push({id:et.types.cloneNode(c)})),H=c,pe=et.types.assignmentExpression("=",et.types.cloneNode(c),W),L?N.callee=H:N.object=H),L&&et.types.isMemberExpression(U))if(t&&nd(U))N.callee=W;else{let{object:ce}=U,qe;if(et.types.isSuper(ce))qe=et.types.thisExpression();else{let ze=a.maybeGenerateMemoised(ce);ze?(qe=ze,U.object=et.types.assignmentExpression("=",ze,ce)):qe=ce}N.arguments.unshift(et.types.cloneNode(qe)),N.callee=et.types.memberExpression(N.callee,et.types.identifier("call"))}let Ee={check:et.types.cloneNode(pe),ref:et.types.cloneNode(H)};Object.defineProperty(Ee,"ref",{enumerable:!1}),u.push(Ee)}let p=n.node;i&&(p=i(p));let d=et.types.isBooleanLiteral(s),m=d&&s.value===!1,g=!d&&et.types.isUnaryExpression(s,{operator:"void"}),f=et.types.isExpressionStatement(n.parent)&&!n.isCompletionRecord()||et.types.isSequenceExpression(n.parent)&&gSe(n.parent.expressions)!==n.node,b=m?r?SSe:xSe:r?TSe:ESe,T=m?"&&":"||",w=u.map(b).reduce((I,N)=>et.types.logicalExpression(T,I,N));n.replaceWith(d||g&&f?et.types.logicalExpression(T,w,p):et.types.conditionalExpression(w,s,p))}function tB(e,t){let{scope:r}=e,n=eB(e),{parentPath:s}=n;if(s.isUnaryExpression({operator:"delete"}))uT(e,t,s,et.types.booleanLiteral(!0));else{let i;s.isCallExpression({callee:n.node})&&e.isOptionalMemberExpression()&&(i=a=>{let o=ta.skipTransparentExprWrapperNodes(a.object),l;return(!t.pureGetters||!nd(o))&&(l=r.maybeGenerateMemoised(o),l&&(a.object=et.types.assignmentExpression("=",l,o))),et.types.callExpression(et.types.memberExpression(a,et.types.identifier("bind")),[et.types.cloneNode(l!=null?l:o)])}),uT(e,t,e,lT(n)?et.types.booleanLiteral(!1):r.buildUndefinedNode(),i)}}var vSe=ySe.declare((e,t)=>{var r,n;e.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");let{loose:s=!1}=t,i=(r=e.assumption("noDocumentAll"))!=null?r:s,a=(n=e.assumption("pureGetters"))!=null?n:s;return{name:"transform-optional-chaining",manipulateOptions:(o,l)=>l.plugins.push("optionalChaining"),visitor:{"OptionalCallExpression|OptionalMemberExpression"(o){tB(o,{noDocumentAll:i,pureGetters:a})}}}});tu.default=vSe;tu.transform=tB;tu.transformOptionalChain=uT});var sB=x(sd=>{"use strict";Object.defineProperty(sd,"__esModule",{value:!0});sd.default=void 0;var PSe=Ft(),nB=io(),Eke=sd.default=(0,PSe.declare)((e,t)=>(e.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta"),(0,nB.createClassFeaturePlugin)({name:"transform-private-methods",api:e,feature:nB.FEATURES.privateMethods,loose:t.loose,manipulateOptions(r,n){n.plugins.push("classPrivateMethods")}})))});var iB=x(id=>{"use strict";Object.defineProperty(id,"__esModule",{value:!0});id.default=void 0;var ASe=Ft(),CSe=(0,ASe.declare)(e=>(e.assertVersion(7),{name:"syntax-json-strings",manipulateOptions(t,r){r.plugins.push("jsonStrings")}}));id.default=CSe});var aB=x(ad=>{"use strict";Object.defineProperty(ad,"__esModule",{value:!0});ad.default=void 0;var DSe=Ft(),wSe=(0,DSe.declare)(e=>(e.assertVersion(7),{name:"syntax-optional-catch-binding",manipulateOptions(t,r){r.plugins.push("optionalCatchBinding")}}));ad.default=wSe});var oB=x(od=>{"use strict";Object.defineProperty(od,"__esModule",{value:!0});od.default=void 0;var ISe=Ft(),_Se=(0,ISe.declare)(e=>(e.assertVersion(7),{name:"syntax-async-generators",manipulateOptions(t,r){r.plugins.push("asyncGenerators")}}));od.default=_Se});var lB=x(ld=>{"use strict";Object.defineProperty(ld,"__esModule",{value:!0});ld.default=void 0;var NSe=Ft(),OSe=(0,NSe.declare)(e=>(e.assertVersion(7),{name:"syntax-object-rest-spread",manipulateOptions(t,r){r.plugins.push("objectRestSpread")}}));ld.default=OSe});var uB=x(ud=>{"use strict";Object.defineProperty(ud,"__esModule",{value:!0});ud.default=void 0;var BSe=Ft(),Is=vt(),Ake=ud.default=(0,BSe.declare)(e=>(e.assertVersion(7),{name:"transform-export-namespace-from",manipulateOptions:(t,r)=>r.plugins.push("exportNamespaceFrom"),visitor:{ExportNamedDeclaration(t){var r;let{node:n,scope:s}=t,{specifiers:i}=n,a=Is.types.isExportDefaultSpecifier(i[0])?1:0;if(!Is.types.isExportNamespaceSpecifier(i[a]))return;let o=[];a===1&&o.push(Is.types.exportNamedDeclaration(null,[i.shift()],n.source));let l=i.shift(),{exported:u}=l,c=s.generateUidIdentifier((r=u.name)!=null?r:u.value);o.push(Is.types.importDeclaration([Is.types.importNamespaceSpecifier(c)],Is.types.cloneNode(n.source)),Is.types.exportNamedDeclaration(null,[Is.types.exportSpecifier(Is.types.cloneNode(c),u)])),n.specifiers.length>=1&&o.push(n);let[p]=t.replaceWithMultiple(o);t.scope.registerDeclaration(p)}}}))});var fB=x(pT=>{"use strict";Object.defineProperty(pT,"__esModule",{value:!0});pT.default=VSe;var kSe=vE(),FSe=Ft(),ae=vt(),cT=og(),LSe=hf(),ru={importSource:"react",runtime:"automatic",pragma:"React.createElement",pragmaFrag:"React.Fragment"},jSe=/^\s*(?:\*\s*)?@jsxImportSource\s+(\S+)\s*$/m,MSe=/^\s*(?:\*\s*)?@jsxRuntime\s+(\S+)\s*$/m,RSe=/^\s*(?:\*\s*)?@jsx\s+(\S+)\s*$/m,qSe=/^\s*(?:\*\s*)?@jsxFrag\s+(\S+)\s*$/m,_s=(e,t)=>e.get(`@babel/plugin-react-jsx/${t}`),li=(e,t,r)=>e.set(`@babel/plugin-react-jsx/${t}`,r);function USe(e){return e.properties.some(t=>ae.types.isObjectProperty(t,{computed:!1,shorthand:!1})&&(ae.types.isIdentifier(t.key,{name:"__proto__"})||ae.types.isStringLiteral(t.key,{value:"__proto__"})))}function VSe({name:e,development:t}){return(0,FSe.declare)((s,i)=>{let{pure:a,throwIfNamespace:o=!0,filter:l,runtime:u=t?"automatic":"classic",importSource:c=ru.importSource,pragma:p=ru.pragma,pragmaFrag:d=ru.pragmaFrag}=i;{var{useSpread:m=!1,useBuiltIns:g=!1}=i;if(u==="classic"){if(typeof m!="boolean")throw new Error("transform-react-jsx currently only accepts a boolean option for useSpread (defaults to false)");if(typeof g!="boolean")throw new Error("transform-react-jsx currently only accepts a boolean option for useBuiltIns (defaults to false)");if(m&&g)throw new Error("transform-react-jsx currently only accepts useBuiltIns or useSpread but not both")}}let f={JSXOpeningElement(J,se){let V=[];T(J.scope)&&V.push(ae.types.jsxAttribute(ae.types.jsxIdentifier("__self"),ae.types.jsxExpressionContainer(ae.types.thisExpression()))),V.push(ae.types.jsxAttribute(ae.types.jsxIdentifier("__source"),ae.types.jsxExpressionContainer($Se(J,se)))),J.pushContainer("attributes",V)}};return{name:e,inherits:kSe.default,visitor:{JSXNamespacedName(J){if(o)throw J.buildCodeFrameError("Namespace tags are not supported by default. React's JSX doesn't support namespace tags. You can set `throwIfNamespace: false` to bypass this warning.")},JSXSpreadChild(J){throw J.buildCodeFrameError("Spread children are not supported in React.")},Program:{enter(J,se){let{file:V}=se,G=u,j=c,re=p,de=d,ye=!!i.importSource,Te=!!i.pragma,he=!!i.pragmaFrag;if(V.ast.comments)for(let De of V.ast.comments){let we=jSe.exec(De.value);we&&(j=we[1],ye=!0);let Ve=MSe.exec(De.value);Ve&&(G=Ve[1]);let pt=RSe.exec(De.value);pt&&(re=pt[1],Te=!0);let ut=qSe.exec(De.value);ut&&(de=ut[1],he=!0)}if(li(se,"runtime",G),G==="classic"){if(ye)throw J.buildCodeFrameError("importSource cannot be set when runtime is classic.");let De=cB(re),we=cB(de);li(se,"id/createElement",()=>ae.types.cloneNode(De)),li(se,"id/fragment",()=>ae.types.cloneNode(we)),li(se,"defaultPure",re===ru.pragma)}else if(G==="automatic"){if(Te||he)throw J.buildCodeFrameError("pragma and pragmaFrag cannot be set when runtime is automatic.");let De=(we,Ve)=>li(se,we,n(se,J,Ve,j));De("id/jsx",t?"jsxDEV":"jsx"),De("id/jsxs",t?"jsxDEV":"jsxs"),De("id/createElement","createElement"),De("id/fragment","Fragment"),li(se,"defaultPure",j===ru.importSource)}else throw J.buildCodeFrameError('Runtime must be either "classic" or "automatic".');t&&J.traverse(f,se)}},JSXFragment:{exit(J,se){let V;_s(se,"runtime")==="classic"?V=ce(J,se):V=Ee(J,se),J.replaceWith(ae.types.inherits(V,J.node))}},JSXElement:{exit(J,se){let V;_s(se,"runtime")==="classic"||I(J)?V=qe(J,se):V=H(J,se),J.replaceWith(ae.types.inherits(V,J.node))}},JSXAttribute(J){ae.types.isJSXElement(J.node.value)&&(J.node.value=ae.types.jsxExpressionContainer(J.node.value))}}};function b(J){return J.node.superClass!==null}function T(J){do{let{path:se}=J;if(se.isFunctionParent()&&!se.isArrowFunctionExpression())return!se.isMethod()||se.node.kind!=="constructor"?!0:!b(se.parentPath.parentPath);if(se.isTSModuleBlock())return!1}while(J=J.parent);return!0}function w(J,se,V){let G=ae.types.callExpression(_s(J,`id/${se}`)(),V);return(a!=null?a:_s(J,"defaultPure"))&&(0,LSe.default)(G),G}function I(J){let V=J.get("openingElement").node.attributes,G=!1;for(let j=0;j<V.length;j++){let re=V[j];if(G&&ae.types.isJSXAttribute(re)&&re.name.name==="key")return!0;ae.types.isJSXSpreadAttribute(re)&&(G=!0)}return!1}function N(J,se){return ae.types.isJSXIdentifier(J)?J.name==="this"&&ae.types.isReferenced(J,se)?ae.types.thisExpression():ae.types.isValidIdentifier(J.name,!1)?(J.type="Identifier",J):ae.types.stringLiteral(J.name):ae.types.isJSXMemberExpression(J)?ae.types.memberExpression(N(J.object,J),N(J.property,J)):ae.types.isJSXNamespacedName(J)?ae.types.stringLiteral(`${J.namespace.name}:${J.name.name}`):J}function L(J){return ae.types.isJSXExpressionContainer(J)?J.expression:J}function W(J,se){if(ae.types.isJSXSpreadAttribute(se.node)){let j=se.node.argument;return ae.types.isObjectExpression(j)&&!USe(j)?J.push(...j.properties):J.push(ae.types.spreadElement(j)),J}let V=L(se.node.name.name!=="key"?se.node.value||ae.types.booleanLiteral(!0):se.node.value);if(se.node.name.name==="key"&&V===null)throw se.buildCodeFrameError('Please provide an explicit key value. Using "key" as a shorthand for "key={true}" is not allowed.');if(ae.types.isStringLiteral(V)&&!ae.types.isJSXExpressionContainer(se.node.value)){var G;V.value=V.value.replace(/\n\s+/g," "),(G=V.extra)==null||delete G.raw}return ae.types.isJSXNamespacedName(se.node.name)?se.node.name=ae.types.stringLiteral(se.node.name.namespace.name+":"+se.node.name.name.name):ae.types.isValidIdentifier(se.node.name.name,!1)?se.node.name.type="Identifier":se.node.name=ae.types.stringLiteral(se.node.name.name),J.push(ae.types.inherits(ae.types.objectProperty(se.node.name,V),se.node)),J}function U(J){let se;if(J.length===1)se=J[0];else if(J.length>1)se=ae.types.arrayExpression(J);else return;return ae.types.objectProperty(ae.types.identifier("children"),se)}function H(J,se){let V=J.get("openingElement"),G=[ze(V)],j=[],re=Object.create(null);for(let he of V.get("attributes"))if(he.isJSXAttribute()&&ae.types.isJSXIdentifier(he.node.name)){let{name:De}=he.node.name;switch(De){case"__source":case"__self":if(re[De])throw pB(J,De);case"key":{let we=L(he.node.value);if(we===null)throw he.buildCodeFrameError('Please provide an explicit key value. Using "key" as a shorthand for "key={true}" is not allowed.');re[De]=we;break}default:j.push(he)}}else j.push(he);let de=ae.types.react.buildChildren(J.node),ye;if(j.length||de.length?ye=pe(j,de):ye=ae.types.objectExpression([]),G.push(ye),t){var Te;G.push((Te=re.key)!=null?Te:J.scope.buildUndefinedNode(),ae.types.booleanLiteral(de.length>1)),re.__source?(G.push(re.__source),re.__self&&G.push(re.__self)):re.__self&&G.push(J.scope.buildUndefinedNode(),re.__self)}else re.key!==void 0&&G.push(re.key);return w(se,de.length>1?"jsxs":"jsx",G)}function pe(J,se){let V=J.reduce(W,[]);return(se==null?void 0:se.length)>0&&V.push(U(se)),ae.types.objectExpression(V)}function Ee(J,se){let V=[_s(se,"id/fragment")()],G=ae.types.react.buildChildren(J.node);return V.push(ae.types.objectExpression(G.length>0?[U(G)]:[])),t&&V.push(J.scope.buildUndefinedNode(),ae.types.booleanLiteral(G.length>1)),w(se,G.length>1?"jsxs":"jsx",V)}function ce(J,se){if(!(l&&!l(J.node,se)))return w(se,"createElement",[_s(se,"id/fragment")(),ae.types.nullLiteral(),...ae.types.react.buildChildren(J.node)])}function qe(J,se){let V=J.get("openingElement");return w(se,"createElement",[ze(V),Ot(se,J,V.get("attributes")),...ae.types.react.buildChildren(J.node)])}function ze(J){let se=N(J.node.name,J.node),V;return ae.types.isIdentifier(se)?V=se.name:ae.types.isStringLiteral(se)&&(V=se.value),ae.types.react.isCompatTag(V)?ae.types.stringLiteral(V):se}function Ot(J,se,V){let G=_s(J,"runtime");if(G!=="automatic"){let de=[],ye=V.reduce(W,[]);if(m)ye.length&&de.push(ae.types.objectExpression(ye));else{let he=0;ye.forEach((De,we)=>{ae.types.isSpreadElement(De)&&(we>he&&de.push(ae.types.objectExpression(ye.slice(he,we))),de.push(De.argument),he=we+1)}),ye.length>he&&de.push(ae.types.objectExpression(ye.slice(he)))}if(!de.length)return ae.types.nullLiteral();if(de.length===1&&!(ae.types.isSpreadElement(ye[0])&&ae.types.isObjectExpression(ye[0].argument)))return de[0];ae.types.isObjectExpression(de[0])||de.unshift(ae.types.objectExpression([]));let Te=g?ae.types.memberExpression(ae.types.identifier("Object"),ae.types.identifier("assign")):J.addHelper("extends");return ae.types.callExpression(Te,de)}let j=[],re=Object.create(null);for(let de of V){let{node:ye}=de,Te=ae.types.isJSXAttribute(ye)&&ae.types.isJSXIdentifier(ye.name)&&ye.name.name;if(G==="automatic"&&(Te==="__source"||Te==="__self")){if(re[Te])throw pB(se,Te);re[Te]=!0}W(j,de)}return j.length===1&&ae.types.isSpreadElement(j[0])&&!ae.types.isObjectExpression(j[0].argument)?j[0].argument:j.length>0?ae.types.objectExpression(j):ae.types.nullLiteral()}});function r(s,i){switch(i){case"Fragment":return`${s}/${t?"jsx-dev-runtime":"jsx-runtime"}`;case"jsxDEV":return`${s}/jsx-dev-runtime`;case"jsx":case"jsxs":return`${s}/jsx-runtime`;case"createElement":return s}}function n(s,i,a,o){return()=>{let l=r(o,a);if((0,cT.isModule)(i)){let u=_s(s,`imports/${a}`);return u?ae.types.cloneNode(u):(u=(0,cT.addNamed)(i,a,l,{importedInterop:"uncompiled",importPosition:"after"}),li(s,`imports/${a}`,u),u)}else{let u=_s(s,`requires/${l}`);return u?u=ae.types.cloneNode(u):(u=(0,cT.addNamespace)(i,l,{importedInterop:"uncompiled"}),li(s,`requires/${l}`,u)),ae.types.memberExpression(u,ae.types.identifier(a))}}}}function cB(e){return e.split(".").map(t=>ae.types.identifier(t)).reduce((t,r)=>ae.types.memberExpression(t,r))}function $Se(e,t){let r=e.node.loc;if(!r)return e.scope.buildUndefinedNode();if(!t.fileNameIdentifier){let{filename:n=""}=t,s=e.scope.generateUidIdentifier("_jsxFileName");e.scope.getProgramParent().push({id:s,init:ae.types.stringLiteral(n)}),t.fileNameIdentifier=s}return WSe(ae.types.cloneNode(t.fileNameIdentifier),r.start.line,r.start.column)}function WSe(e,t,r){let n=t!=null?ae.types.numericLiteral(t):ae.types.nullLiteral(),s=r!=null?ae.types.numericLiteral(r+1):ae.types.nullLiteral();return ae.template.expression.ast`{
node_modules/rollup/dist/es/shared/node-entry.js:10:import { EMPTY_OBJECT, ExportDefaultDeclaration as ExportDefaultDeclaration$1, CallExpression as CallExpression$1, EMPTY_ARRAY, LOGLEVEL_WARN, logUnusedExternalImports, ANNOTATION_KEY, INVALID_ANNOTATION_KEY, ExpressionStatement as ExpressionStatement$1, AwaitExpression as AwaitExpression$1, MemberExpression as MemberExpression$1, Identifier as Identifier$1, FunctionExpression as FunctionExpression$1, ArrowFunctionExpression as ArrowFunctionExpression$1, ObjectExpression as ObjectExpression$1, Property as Property$1, Program as Program$1, logIllegalImportReassignment, BLANK, logRedeclarationError, StaticBlock as StaticBlock$1, CatchClause as CatchClause$1, logDuplicateArgumentNameError, logModuleLevelDirective, ReturnStatement as ReturnStatement$1, VariableDeclarator as VariableDeclarator$1, logMissingExport, normalize, getImportPath, logMissingNodeBuiltins, logReservedNamespace, error, logIllegalIdentifierAsName, logMissingNameOptionForIifeExport, logMissingNameOptionForUmdExport, RestElement as RestElement$1, logConstVariableReassignError, EMPTY_SET, logCannotCallNamespace, logEval, BlockStatement as BlockStatement$1, getRollupError, logModuleParseError, logParseError, LOGLEVEL_INFO, logFirstSideEffect, locate, logInvalidAnnotation, logThisIsUndefined, getAstBuffer, convertAnnotations, FIXED_STRINGS, convertNode as convertNode$1, logImportAttributeIsInvalid, logImportOptionsAreInvalid, logMissingEntryExport, logSyntheticNamedExportsNeedNamespaceExport, logDuplicateExportError, logInvalidSourcemapForError, augmentCodeLocation, logInconsistentImportAttributes, logMissingJsxExport, logNamespaceConflict, logAmbiguousExternalNamespaces, logShimmedExport, parseAst, TemplateLiteral as TemplateLiteral$1, Literal as Literal$1, logCircularReexport, logInvalidFormatForTopLevelAwait, logAddonNotGenerated, logIncompatibleExportOptionValue, logMixedExport, logFailedValidation, isPathFragment, logCyclicCrossChunkReexport, getAliasName, logUnexpectedNamedImport, isAbsolute as isAbsolute$1, relative as relative$1, logUnexpectedNamespaceReexport, logEmptyChunk, logMissingGlobalName, logOptimizeChunkStatus, logSourcemapBroken, logConflictingSourcemapSources, logChunkInvalid, logInvalidOption, URL_OUTPUT_FORMAT, URL_OUTPUT_DIR, URL_OUTPUT_SOURCEMAPFILE, URL_OUTPUT_AMD_ID, logCannotAssignModuleToChunk, logCircularChunk, logUnknownOption, printQuotedStringList, LOGLEVEL_ERROR, logLevelPriority, LOGLEVEL_DEBUG, logAnonymousPluginCache, logDuplicatePluginName, logInvalidSetAssetSourceCall, logPluginError, logNoTransformMapOrAstWithoutCode, warnDeprecation, URL_TRANSFORM, relativeId, logBadLoader, logInternalIdCannotBeExternal, isRelative, logUnresolvedImport, logUnresolvedImportTreatedAsExternal, logExternalSyntheticExports, logUnresolvedEntry, logUnresolvedImplicitDependant, logExternalModulesCannotBeIncludedInManualChunks, logEntryCannotBeExternal, logImplicitDependantCannotBeExternal, logExternalModulesCannotBeTransformedToModules, URL_LOAD, logNoAssetSourceSet, logFileReferenceIdNotFoundForFilename, logAssetReferenceIdNotFoundForSetSource, logAssetSourceAlreadySet, logInvalidRollupPhaseForChunkEmission, logChunkNotGeneratedForFileName, logAssetNotFinalisedForFileName, logFileNameConflict, URL_GENERATEBUNDLE, logInvalidLogPosition, logInputHookInOutputPlugin, logInvalidAddonPluginHook, logInvalidFunctionPluginHook, logImplicitDependantIsNotIncluded, logCircularDependency, augmentLogMessage, URL_JSX, URL_TREESHAKE, URL_TREESHAKE_MODULESIDEEFFECTS, URL_OUTPUT_INLINEDYNAMICIMPORTS, URL_PRESERVEENTRYSIGNATURES, URL_OUTPUT_GENERATEDCODE, isValidUrl, addTrailingSlashIfMissed, URL_OUTPUT_SOURCEMAPBASEURL, URL_OUTPUT_MANUALCHUNKS, logInvalidExportOptionValue, URL_OUTPUT_AMD_BASEPATH, URL_OUTPUT_INTEROP, URL_OUTPUT_EXTERNALIMPORTATTRIBUTES, logAlreadyClosed, logMissingFileOrDirOption, logCannotEmitFromOptionsHook, URL_WATCH } from './parseAst.js';
node_modules/rollup/dist/es/shared/node-entry.js:2676:        this.options.onLog(LOGLEVEL_WARN, logUnusedExternalImports(this.id, unused, importersArray));
node_modules/rollup/dist/es/shared/node-entry.js:6510:            this.scope.context.log(LOGLEVEL_WARN, 
node_modules/rollup/dist/es/shared/node-entry.js:7688:                this.scope.context.log(LOGLEVEL_WARN, logIllegalImportReassignment(this.object.name, this.scope.context.module.id), this.start);
node_modules/rollup/dist/es/shared/node-entry.js:7724:            astContext.log(LOGLEVEL_WARN, logMissingExport(exportName, astContext.module.id, fileName, !!options?.missingButExportExists), path[0].pos);
node_modules/rollup/dist/es/shared/node-entry.js:8568:    log(LOGLEVEL_WARN, logMissingNodeBuiltins(externalBuiltins));
node_modules/rollup/dist/es/shared/node-entry.js:8765:        log(LOGLEVEL_WARN, logReservedNamespace(parts[0]));
node_modules/rollup/dist/es/shared/node-entry.js:8787:        log(LOGLEVEL_WARN, logReservedNamespace(parts[0]));
node_modules/rollup/dist/es/shared/node-entry.js:8833:        log(LOGLEVEL_WARN, logMissingNameOptionForIifeExport());
node_modules/rollup/dist/es/shared/node-entry.js:11719:                this.scope.context.log(LOGLEVEL_WARN, logConstVariableReassignError(), this.left.start);
node_modules/rollup/dist/es/shared/node-entry.js:12266:                this.scope.context.log(LOGLEVEL_WARN, logCannotCallNamespace(this.callee.name), this.start);
node_modules/rollup/dist/es/shared/node-entry.js:12269:                this.scope.context.log(LOGLEVEL_WARN, logEval(this.scope.context.module.id), this.start);
node_modules/rollup/dist/es/shared/node-entry.js:14495:                    log(LOGLEVEL_INFO, logFirstSideEffect(code, module.id, locate(code, node.start, { offsetLine: 1 })), node.start);
node_modules/rollup/dist/es/shared/node-entry.js:14516:                    this.scope.context.log(LOGLEVEL_WARN, logInvalidAnnotation(this.scope.context.code.slice(start, end), this.scope.context.module.id, type), start);
node_modules/rollup/dist/es/shared/node-entry.js:14963:                this.scope.context.log(LOGLEVEL_WARN, logCannotCallNamespace(name), this.start);
node_modules/rollup/dist/es/shared/node-entry.js:15126:            this.scope.context.log(LOGLEVEL_WARN, logThisIsUndefined(), this.start);
node_modules/rollup/dist/es/shared/node-entry.js:16680:            context.module.log(LOGLEVEL_WARN, logImportAttributeIsInvalid(context.module.id), start);
node_modules/rollup/dist/es/shared/node-entry.js:16689:        context.module.log(LOGLEVEL_WARN, logImportOptionsAreInvalid(context.module.id), start);
node_modules/rollup/dist/es/shared/node-entry.js:16699:        context.module.log(LOGLEVEL_WARN, logImportAttributeIsInvalid(context.module.id), property.start);
node_modules/rollup/dist/es/shared/node-entry.js:17604:                this.options.onLog(LOGLEVEL_WARN, logInvalidSourcemapForError(error_, this.id, column, line, pos));
node_modules/rollup/dist/es/shared/node-entry.js:17645:                this.log(LOGLEVEL_WARN, logInconsistentImportAttributes(existingAttributes, parsedAttributes, source, this.id), declaration.start);
node_modules/rollup/dist/es/shared/node-entry.js:17692:            this.options.onLog(LOGLEVEL_WARN, logNamespaceConflict(name, this.id, foundDeclarationList.map(([, module]) => module.id)));
node_modules/rollup/dist/es/shared/node-entry.js:17700:                this.options.onLog(LOGLEVEL_WARN, logAmbiguousExternalNamespaces(name, this.id, usedDeclaration.module.id, foundDeclarationList.map(declaration => declaration.module.id)));
node_modules/rollup/dist/es/shared/node-entry.js:17772:        this.options.onLog(LOGLEVEL_WARN, logShimmedExport(this.id, name));
node_modules/rollup/dist/es/shared/node-entry.js:18008:                log(LOGLEVEL_WARN, logMixedExport(facadeModuleId, name));
node_modules/rollup/dist/es/shared/node-entry.js:18220:        log(LOGLEVEL_WARN, logMissingGlobalName(chunk.id, chunk.variableName));
node_modules/rollup/dist/es/shared/node-entry.js:18710:                        this.inputOptions.onLog(LOGLEVEL_WARN, logCyclicCrossChunkReexport(
node_modules/rollup/dist/es/shared/node-entry.js:19012:                    this.inputOptions.onLog(LOGLEVEL_WARN, logUnexpectedNamespaceReexport(id));
node_modules/rollup/dist/es/shared/node-entry.js:19183:            onLog(LOGLEVEL_WARN, logEmptyChunk(this.getChunkName()));
node_modules/rollup/dist/es/shared/node-entry.js:20270:        log(LOGLEVEL_WARN, logSourcemapBroken(map.plugin));
node_modules/rollup/dist/es/shared/node-entry.js:20672:                        this.inputOptions.onLog(LOGLEVEL_WARN, logChunkInvalid(file, error_));
node_modules/rollup/dist/es/shared/node-entry.js:20729:                    this.inputOptions.onLog(LOGLEVEL_WARN, logCircularChunk(path, isManualChunkConflict));
node_modules/rollup/dist/es/shared/node-entry.js:20759:        log(LOGLEVEL_WARN, logInvalidOption('output.amd.id', URL_OUTPUT_AMD_ID, 'this option is only properly supported for single-file builds. Use "output.amd.autoId" and "output.amd.basePath" instead'));
node_modules/rollup/dist/es/shared/node-entry.js:20959:            if (level === LOGLEVEL_ERROR) {
node_modules/rollup/dist/es/shared/node-entry.js:20971:        if (level === LOGLEVEL_WARN) {
node_modules/rollup/dist/es/shared/node-entry.js:20972:            onwarn(addLogToString(log), warning => printLog(LOGLEVEL_WARN, normalizeLog(warning)));
node_modules/rollup/dist/es/shared/node-entry.js:20993:        case LOGLEVEL_WARN: {
node_modules/rollup/dist/es/shared/node-entry.js:20996:        case LOGLEVEL_DEBUG: {
node_modules/rollup/dist/es/shared/node-entry.js:21008:        log(LOGLEVEL_WARN, logUnknownOption(optionType, unknownOptions, [...validOptionSet].sort()));
node_modules/rollup/dist/es/shared/node-entry.js:21213:                    options.onLog(LOGLEVEL_WARN, logNoTransformMapOrAstWithoutCode(plugin.name));
node_modules/rollup/dist/es/shared/node-entry.js:21520:                this.options.onLog(LOGLEVEL_WARN, logInconsistentImportAttributes(existingModule.info.attributes, attributes, id, importer));
node_modules/rollup/dist/es/shared/node-entry.js:21574:                this.options.onLog(LOGLEVEL_WARN, logInconsistentImportAttributes(externalModule.info.attributes, attributes, source, importer));
node_modules/rollup/dist/es/shared/node-entry.js:21689:            this.options.onLog(LOGLEVEL_WARN, logUnresolvedImportTreatedAsExternal(source, importer));
node_modules/rollup/dist/es/shared/node-entry.js:21701:            this.options.onLog(LOGLEVEL_WARN, logExternalSyntheticExports(source, importer));
node_modules/rollup/dist/es/shared/node-entry.js:21743:                    this.options.onLog(LOGLEVEL_WARN, logInconsistentImportAttributes(existingResolution.attributes, attributes, specifier, importer));
node_modules/rollup/dist/es/shared/node-entry.js:21809:        log(LOGLEVEL_WARN, logFileNameConflict(fileName));
node_modules/rollup/dist/es/shared/node-entry.js:22182:            logger(LOGLEVEL_WARN, logInvalidLogPosition(pluginName));
node_modules/rollup/dist/es/shared/node-entry.js:22223:        debug: getLogHandler(LOGLEVEL_DEBUG, 'PLUGIN_LOG', onLog, plugin.name, logLevel),
node_modules/rollup/dist/es/shared/node-entry.js:22233:        info: getLogHandler(LOGLEVEL_INFO, 'PLUGIN_LOG', onLog, plugin.name, logLevel),
node_modules/rollup/dist/es/shared/node-entry.js:22247:        warn: getLogHandler(LOGLEVEL_WARN, 'PLUGIN_WARNING', onLog, plugin.name, logLevel)
node_modules/rollup/dist/es/shared/node-entry.js:22409:                        options.onLog(LOGLEVEL_WARN, logInputHookInOutputPlugin(plugin.name, hook));
node_modules/rollup/dist/es/shared/node-entry.js:22839:            this.options.onLog(LOGLEVEL_WARN, logCircularDependency(cyclePath));
node_modules/rollup/dist/es/shared/node-entry.js:22853:                        module.log(LOGLEVEL_WARN, logMissingExport(importDescription.name, module.id, importDescription.module.id, !!options?.missingButExportExists), importDescription.start);
node_modules/rollup/dist/es/shared/node-entry.js:22936:                debug: getLogHandler(LOGLEVEL_DEBUG),
node_modules/rollup/dist/es/shared/node-entry.js:22938:                info: getLogHandler(LOGLEVEL_INFO),
node_modules/rollup/dist/es/shared/node-entry.js:22940:                warn: getLogHandler(LOGLEVEL_WARN)
node_modules/rollup/dist/es/shared/node-entry.js:22960:    const logLevel = config.logLevel || LOGLEVEL_INFO;
node_modules/rollup/dist/es/shared/node-entry.js:23506:    const logLevel = inputOptions.logLevel || LOGLEVEL_INFO;
node_modules/rollup/dist/es/shared/node-entry.js:23512:            debug: getLogHandler(LOGLEVEL_DEBUG, 'PLUGIN_LOG', logger, name, logLevel),
node_modules/rollup/dist/es/shared/node-entry.js:23514:            info: getLogHandler(LOGLEVEL_INFO, 'PLUGIN_LOG', logger, name, logLevel),
node_modules/rollup/dist/es/shared/node-entry.js:23516:            warn: getLogHandler(LOGLEVEL_WARN, 'PLUGIN_WARNING', logger, name, logLevel)
node_modules/rollup/dist/es/shared/node-entry.js:23759:    const logLevel = config.logLevel || LOGLEVEL_INFO;
node_modules/rollup/dist/es/shared/parseAst.js:253:const LOGLEVEL_SILENT = 'silent';
node_modules/rollup/dist/es/shared/parseAst.js:254:const LOGLEVEL_ERROR = 'error';
node_modules/rollup/dist/es/shared/parseAst.js:255:const LOGLEVEL_WARN = 'warn';
node_modules/rollup/dist/es/shared/parseAst.js:256:const LOGLEVEL_INFO = 'info';
node_modules/rollup/dist/es/shared/parseAst.js:257:const LOGLEVEL_DEBUG = 'debug';
node_modules/rollup/dist/es/shared/parseAst.js:259:    [LOGLEVEL_DEBUG]: 0,
node_modules/rollup/dist/es/shared/parseAst.js:260:    [LOGLEVEL_INFO]: 1,
node_modules/rollup/dist/es/shared/parseAst.js:261:    [LOGLEVEL_SILENT]: 3,
node_modules/rollup/dist/es/shared/parseAst.js:262:    [LOGLEVEL_WARN]: 2
node_modules/rollup/dist/es/shared/parseAst.js:450:const ADDON_ERROR = 'ADDON_ERROR', ALREADY_CLOSED = 'ALREADY_CLOSED', AMBIGUOUS_EXTERNAL_NAMESPACES = 'AMBIGUOUS_EXTERNAL_NAMESPACES', ANONYMOUS_PLUGIN_CACHE = 'ANONYMOUS_PLUGIN_CACHE', ASSET_NOT_FINALISED = 'ASSET_NOT_FINALISED', ASSET_NOT_FOUND = 'ASSET_NOT_FOUND', ASSET_SOURCE_ALREADY_SET = 'ASSET_SOURCE_ALREADY_SET', ASSET_SOURCE_MISSING = 'ASSET_SOURCE_MISSING', BAD_LOADER = 'BAD_LOADER', CANNOT_CALL_NAMESPACE = 'CANNOT_CALL_NAMESPACE', CANNOT_EMIT_FROM_OPTIONS_HOOK = 'CANNOT_EMIT_FROM_OPTIONS_HOOK', CHUNK_NOT_GENERATED = 'CHUNK_NOT_GENERATED', CHUNK_INVALID = 'CHUNK_INVALID', CIRCULAR_CHUNK = 'CIRCULAR_CHUNK', CIRCULAR_DEPENDENCY = 'CIRCULAR_DEPENDENCY', CIRCULAR_REEXPORT = 'CIRCULAR_REEXPORT', CONST_REASSIGN = 'CONST_REASSIGN', CYCLIC_CROSS_CHUNK_REEXPORT = 'CYCLIC_CROSS_CHUNK_REEXPORT', DEPRECATED_FEATURE = 'DEPRECATED_FEATURE', DUPLICATE_ARGUMENT_NAME = 'DUPLICATE_ARGUMENT_NAME', DUPLICATE_EXPORT = 'DUPLICATE_EXPORT', DUPLICATE_PLUGIN_NAME = 'DUPLICATE_PLUGIN_NAME', EMPTY_BUNDLE = 'EMPTY_BUNDLE', EVAL = 'EVAL', EXTERNAL_MODULES_CANNOT_BE_INCLUDED_IN_MANUAL_CHUNKS = 'EXTERNAL_MODULES_CANNOT_BE_INCLUDED_IN_MANUAL_CHUNKS', EXTERNAL_MODULES_CANNOT_BE_TRANSFORMED_TO_MODULES = 'EXTERNAL_MODULES_CANNOT_BE_TRANSFORMED_TO_MODULES', EXTERNAL_SYNTHETIC_EXPORTS = 'EXTERNAL_SYNTHETIC_EXPORTS', FILE_NAME_CONFLICT = 'FILE_NAME_CONFLICT', FILE_NOT_FOUND = 'FILE_NOT_FOUND', FIRST_SIDE_EFFECT = 'FIRST_SIDE_EFFECT', ILLEGAL_IDENTIFIER_AS_NAME = 'ILLEGAL_IDENTIFIER_AS_NAME', ILLEGAL_REASSIGNMENT = 'ILLEGAL_REASSIGNMENT', INCONSISTENT_IMPORT_ATTRIBUTES = 'INCONSISTENT_IMPORT_ATTRIBUTES', INVALID_ANNOTATION = 'INVALID_ANNOTATION', INPUT_HOOK_IN_OUTPUT_PLUGIN = 'INPUT_HOOK_IN_OUTPUT_PLUGIN', INVALID_CHUNK = 'INVALID_CHUNK', INVALID_EXPORT_OPTION = 'INVALID_EXPORT_OPTION', INVALID_EXTERNAL_ID = 'INVALID_EXTERNAL_ID', INVALID_IMPORT_ATTRIBUTE = 'INVALID_IMPORT_ATTRIBUTE', INVALID_LOG_POSITION = 'INVALID_LOG_POSITION', INVALID_OPTION = 'INVALID_OPTION', INVALID_PLUGIN_HOOK = 'INVALID_PLUGIN_HOOK', INVALID_ROLLUP_PHASE = 'INVALID_ROLLUP_PHASE', INVALID_SETASSETSOURCE = 'INVALID_SETASSETSOURCE', INVALID_TLA_FORMAT = 'INVALID_TLA_FORMAT', MISSING_EXPORT = 'MISSING_EXPORT', MISSING_GLOBAL_NAME = 'MISSING_GLOBAL_NAME', MISSING_IMPLICIT_DEPENDANT = 'MISSING_IMPLICIT_DEPENDANT', MISSING_JSX_EXPORT = 'MISSING_JSX_EXPORT', MISSING_NAME_OPTION_FOR_IIFE_EXPORT = 'MISSING_NAME_OPTION_FOR_IIFE_EXPORT', MISSING_NODE_BUILTINS = 'MISSING_NODE_BUILTINS', MISSING_OPTION = 'MISSING_OPTION', MIXED_EXPORTS = 'MIXED_EXPORTS', MODULE_LEVEL_DIRECTIVE = 'MODULE_LEVEL_DIRECTIVE', NAMESPACE_CONFLICT = 'NAMESPACE_CONFLICT', NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE = 'NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE', OPTIMIZE_CHUNK_STATUS = 'OPTIMIZE_CHUNK_STATUS', PARSE_ERROR = 'PARSE_ERROR', PLUGIN_ERROR = 'PLUGIN_ERROR', REDECLARATION_ERROR = 'REDECLARATION_ERROR', RESERVED_NAMESPACE = 'RESERVED_NAMESPACE', SHIMMED_EXPORT = 'SHIMMED_EXPORT', SOURCEMAP_BROKEN = 'SOURCEMAP_BROKEN', SOURCEMAP_ERROR = 'SOURCEMAP_ERROR', SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT = 'SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT', THIS_IS_UNDEFINED = 'THIS_IS_UNDEFINED', UNEXPECTED_NAMED_IMPORT = 'UNEXPECTED_NAMED_IMPORT', UNKNOWN_OPTION = 'UNKNOWN_OPTION', UNRESOLVED_ENTRY = 'UNRESOLVED_ENTRY', UNRESOLVED_IMPORT = 'UNRESOLVED_IMPORT', UNUSED_EXTERNAL_IMPORT = 'UNUSED_EXTERNAL_IMPORT', VALIDATION_ERROR = 'VALIDATION_ERROR';
node_modules/rollup/dist/es/shared/parseAst.js:722:        code: INVALID_LOG_POSITION,
node_modules/rollup/dist/es/shared/parseAst.js:1095:        log(LOGLEVEL_WARN, warning);
node_modules/rollup/dist/es/shared/parseAst.js:2096:export { ANNOTATION_KEY, ArrowFunctionExpression, AwaitExpression, BLANK, BlockStatement, CallExpression, CatchClause, EMPTY_ARRAY, EMPTY_OBJECT, EMPTY_SET, ExportDefaultDeclaration, ExpressionStatement, FIXED_STRINGS, FunctionExpression, INVALID_ANNOTATION_KEY, Identifier, LOGLEVEL_DEBUG, LOGLEVEL_ERROR, LOGLEVEL_INFO, LOGLEVEL_WARN, Literal, MemberExpression, ObjectExpression, Program, Property, RestElement, ReturnStatement, StaticBlock, TemplateLiteral, URL_GENERATEBUNDLE, URL_JSX, URL_LOAD, URL_OUTPUT_AMD_BASEPATH, URL_OUTPUT_AMD_ID, URL_OUTPUT_DIR, URL_OUTPUT_EXTERNALIMPORTATTRIBUTES, URL_OUTPUT_FORMAT, URL_OUTPUT_GENERATEDCODE, URL_OUTPUT_INLINEDYNAMICIMPORTS, URL_OUTPUT_INTEROP, URL_OUTPUT_MANUALCHUNKS, URL_OUTPUT_SOURCEMAPBASEURL, URL_OUTPUT_SOURCEMAPFILE, URL_PRESERVEENTRYSIGNATURES, URL_TRANSFORM, URL_TREESHAKE, URL_TREESHAKE_MODULESIDEEFFECTS, URL_WATCH, VariableDeclarator, addTrailingSlashIfMissed, augmentCodeLocation, augmentLogMessage, convertAnnotations, convertNode, error, getAliasName, getAstBuffer, getImportPath, getRollupError, isAbsolute, isPathFragment, isRelative, isValidUrl, locate, logAddonNotGenerated, logAlreadyClosed, logAmbiguousExternalNamespaces, logAnonymousPluginCache, logAssetNotFinalisedForFileName, logAssetReferenceIdNotFoundForSetSource, logAssetSourceAlreadySet, logBadLoader, logCannotAssignModuleToChunk, logCannotCallNamespace, logCannotEmitFromOptionsHook, logChunkInvalid, logChunkNotGeneratedForFileName, logCircularChunk, logCircularDependency, logCircularReexport, logConflictingSourcemapSources, logConstVariableReassignError, logCyclicCrossChunkReexport, logDuplicateArgumentNameError, logDuplicateExportError, logDuplicatePluginName, logEmptyChunk, logEntryCannotBeExternal, logEval, logExternalModulesCannotBeIncludedInManualChunks, logExternalModulesCannotBeTransformedToModules, logExternalSyntheticExports, logFailedValidation, logFileNameConflict, logFileReferenceIdNotFoundForFilename, logFirstSideEffect, logIllegalIdentifierAsName, logIllegalImportReassignment, logImplicitDependantCannotBeExternal, logImplicitDependantIsNotIncluded, logImportAttributeIsInvalid, logImportOptionsAreInvalid, logIncompatibleExportOptionValue, logInconsistentImportAttributes, logInputHookInOutputPlugin, logInternalIdCannotBeExternal, logInvalidAddonPluginHook, logInvalidAnnotation, logInvalidExportOptionValue, logInvalidFormatForTopLevelAwait, logInvalidFunctionPluginHook, logInvalidLogPosition, logInvalidOption, logInvalidRollupPhaseForChunkEmission, logInvalidSetAssetSourceCall, logInvalidSourcemapForError, logLevelPriority, logMissingEntryExport, logMissingExport, logMissingFileOrDirOption, logMissingGlobalName, logMissingJsxExport, logMissingNameOptionForIifeExport, logMissingNameOptionForUmdExport, logMissingNodeBuiltins, logMixedExport, logModuleLevelDirective, logModuleParseError, logNamespaceConflict, logNoAssetSourceSet, logNoTransformMapOrAstWithoutCode, logOptimizeChunkStatus, logParseError, logPluginError, logRedeclarationError, logReservedNamespace, logShimmedExport, logSourcemapBroken, logSyntheticNamedExportsNeedNamespaceExport, logThisIsUndefined, logUnexpectedNamedImport, logUnexpectedNamespaceReexport, logUnknownOption, logUnresolvedEntry, logUnresolvedImplicitDependant, logUnresolvedImport, logUnresolvedImportTreatedAsExternal, logUnusedExternalImports, normalize, parseAst, parseAstAsync, printQuotedStringList, relative, relativeId, warnDeprecation };
node_modules/rollup/dist/shared/loadConfigFile.js:61:                case parseAst_js.LOGLEVEL_WARN: {
node_modules/rollup/dist/shared/loadConfigFile.js:64:                case parseAst_js.LOGLEVEL_DEBUG: {
node_modules/rollup/dist/shared/loadConfigFile.js:254:    if (process.env.ROLLUP_FILTER_LOGS) {
node_modules/rollup/dist/shared/loadConfigFile.js:255:        filters.push(...process.env.ROLLUP_FILTER_LOGS.split(','));
node_modules/vite/dist/node/chunks/dep-D-7KCb9p.js:510:    TAG_NAMES["DIALOG"] = "dialog";
node_modules/vite/dist/node/chunks/dep-D-7KCb9p.js:641:    TAG_ID[TAG_ID["DIALOG"] = 25] = "DIALOG";
node_modules/vite/dist/node/chunks/dep-D-7KCb9p.js:765:    [TAG_NAMES.DIALOG, TAG_ID.DIALOG],
node_modules/vite/dist/node/chunks/dep-D-7KCb9p.js:6680:        case TAG_ID.DIALOG:
node_modules/vite/dist/node/chunks/dep-D-7KCb9p.js:6989:        case TAG_ID.DIALOG:
node_modules/rollup/dist/shared/parseAst.js:135:const LOGLEVEL_SILENT = 'silent';
node_modules/rollup/dist/shared/parseAst.js:136:const LOGLEVEL_ERROR = 'error';
node_modules/rollup/dist/shared/parseAst.js:137:const LOGLEVEL_WARN = 'warn';
node_modules/rollup/dist/shared/parseAst.js:138:const LOGLEVEL_INFO = 'info';
node_modules/rollup/dist/shared/parseAst.js:139:const LOGLEVEL_DEBUG = 'debug';
node_modules/rollup/dist/shared/parseAst.js:141:    [LOGLEVEL_DEBUG]: 0,
node_modules/rollup/dist/shared/parseAst.js:142:    [LOGLEVEL_INFO]: 1,
node_modules/rollup/dist/shared/parseAst.js:143:    [LOGLEVEL_SILENT]: 3,
node_modules/rollup/dist/shared/parseAst.js:144:    [LOGLEVEL_WARN]: 2
node_modules/rollup/dist/shared/parseAst.js:335:const ADDON_ERROR = 'ADDON_ERROR', ALREADY_CLOSED = 'ALREADY_CLOSED', AMBIGUOUS_EXTERNAL_NAMESPACES = 'AMBIGUOUS_EXTERNAL_NAMESPACES', ANONYMOUS_PLUGIN_CACHE = 'ANONYMOUS_PLUGIN_CACHE', ASSET_NOT_FINALISED = 'ASSET_NOT_FINALISED', ASSET_NOT_FOUND = 'ASSET_NOT_FOUND', ASSET_SOURCE_ALREADY_SET = 'ASSET_SOURCE_ALREADY_SET', ASSET_SOURCE_MISSING = 'ASSET_SOURCE_MISSING', BAD_LOADER = 'BAD_LOADER', CANNOT_CALL_NAMESPACE = 'CANNOT_CALL_NAMESPACE', CANNOT_EMIT_FROM_OPTIONS_HOOK = 'CANNOT_EMIT_FROM_OPTIONS_HOOK', CHUNK_NOT_GENERATED = 'CHUNK_NOT_GENERATED', CHUNK_INVALID = 'CHUNK_INVALID', CIRCULAR_CHUNK = 'CIRCULAR_CHUNK', CIRCULAR_DEPENDENCY = 'CIRCULAR_DEPENDENCY', CIRCULAR_REEXPORT = 'CIRCULAR_REEXPORT', CONST_REASSIGN = 'CONST_REASSIGN', CYCLIC_CROSS_CHUNK_REEXPORT = 'CYCLIC_CROSS_CHUNK_REEXPORT', DEPRECATED_FEATURE = 'DEPRECATED_FEATURE', DUPLICATE_ARGUMENT_NAME = 'DUPLICATE_ARGUMENT_NAME', DUPLICATE_EXPORT = 'DUPLICATE_EXPORT', DUPLICATE_IMPORT_OPTIONS = 'DUPLICATE_IMPORT_OPTIONS', DUPLICATE_PLUGIN_NAME = 'DUPLICATE_PLUGIN_NAME', EMPTY_BUNDLE = 'EMPTY_BUNDLE', EVAL = 'EVAL', EXTERNAL_MODULES_CANNOT_BE_INCLUDED_IN_MANUAL_CHUNKS = 'EXTERNAL_MODULES_CANNOT_BE_INCLUDED_IN_MANUAL_CHUNKS', EXTERNAL_MODULES_CANNOT_BE_TRANSFORMED_TO_MODULES = 'EXTERNAL_MODULES_CANNOT_BE_TRANSFORMED_TO_MODULES', EXTERNAL_SYNTHETIC_EXPORTS = 'EXTERNAL_SYNTHETIC_EXPORTS', FAIL_AFTER_WARNINGS = 'FAIL_AFTER_WARNINGS', FILE_NAME_CONFLICT = 'FILE_NAME_CONFLICT', FILE_NOT_FOUND = 'FILE_NOT_FOUND', FIRST_SIDE_EFFECT = 'FIRST_SIDE_EFFECT', ILLEGAL_IDENTIFIER_AS_NAME = 'ILLEGAL_IDENTIFIER_AS_NAME', ILLEGAL_REASSIGNMENT = 'ILLEGAL_REASSIGNMENT', INCONSISTENT_IMPORT_ATTRIBUTES = 'INCONSISTENT_IMPORT_ATTRIBUTES', INVALID_ANNOTATION = 'INVALID_ANNOTATION', INPUT_HOOK_IN_OUTPUT_PLUGIN = 'INPUT_HOOK_IN_OUTPUT_PLUGIN', INVALID_CHUNK = 'INVALID_CHUNK', INVALID_CONFIG_MODULE_FORMAT = 'INVALID_CONFIG_MODULE_FORMAT', INVALID_EXPORT_OPTION = 'INVALID_EXPORT_OPTION', INVALID_EXTERNAL_ID = 'INVALID_EXTERNAL_ID', INVALID_IMPORT_ATTRIBUTE = 'INVALID_IMPORT_ATTRIBUTE', INVALID_LOG_POSITION = 'INVALID_LOG_POSITION', INVALID_OPTION = 'INVALID_OPTION', INVALID_PLUGIN_HOOK = 'INVALID_PLUGIN_HOOK', INVALID_ROLLUP_PHASE = 'INVALID_ROLLUP_PHASE', INVALID_SETASSETSOURCE = 'INVALID_SETASSETSOURCE', INVALID_TLA_FORMAT = 'INVALID_TLA_FORMAT', MISSING_CONFIG = 'MISSING_CONFIG', MISSING_EXPORT = 'MISSING_EXPORT', MISSING_EXTERNAL_CONFIG = 'MISSING_EXTERNAL_CONFIG', MISSING_GLOBAL_NAME = 'MISSING_GLOBAL_NAME', MISSING_IMPLICIT_DEPENDANT = 'MISSING_IMPLICIT_DEPENDANT', MISSING_JSX_EXPORT = 'MISSING_JSX_EXPORT', MISSING_NAME_OPTION_FOR_IIFE_EXPORT = 'MISSING_NAME_OPTION_FOR_IIFE_EXPORT', MISSING_NODE_BUILTINS = 'MISSING_NODE_BUILTINS', MISSING_OPTION = 'MISSING_OPTION', MIXED_EXPORTS = 'MIXED_EXPORTS', MODULE_LEVEL_DIRECTIVE = 'MODULE_LEVEL_DIRECTIVE', NAMESPACE_CONFLICT = 'NAMESPACE_CONFLICT', NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE = 'NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE', ONLY_INLINE_SOURCEMAPS = 'ONLY_INLINE_SOURCEMAPS', OPTIMIZE_CHUNK_STATUS = 'OPTIMIZE_CHUNK_STATUS', PARSE_ERROR = 'PARSE_ERROR', PLUGIN_ERROR = 'PLUGIN_ERROR', REDECLARATION_ERROR = 'REDECLARATION_ERROR', RESERVED_NAMESPACE = 'RESERVED_NAMESPACE', SHIMMED_EXPORT = 'SHIMMED_EXPORT', SOURCEMAP_BROKEN = 'SOURCEMAP_BROKEN', SOURCEMAP_ERROR = 'SOURCEMAP_ERROR', SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT = 'SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT', THIS_IS_UNDEFINED = 'THIS_IS_UNDEFINED', UNEXPECTED_NAMED_IMPORT = 'UNEXPECTED_NAMED_IMPORT', UNKNOWN_OPTION = 'UNKNOWN_OPTION', UNRESOLVED_ENTRY = 'UNRESOLVED_ENTRY', UNRESOLVED_IMPORT = 'UNRESOLVED_IMPORT', UNUSED_EXTERNAL_IMPORT = 'UNUSED_EXTERNAL_IMPORT', VALIDATION_ERROR = 'VALIDATION_ERROR';
node_modules/rollup/dist/shared/parseAst.js:646:        code: INVALID_LOG_POSITION,
node_modules/rollup/dist/shared/parseAst.js:1038:        log(LOGLEVEL_WARN, warning);
node_modules/rollup/dist/shared/parseAst.js:2175:exports.LOGLEVEL_DEBUG = LOGLEVEL_DEBUG;
node_modules/rollup/dist/shared/parseAst.js:2176:exports.LOGLEVEL_ERROR = LOGLEVEL_ERROR;
node_modules/rollup/dist/shared/parseAst.js:2177:exports.LOGLEVEL_INFO = LOGLEVEL_INFO;
node_modules/rollup/dist/shared/parseAst.js:2178:exports.LOGLEVEL_WARN = LOGLEVEL_WARN;
node_modules/playwright-core/types/protocol.d.ts:9642:this one being a DVLOG(ERROR) style log message that gets printed
node_modules/rollup/dist/shared/rollup.js:249:        log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logFileNameConflict(fileName));
node_modules/rollup/dist/shared/rollup.js:631:            if (level === parseAst_js.LOGLEVEL_ERROR) {
node_modules/rollup/dist/shared/rollup.js:643:        if (level === parseAst_js.LOGLEVEL_WARN) {
node_modules/rollup/dist/shared/rollup.js:644:            onwarn(addLogToString(log), warning => printLog(parseAst_js.LOGLEVEL_WARN, normalizeLog(warning)));
node_modules/rollup/dist/shared/rollup.js:665:        case parseAst_js.LOGLEVEL_WARN: {
node_modules/rollup/dist/shared/rollup.js:668:        case parseAst_js.LOGLEVEL_DEBUG: {
node_modules/rollup/dist/shared/rollup.js:680:        log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logUnknownOption(optionType, unknownOptions, [...validOptionSet].sort()));
node_modules/rollup/dist/shared/rollup.js:786:            logger(parseAst_js.LOGLEVEL_WARN, parseAst_js.logInvalidLogPosition(pluginName));
node_modules/rollup/dist/shared/rollup.js:910:        debug: getLogHandler(parseAst_js.LOGLEVEL_DEBUG, 'PLUGIN_LOG', onLog, plugin.name, logLevel),
node_modules/rollup/dist/shared/rollup.js:920:        info: getLogHandler(parseAst_js.LOGLEVEL_INFO, 'PLUGIN_LOG', onLog, plugin.name, logLevel),
node_modules/rollup/dist/shared/rollup.js:934:        warn: getLogHandler(parseAst_js.LOGLEVEL_WARN, 'PLUGIN_WARNING', onLog, plugin.name, logLevel)
node_modules/rollup/dist/shared/rollup.js:3253:                        options.onLog(parseAst_js.LOGLEVEL_WARN, parseAst_js.logInputHookInOutputPlugin(plugin.name, hook));
node_modules/rollup/dist/shared/rollup.js:3503:                debug: getLogHandler(parseAst_js.LOGLEVEL_DEBUG),
node_modules/rollup/dist/shared/rollup.js:3505:                info: getLogHandler(parseAst_js.LOGLEVEL_INFO),
node_modules/rollup/dist/shared/rollup.js:3507:                warn: getLogHandler(parseAst_js.LOGLEVEL_WARN)
node_modules/rollup/dist/shared/rollup.js:3536:    const logLevel = config.logLevel || parseAst_js.LOGLEVEL_INFO;
node_modules/rollup/dist/shared/rollup.js:6467:        this.options.onLog(parseAst_js.LOGLEVEL_WARN, parseAst_js.logUnusedExternalImports(this.id, unused, importersArray));
node_modules/rollup/dist/shared/rollup.js:10287:            this.scope.context.log(parseAst_js.LOGLEVEL_WARN, 
node_modules/rollup/dist/shared/rollup.js:11465:                this.scope.context.log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logIllegalImportReassignment(this.object.name, this.scope.context.module.id), this.start);
node_modules/rollup/dist/shared/rollup.js:11501:            astContext.log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logMissingExport(exportName, astContext.module.id, fileName, !!options?.missingButExportExists), path[0].pos);
node_modules/rollup/dist/shared/rollup.js:12345:    log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logMissingNodeBuiltins(externalBuiltins));
node_modules/rollup/dist/shared/rollup.js:12542:        log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logReservedNamespace(parts[0]));
node_modules/rollup/dist/shared/rollup.js:12564:        log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logReservedNamespace(parts[0]));
node_modules/rollup/dist/shared/rollup.js:12610:        log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logMissingNameOptionForIifeExport());
node_modules/rollup/dist/shared/rollup.js:13329:                this.scope.context.log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logConstVariableReassignError(), this.left.start);
node_modules/rollup/dist/shared/rollup.js:13876:                this.scope.context.log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logCannotCallNamespace(this.callee.name), this.start);
node_modules/rollup/dist/shared/rollup.js:13879:                this.scope.context.log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logEval(this.scope.context.module.id), this.start);
node_modules/rollup/dist/shared/rollup.js:16105:                    log(parseAst_js.LOGLEVEL_INFO, parseAst_js.logFirstSideEffect(code, module.id, parseAst_js.locate(code, node.start, { offsetLine: 1 })), node.start);
node_modules/rollup/dist/shared/rollup.js:16126:                    this.scope.context.log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logInvalidAnnotation(this.scope.context.code.slice(start, end), this.scope.context.module.id, type), start);
node_modules/rollup/dist/shared/rollup.js:16573:                this.scope.context.log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logCannotCallNamespace(name), this.start);
node_modules/rollup/dist/shared/rollup.js:16736:            this.scope.context.log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logThisIsUndefined(), this.start);
node_modules/rollup/dist/shared/rollup.js:18283:            context.module.log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logImportAttributeIsInvalid(context.module.id), start);
node_modules/rollup/dist/shared/rollup.js:18292:        context.module.log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logImportOptionsAreInvalid(context.module.id), start);
node_modules/rollup/dist/shared/rollup.js:18302:        context.module.log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logImportAttributeIsInvalid(context.module.id), property.start);
node_modules/rollup/dist/shared/rollup.js:19207:                this.options.onLog(parseAst_js.LOGLEVEL_WARN, parseAst_js.logInvalidSourcemapForError(error_, this.id, column, line, pos));
node_modules/rollup/dist/shared/rollup.js:19248:                this.log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logInconsistentImportAttributes(existingAttributes, parsedAttributes, source, this.id), declaration.start);
node_modules/rollup/dist/shared/rollup.js:19295:            this.options.onLog(parseAst_js.LOGLEVEL_WARN, parseAst_js.logNamespaceConflict(name, this.id, foundDeclarationList.map(([, module]) => module.id)));
node_modules/rollup/dist/shared/rollup.js:19303:                this.options.onLog(parseAst_js.LOGLEVEL_WARN, parseAst_js.logAmbiguousExternalNamespaces(name, this.id, usedDeclaration.module.id, foundDeclarationList.map(declaration => declaration.module.id)));
node_modules/rollup/dist/shared/rollup.js:19375:        this.options.onLog(parseAst_js.LOGLEVEL_WARN, parseAst_js.logShimmedExport(this.id, name));
node_modules/rollup/dist/shared/rollup.js:19611:                log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logMixedExport(facadeModuleId, name));
node_modules/rollup/dist/shared/rollup.js:19714:        log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logMissingGlobalName(chunk.id, chunk.variableName));
node_modules/rollup/dist/shared/rollup.js:20204:                        this.inputOptions.onLog(parseAst_js.LOGLEVEL_WARN, parseAst_js.logCyclicCrossChunkReexport(
node_modules/rollup/dist/shared/rollup.js:20506:                    this.inputOptions.onLog(parseAst_js.LOGLEVEL_WARN, parseAst_js.logUnexpectedNamespaceReexport(id));
node_modules/rollup/dist/shared/rollup.js:20677:            onLog(parseAst_js.LOGLEVEL_WARN, parseAst_js.logEmptyChunk(this.getChunkName()));
node_modules/rollup/dist/shared/rollup.js:21764:        log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logSourcemapBroken(map.plugin));
node_modules/rollup/dist/shared/rollup.js:22146:                        this.inputOptions.onLog(parseAst_js.LOGLEVEL_WARN, parseAst_js.logChunkInvalid(file, error_));
node_modules/rollup/dist/shared/rollup.js:22203:                    this.inputOptions.onLog(parseAst_js.LOGLEVEL_WARN, parseAst_js.logCircularChunk(path, isManualChunkConflict));
node_modules/rollup/dist/shared/rollup.js:22233:        log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logInvalidOption('output.amd.id', parseAst_js.URL_OUTPUT_AMD_ID, 'this option is only properly supported for single-file builds. Use "output.amd.autoId" and "output.amd.basePath" instead'));
node_modules/rollup/dist/shared/rollup.js:22442:                    options.onLog(parseAst_js.LOGLEVEL_WARN, parseAst_js.logNoTransformMapOrAstWithoutCode(plugin.name));
node_modules/rollup/dist/shared/rollup.js:22749:                this.options.onLog(parseAst_js.LOGLEVEL_WARN, parseAst_js.logInconsistentImportAttributes(existingModule.info.attributes, attributes, id, importer));
node_modules/rollup/dist/shared/rollup.js:22803:                this.options.onLog(parseAst_js.LOGLEVEL_WARN, parseAst_js.logInconsistentImportAttributes(externalModule.info.attributes, attributes, source, importer));
node_modules/rollup/dist/shared/rollup.js:22918:            this.options.onLog(parseAst_js.LOGLEVEL_WARN, parseAst_js.logUnresolvedImportTreatedAsExternal(source, importer));
node_modules/rollup/dist/shared/rollup.js:22930:            this.options.onLog(parseAst_js.LOGLEVEL_WARN, parseAst_js.logExternalSyntheticExports(source, importer));
node_modules/rollup/dist/shared/rollup.js:22972:                    this.options.onLog(parseAst_js.LOGLEVEL_WARN, parseAst_js.logInconsistentImportAttributes(existingResolution.attributes, attributes, specifier, importer));
node_modules/rollup/dist/shared/rollup.js:23211:            this.options.onLog(parseAst_js.LOGLEVEL_WARN, parseAst_js.logCircularDependency(cyclePath));
node_modules/rollup/dist/shared/rollup.js:23225:                        module.log(parseAst_js.LOGLEVEL_WARN, parseAst_js.logMissingExport(importDescription.name, module.id, importDescription.module.id, !!options?.missingButExportExists), importDescription.start);
node_modules/rollup/dist/shared/rollup.js:23297:    const logLevel = config.logLevel || parseAst_js.LOGLEVEL_INFO;
node_modules/rollup/dist/shared/rollup.js:23843:    const logLevel = inputOptions.logLevel || parseAst_js.LOGLEVEL_INFO;
node_modules/rollup/dist/shared/rollup.js:23849:            debug: getLogHandler(parseAst_js.LOGLEVEL_DEBUG, 'PLUGIN_LOG', logger, name, logLevel),
node_modules/rollup/dist/shared/rollup.js:23851:            info: getLogHandler(parseAst_js.LOGLEVEL_INFO, 'PLUGIN_LOG', logger, name, logLevel),
node_modules/rollup/dist/shared/rollup.js:23853:            warn: getLogHandler(parseAst_js.LOGLEVEL_WARN, 'PLUGIN_WARNING', logger, name, logLevel)
node_modules/@babel/types/lib/definitions/core.js.map:1:{"version":3,"names":["_is","require","_isValidIdentifier","_helperValidatorIdentifier","_helperStringParser","_index","_utils","classMethodOrPropertyUnionShapeCommon","allowPrivateName","unionShape","discriminator","shapes","name","value","properties","key","validate","assertNodeType","exports","defineType","defineAliasedType","fields","elements","arrayOf","assertNodeOrValueType","default","process","env","BABEL_TYPES_8_BREAKING","undefined","visitor","aliases","operator","assertValueType","Object","assign","identifier","assertOneOf","ASSIGNMENT_OPERATORS","pattern","node","val","validator","is","left","oneOf","right","builder","BINARY_OPERATORS","expression","inOp","oneOfNodeTypes","directives","arrayOfType","body","validateArrayOfType","label","optional","callee","arguments","typeArguments","typeParameters","param","test","consequent","alternate","program","comments","each","assertEach","tokens","type","init","update","functionCommon","params","generator","async","functionTypeAnnotationCommon","returnType","functionDeclarationCommon","declare","id","predicate","parent","inherits","patternLikeCommon","typeAnnotation","decorators","chain","isValidIdentifier","TypeError","match","exec","toString","parentKey","nonComp","computed","imported","meta","isKeyword","isReservedWord","deprecatedAlias","Number","isFinite","error","Error","flags","invalid","LOGICAL_OPERATORS","property","object","normal","sourceType","interpreter","kind","shorthand","argument","listKey","index","length","expressions","discriminant","cases","block","handler","finalizer","prefix","UNARY_OPERATORS","UPDATE_OPERATORS","declarations","withoutInit","constOrLetOrVar","usingOrAwaitUsing","parentIsForX","decl","definite","superClass","implements","mixins","abstract","importAttributes","attributes","assertions","deprecated","source","exportKind","validateOptional","declaration","validateType","specifiers","sourced","sourceless","local","exported","lval","await","module","phase","importKind","options","classMethodOrPropertyCommon","accessibility","static","override","classMethodOrDeclareMethodCommon","access","tag","quasi","assertShape","raw","cooked","templateElementCookedValidator","unterminatedCalled","str","firstInvalidLoc","readStringContents","unterminated","strictNumericEscape","invalidEscapeSequence","numericSeparatorInEscapeSequence","unexpectedNumericSeparator","invalidDigit","invalidCodePoint","tail","quasis","delegate","assertOptionalChainStart","readonly","variance"],"sources":["../../src/definitions/core.ts"],"sourcesContent":["import is from \"../validators/is.ts\";\nimport isValidIdentifier from \"../validators/isValidIdentifier.ts\";\nimport { isKeyword, isReservedWord } from \"@babel/helper-validator-identifier\";\nimport type * as t from \"../index.ts\";\nimport { readStringContents } from \"@babel/helper-string-parser\";\n\nimport {\n  BINARY_OPERATORS,\n  LOGICAL_OPERATORS,\n  ASSIGNMENT_OPERATORS,\n  UNARY_OPERATORS,\n  UPDATE_OPERATORS,\n} from \"../constants/index.ts\";\n\nimport {\n  defineAliasedType,\n  assertShape,\n  assertOptionalChainStart,\n  assertValueType,\n  assertNodeType,\n  assertNodeOrValueType,\n  assertEach,\n  chain,\n  assertOneOf,\n  validateOptional,\n  arrayOf,\n  arrayOfType,\n  validateArrayOfType,\n  validateType,\n  type Validator,\n  type ValidatorImpl,\n  type ValidatorOneOfNodeTypes,\n  type ValidatorType,\n} from \"./utils.ts\";\n\nexport const classMethodOrPropertyUnionShapeCommon = (\n  allowPrivateName = false,\n) => ({\n  unionShape: {\n    discriminator: \"computed\",\n    shapes: [\n      {\n        name: \"computed\",\n        value: [true],\n        properties: {\n          key: {\n            validate: assertNodeType(\"Expression\"),\n          },\n        },\n      },\n      {\n        name: \"nonComputed\",\n        value: [false],\n        properties: {\n          key: {\n            validate: allowPrivateName\n              ? assertNodeType(\n                  \"Identifier\",\n                  \"StringLiteral\",\n                  \"NumericLiteral\",\n                  \"BigIntLiteral\",\n                  \"PrivateName\",\n                )\n              : assertNodeType(\n                  \"Identifier\",\n                  \"StringLiteral\",\n                  \"NumericLiteral\",\n                  \"BigIntLiteral\",\n                ),\n          },\n        },\n      },\n    ],\n  },\n});\n\nconst defineType = defineAliasedType(\"Standardized\");\n\ndefineType(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: arrayOf(\n        assertNodeOrValueType(\"null\", \"Expression\", \"SpreadElement\"),\n      ),\n      default:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? []\n          : undefined,\n    },\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertValueType(\"string\")\n          : Object.assign(\n              (function () {\n                const identifier = assertOneOf(...ASSIGNMENT_OPERATORS);\n                const pattern = assertOneOf(\"=\");\n\n                return function (node: t.AssignmentExpression, key, val) {\n                  const validator = is(\"Pattern\", node.left)\n                    ? pattern\n                    : identifier;\n                  validator(node, key, val);\n                } satisfies ValidatorImpl;\n              })(),\n              { oneOf: ASSIGNMENT_OPERATORS },\n            ),\n    },\n    left: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertNodeType(\"LVal\", \"OptionalMemberExpression\")\n          : assertNodeType(\n              \"Identifier\",\n              \"MemberExpression\",\n              \"OptionalMemberExpression\",\n              \"ArrayPattern\",\n              \"ObjectPattern\",\n              \"TSAsExpression\",\n              \"TSSatisfiesExpression\",\n              \"TSTypeAssertion\",\n              \"TSNonNullExpression\",\n            ),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: assertOneOf(...BINARY_OPERATORS),\n    },\n    left: {\n      validate: (function () {\n        const expression = assertNodeType(\"Expression\");\n        const inOp = assertNodeType(\"Expression\", \"PrivateName\");\n\n        const validator: ValidatorOneOfNodeTypes = Object.assign(\n          function (node: t.BinaryExpression, key, val) {\n            const validator = node.operator === \"in\" ? inOp : expression;\n            validator(node, key, val);\n          } satisfies ValidatorImpl,\n          // todo(ts): can be discriminated union by `operator` property\n          { oneOfNodeTypes: [\"Expression\", \"PrivateName\"] as const },\n        );\n        return validator;\n      })(),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n});\n\ndefineType(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n});\n\ndefineType(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: assertNodeType(\"DirectiveLiteral\"),\n    },\n  },\n});\n\ndefineType(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n});\n\ndefineType(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: arrayOfType(\"Directive\"),\n      default: [],\n    },\n    body: validateArrayOfType(\"Statement\"),\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"],\n});\n\ndefineType(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n});\n\ndefineType(\"CallExpression\", {\n  visitor: process.env.BABEL_8_BREAKING\n    ? [\"callee\", \"typeArguments\", \"arguments\"]\n    : [\"callee\", \"typeParameters\", \"typeArguments\", \"arguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: assertNodeType(\"Expression\", \"Super\", \"V8IntrinsicIdentifier\"),\n    },\n    arguments: validateArrayOfType(\n      \"Expression\",\n      \"SpreadElement\",\n      \"ArgumentPlaceholder\",\n    ),\n    typeArguments: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\n            \"TypeParameterInstantiation\",\n            \"TSTypeParameterInstantiation\",\n          )\n        : assertNodeType(\"TypeParameterInstantiation\"),\n      optional: true,\n    },\n    ...(process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n      ? {}\n      : {\n          optional: {\n            validate: assertValueType(\"boolean\"),\n            optional: true,\n          },\n          typeParameters: {\n            validate: assertNodeType(\"TSTypeParameterInstantiation\"),\n            optional: true,\n          },\n        }),\n  },\n});\n\ndefineType(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: assertNodeType(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n  aliases: [\"Scopable\", \"BlockParent\"],\n});\n\ndefineType(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    consequent: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    alternate: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  aliases: [\"Expression\", \"Conditional\"],\n});\n\ndefineType(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n});\n\ndefineType(\"DebuggerStatement\", {\n  aliases: [\"Statement\"],\n});\n\ndefineType(\"DoWhileStatement\", {\n  builder: [\"test\", \"body\"],\n  visitor: [\"body\", \"test\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n});\n\ndefineType(\"EmptyStatement\", {\n  aliases: [\"Statement\"],\n});\n\ndefineType(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"],\n});\n\ndefineType(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: assertNodeType(\"Program\"),\n    },\n    comments: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? Object.assign(() => {}, {\n              each: { oneOfNodeTypes: [\"CommentBlock\", \"CommentLine\"] },\n            })\n          : assertEach(assertNodeType(\"CommentBlock\", \"CommentLine\")),\n      optional: true,\n    },\n    tokens: {\n      // todo(ts): add Token type\n      validate: assertEach(Object.assign(() => {}, { type: \"any\" })),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\n    \"Scopable\",\n    \"Statement\",\n    \"For\",\n    \"BlockParent\",\n    \"Loop\",\n    \"ForXStatement\",\n  ],\n  fields: {\n    left: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertNodeType(\"VariableDeclaration\", \"LVal\")\n          : assertNodeType(\n              \"VariableDeclaration\",\n              \"Identifier\",\n              \"MemberExpression\",\n              \"ArrayPattern\",\n              \"ObjectPattern\",\n              \"TSAsExpression\",\n              \"TSSatisfiesExpression\",\n              \"TSTypeAssertion\",\n              \"TSNonNullExpression\",\n            ),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: assertNodeType(\"VariableDeclaration\", \"Expression\"),\n      optional: true,\n    },\n    test: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    update: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\nexport const functionCommon = () => ({\n  params: validateArrayOfType(\"FunctionParameter\"),\n  generator: {\n    default: false,\n  },\n  async: {\n    default: false,\n  },\n});\n\nexport const functionTypeAnnotationCommon = () => ({\n  returnType: {\n    validate: process.env.BABEL_8_BREAKING\n      ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n      : assertNodeType(\n          \"TypeAnnotation\",\n          \"TSTypeAnnotation\",\n          // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n          \"Noop\",\n        ),\n    optional: true,\n  },\n  typeParameters: {\n    validate: process.env.BABEL_8_BREAKING\n      ? assertNodeType(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\")\n      : assertNodeType(\n          \"TypeParameterDeclaration\",\n          \"TSTypeParameterDeclaration\",\n          // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n          \"Noop\",\n        ),\n    optional: true,\n  },\n});\n\nexport const functionDeclarationCommon = () => ({\n  ...functionCommon(),\n  declare: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  id: {\n    validate: assertNodeType(\"Identifier\"),\n    optional: true, // May be null for `export default function`\n  },\n});\n\ndefineType(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\n    \"id\",\n    \"typeParameters\",\n    \"params\",\n    \"predicate\",\n    \"returnType\",\n    \"body\",\n  ],\n  fields: {\n    ...functionDeclarationCommon(),\n    ...functionTypeAnnotationCommon(),\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n    predicate: {\n      validate: assertNodeType(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true,\n    },\n  },\n  aliases: [\n    \"Scopable\",\n    \"Function\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Statement\",\n    \"Pureish\",\n    \"Declaration\",\n  ],\n  validate:\n    !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n      ? undefined\n      : (function () {\n          const identifier = assertNodeType(\"Identifier\");\n\n          return function (parent, key, node) {\n            if (!is(\"ExportDefaultDeclaration\", parent)) {\n              identifier(node, \"id\", node.id);\n            }\n          };\n        })(),\n});\n\ndefineType(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\n    \"Scopable\",\n    \"Function\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Expression\",\n    \"Pureish\",\n  ],\n  fields: {\n    ...functionCommon(),\n    ...functionTypeAnnotationCommon(),\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n    predicate: {\n      validate: assertNodeType(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true,\n    },\n  },\n});\n\nexport const patternLikeCommon = () => ({\n  typeAnnotation: {\n    validate: process.env.BABEL_8_BREAKING\n      ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n      : assertNodeType(\n          \"TypeAnnotation\",\n          \"TSTypeAnnotation\",\n          // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n          \"Noop\",\n        ),\n    optional: true,\n  },\n  optional: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  decorators: {\n    validate: arrayOfType(\"Decorator\"),\n    optional: true,\n  },\n});\n\ndefineType(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\" /* for legacy param decorators */],\n  aliases: [\n    \"Expression\",\n    \"FunctionParameter\",\n    \"PatternLike\",\n    \"LVal\",\n    \"TSEntityName\",\n  ],\n  fields: {\n    ...patternLikeCommon(),\n    name: {\n      validate:\n        process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n          ? chain(\n              assertValueType(\"string\"),\n              Object.assign(\n                function (node, key, val) {\n                  if (!isValidIdentifier(val, false)) {\n                    throw new TypeError(\n                      `\"${val}\" is not a valid identifier name`,\n                    );\n                  }\n                } satisfies ValidatorImpl,\n                { type: \"string\" as const },\n              ) satisfies ValidatorType,\n            )\n          : assertValueType(\"string\"),\n    },\n  },\n  validate:\n    process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n      ? function (parent, key, node) {\n          const match = /\\.(\\w+)$/.exec(key.toString());\n          if (!match) return;\n\n          const [, parentKey] = match;\n          const nonComp = { computed: false };\n\n          // We can't check if `parent.property === node`, because nodes are validated\n          // before replacing them in the AST.\n          if (parentKey === \"property\") {\n            if (is(\"MemberExpression\", parent, nonComp)) return;\n            if (is(\"OptionalMemberExpression\", parent, nonComp)) return;\n          } else if (parentKey === \"key\") {\n            if (is(\"Property\", parent, nonComp)) return;\n            if (is(\"Method\", parent, nonComp)) return;\n          } else if (parentKey === \"exported\") {\n            if (is(\"ExportSpecifier\", parent)) return;\n          } else if (parentKey === \"imported\") {\n            if (is(\"ImportSpecifier\", parent, { imported: node })) return;\n          } else if (parentKey === \"meta\") {\n            if (is(\"MetaProperty\", parent, { meta: node })) return;\n          }\n\n          if (\n            // Ideally we should call isStrictReservedWord if this node is a descendant\n            // of a block in strict mode. Also, we should pass the inModule option so\n            // we can disable \"await\" in module.\n            (isKeyword(node.name) || isReservedWord(node.name, false)) &&\n            // Even if \"this\" is a keyword, we are using the Identifier\n            // node to represent it.\n            node.name !== \"this\"\n          ) {\n            throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n          }\n        }\n      : undefined,\n});\n\ndefineType(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    consequent: {\n      validate: assertNodeType(\"Statement\"),\n    },\n    alternate: {\n      optional: true,\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: chain(\n        assertValueType(\"number\"),\n        Object.assign(\n          function (node, key, val) {\n            if (1 / val < 0 || !Number.isFinite(val)) {\n              const error = new Error(\n                \"NumericLiterals must be non-negative finite numbers. \" +\n                  `You can use t.valueToNode(${val}) instead.`,\n              );\n              if (process.env.BABEL_8_BREAKING) {\n                // TODO(@nicolo-ribaudo) Fix regenerator to not pass negative\n                // numbers here.\n                if (!IS_STANDALONE) {\n                  if (!new Error().stack.includes(\"regenerator\")) {\n                    throw error;\n                  }\n                }\n              } else {\n                // TODO: Enable this warning once regenerator is fixed.\n                // https://github.com/facebook/regenerator/pull/680\n                // console.warn(error);\n              }\n            }\n          } satisfies ValidatorImpl,\n          { type: \"number\" as const },\n        ) satisfies ValidatorType,\n      ),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"boolean\"),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: assertValueType(\"string\"),\n    },\n    flags: {\n      validate:\n        process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n          ? chain(\n              assertValueType(\"string\"),\n              Object.assign(\n                function (node, key, val) {\n                  const invalid = /[^dgimsuvy]/.exec(val);\n                  if (invalid) {\n                    throw new TypeError(\n                      `\"${invalid[0]}\" is not a valid RegExp flag`,\n                    );\n                  }\n                } satisfies ValidatorImpl,\n                { type: \"string\" as const },\n              ) satisfies ValidatorType,\n            )\n          : assertValueType(\"string\"),\n      default: \"\",\n    },\n  },\n});\n\ndefineType(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: assertOneOf(...LOGICAL_OPERATORS),\n    },\n    left: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"MemberExpression\", {\n  builder: [\n    \"object\",\n    \"property\",\n    \"computed\",\n    ...(!process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n      ? [\"optional\"]\n      : []),\n  ],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  unionShape: {\n    discriminator: \"computed\",\n    shapes: [\n      {\n        name: \"computed\",\n        value: [true],\n        properties: {\n          property: {\n            validate: assertNodeType(\"Expression\"),\n          },\n        },\n      },\n      {\n        name: \"nonComputed\",\n        value: [false],\n        properties: {\n          property: {\n            validate: assertNodeType(\"Identifier\", \"PrivateName\"),\n          },\n        },\n      },\n    ],\n  },\n  fields: {\n    object: {\n      validate: assertNodeType(\"Expression\", \"Super\"),\n    },\n    property: {\n      validate: (function () {\n        const normal = assertNodeType(\"Identifier\", \"PrivateName\");\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: ValidatorOneOfNodeTypes = function (\n          node: t.MemberExpression,\n          key,\n          val,\n        ) {\n          const validator: Validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        // todo(ts): can be discriminated union by `computed` property\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      })(),\n    },\n    computed: {\n      default: false,\n    },\n    ...(!process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n      ? {\n          optional: {\n            validate: assertValueType(\"boolean\"),\n            optional: true,\n          },\n        }\n      : {}),\n  },\n});\n\ndefineType(\"NewExpression\", { inherits: \"CallExpression\" });\n\ndefineType(\"Program\", {\n  // Note: We explicitly leave 'interpreter' out here because it is\n  // conceptually comment-like, and Babel does not traverse comments either.\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceType: {\n      validate: assertOneOf(\"script\", \"module\"),\n      default: \"script\",\n    },\n    interpreter: {\n      validate: assertNodeType(\"InterpreterDirective\"),\n      default: null,\n      optional: true,\n    },\n    directives: {\n      validate: arrayOfType(\"Directive\"),\n      default: [],\n    },\n    body: validateArrayOfType(\"Statement\"),\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"],\n});\n\ndefineType(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: validateArrayOfType(\n      \"ObjectMethod\",\n      \"ObjectProperty\",\n      \"SpreadElement\",\n    ),\n  },\n});\n\ndefineType(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  visitor: [\n    \"decorators\",\n    \"key\",\n    \"typeParameters\",\n    \"params\",\n    \"returnType\",\n    \"body\",\n  ],\n  ...classMethodOrPropertyUnionShapeCommon(),\n  fields: {\n    ...functionCommon(),\n    ...functionTypeAnnotationCommon(),\n    kind: {\n      validate: assertOneOf(\"method\", \"get\", \"set\"),\n      ...(!process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n        ? { default: \"method\" }\n        : {}),\n    },\n    computed: {\n      default: false,\n    },\n    key: {\n      validate: (function () {\n        const normal = assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        );\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: ValidatorOneOfNodeTypes = function (\n          node: t.ObjectMethod,\n          key,\n          val,\n        ) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        // todo(ts): can be discriminated union by `computed` property\n        validator.oneOfNodeTypes = [\n          \"Expression\",\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        ];\n        return validator;\n      })(),\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n  aliases: [\n    \"UserWhitespacable\",\n    \"Function\",\n    \"Scopable\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Method\",\n    \"ObjectMember\",\n  ],\n});\n\ndefineType(\"ObjectProperty\", {\n  builder: [\n    \"key\",\n    \"value\",\n    \"computed\",\n    \"shorthand\",\n    ...(!process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n      ? [\"decorators\"]\n      : []),\n  ],\n  unionShape: {\n    discriminator: \"computed\",\n    shapes: [\n      {\n        name: \"computed\",\n        value: [true],\n        properties: {\n          key: {\n            validate: assertNodeType(\"Expression\"),\n          },\n        },\n      },\n      {\n        name: \"nonComputed\",\n        value: [false],\n        properties: {\n          key: {\n            validate: process.env.BABEL_8_BREAKING\n              ? assertNodeType(\n                  \"Identifier\",\n                  \"StringLiteral\",\n                  \"NumericLiteral\",\n                  \"BigIntLiteral\",\n                  \"PrivateName\",\n                )\n              : assertNodeType(\n                  \"Identifier\",\n                  \"StringLiteral\",\n                  \"NumericLiteral\",\n                  \"BigIntLiteral\",\n                  // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n                  \"DecimalLiteral\",\n                  \"PrivateName\",\n                ),\n          },\n        },\n      },\n    ],\n  },\n  fields: {\n    computed: {\n      default: false,\n    },\n    key: {\n      validate: (function () {\n        const normal = process.env.BABEL_8_BREAKING\n          ? assertNodeType(\n              \"Identifier\",\n              \"StringLiteral\",\n              \"NumericLiteral\",\n              \"BigIntLiteral\",\n              \"PrivateName\",\n            )\n          : assertNodeType(\n              \"Identifier\",\n              \"StringLiteral\",\n              \"NumericLiteral\",\n              \"BigIntLiteral\",\n              // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n              \"DecimalLiteral\",\n              \"PrivateName\",\n            );\n        const computed = assertNodeType(\"Expression\");\n\n        // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST allows DecimalLiteral\n        const validator: ValidatorOneOfNodeTypes = Object.assign(\n          function (node: t.ObjectProperty, key, val) {\n            const validator = node.computed ? computed : normal;\n            validator(node, key, val);\n          } satisfies ValidatorImpl,\n          {\n            // todo(ts): can be discriminated union by `computed` property\n            oneOfNodeTypes: process.env.BABEL_8_BREAKING\n              ? ([\n                  \"Expression\",\n                  \"Identifier\",\n                  \"StringLiteral\",\n                  \"NumericLiteral\",\n                  \"BigIntLiteral\",\n                  \"PrivateName\",\n                ] as const)\n              : ([\n                  \"Expression\",\n                  \"Identifier\",\n                  \"StringLiteral\",\n                  \"NumericLiteral\",\n                  \"BigIntLiteral\",\n                  \"DecimalLiteral\",\n                  \"PrivateName\",\n                ] as const),\n          },\n        );\n        return validator;\n      })(),\n    },\n    value: {\n      // Value may be PatternLike if this is an AssignmentProperty\n      // https://github.com/babel/babylon/issues/434\n      validate: assertNodeType(\"Expression\", \"PatternLike\"),\n    },\n    shorthand: {\n      validate:\n        process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n          ? chain(\n              assertValueType(\"boolean\"),\n              Object.assign(\n                function (node: t.ObjectProperty, key, shorthand) {\n                  if (!shorthand) return;\n\n                  if (node.computed) {\n                    throw new TypeError(\n                      \"Property shorthand of ObjectProperty cannot be true if computed is true\",\n                    );\n                  }\n\n                  if (!is(\"Identifier\", node.key)) {\n                    throw new TypeError(\n                      \"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\",\n                    );\n                  }\n                } satisfies ValidatorImpl,\n                { type: \"boolean\" as const },\n              ) satisfies ValidatorType,\n            )\n          : assertValueType(\"boolean\"),\n      default: false,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n  },\n  visitor: [\"decorators\", \"key\", \"value\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate:\n    !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n      ? undefined\n      : (function () {\n          const pattern = assertNodeType(\n            \"Identifier\",\n            \"Pattern\",\n            \"TSAsExpression\",\n            \"TSSatisfiesExpression\",\n            \"TSNonNullExpression\",\n            \"TSTypeAssertion\",\n          );\n          const expression = assertNodeType(\"Expression\");\n\n          return function (parent, key, node) {\n            const validator = is(\"ObjectPattern\", parent)\n              ? pattern\n              : expression;\n            validator(node, \"value\", node.value);\n          };\n        })(),\n});\n\ndefineType(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: process.env.BABEL_8_BREAKING\n    ? [\"FunctionParameter\", \"PatternLike\"]\n    : [\"FunctionParameter\", \"PatternLike\", \"LVal\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: {\n    ...patternLikeCommon(),\n    argument: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertNodeType(\n              \"Identifier\",\n              \"ArrayPattern\",\n              \"ObjectPattern\",\n              \"MemberExpression\",\n              \"TSAsExpression\",\n              \"TSSatisfiesExpression\",\n              \"TSTypeAssertion\",\n              \"TSNonNullExpression\",\n              // These are not valid in RestElement, but we allow them for backwards compatibility.\n              \"RestElement\",\n              \"AssignmentPattern\",\n            )\n          : assertNodeType(\n              \"Identifier\",\n              \"ArrayPattern\",\n              \"ObjectPattern\",\n              \"MemberExpression\",\n              \"TSAsExpression\",\n              \"TSSatisfiesExpression\",\n              \"TSTypeAssertion\",\n              \"TSNonNullExpression\",\n            ),\n    },\n  },\n  validate:\n    process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n      ? (function (parent: t.ArrayPattern | t.ObjectPattern, key) {\n          const match = /(\\w+)\\[(\\d+)\\]/.exec(key.toString());\n          if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n\n          const [, listKey, index] = match as unknown as [\n            string,\n            keyof typeof parent,\n            string,\n          ];\n          if ((parent[listKey] as t.Node[]).length > +index + 1) {\n            throw new TypeError(\n              `RestElement must be last element of ${listKey}`,\n            );\n          }\n        } satisfies ValidatorImpl)\n      : undefined,\n});\n\ndefineType(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: validateArrayOfType(\"Expression\"),\n  },\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    consequent: validateArrayOfType(\"Statement\"),\n  },\n});\n\ndefineType(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    cases: validateArrayOfType(\"SwitchCase\"),\n  },\n});\n\ndefineType(\"ThisExpression\", {\n  aliases: process.env.BABEL_8_BREAKING\n    ? [\"Expression\", \"TSEntityName\"]\n    : [\"Expression\"],\n});\n\ndefineType(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate:\n        process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n          ? chain(\n              assertNodeType(\"BlockStatement\"),\n              Object.assign(\n                function (node: t.TryStatement) {\n                  // This validator isn't put at the top level because we can run it\n                  // even if this node doesn't have a parent.\n\n                  if (!node.handler && !node.finalizer) {\n                    throw new TypeError(\n                      \"TryStatement expects either a handler or finalizer, or both\",\n                    );\n                  }\n                } satisfies ValidatorImpl,\n                { oneOfNodeTypes: [\"BlockStatement\"] as const },\n              ) satisfies ValidatorOneOfNodeTypes,\n            )\n          : assertNodeType(\"BlockStatement\"),\n    },\n    handler: {\n      optional: true,\n      validate: assertNodeType(\"CatchClause\"),\n    },\n    finalizer: {\n      optional: true,\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n});\n\ndefineType(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true,\n    },\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    operator: {\n      validate: assertOneOf(...UNARY_OPERATORS),\n    },\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"],\n});\n\ndefineType(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false,\n    },\n    argument: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertNodeType(\"Expression\")\n          : assertNodeType(\"Identifier\", \"MemberExpression\"),\n    },\n    operator: {\n      validate: assertOneOf(...UPDATE_OPERATORS),\n    },\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    kind: {\n      validate: assertOneOf(\n        \"var\",\n        \"let\",\n        \"const\",\n        // https://github.com/tc39/proposal-explicit-resource-management\n        \"using\",\n        // https://github.com/tc39/proposal-async-explicit-resource-management\n        \"await using\",\n      ),\n    },\n    declarations: validateArrayOfType(\"VariableDeclarator\"),\n  },\n  validate:\n    process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n      ? (() => {\n          const withoutInit = assertNodeType(\"Identifier\", \"Placeholder\");\n          const constOrLetOrVar = assertNodeType(\n            \"Identifier\",\n            \"ArrayPattern\",\n            \"ObjectPattern\",\n            \"Placeholder\",\n          );\n          const usingOrAwaitUsing = assertNodeType(\n            \"Identifier\",\n            \"VoidPattern\",\n            \"Placeholder\",\n          );\n\n          return function (parent, key, node: t.VariableDeclaration) {\n            const { kind, declarations } = node;\n            const parentIsForX = is(\"ForXStatement\", parent, { left: node });\n            if (parentIsForX) {\n              if (declarations.length !== 1) {\n                throw new TypeError(\n                  `Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`,\n                );\n              }\n            }\n            for (const decl of declarations) {\n              if (kind === \"const\" || kind === \"let\" || kind === \"var\") {\n                if (!parentIsForX && !decl.init) {\n                  withoutInit(decl, \"id\", decl.id);\n                } else {\n                  constOrLetOrVar(decl, \"id\", decl.id);\n                }\n              } else {\n                usingOrAwaitUsing(decl, \"id\", decl.id);\n              }\n            }\n          };\n        })()\n      : undefined,\n});\n\ndefineType(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertNodeType(\"LVal\", \"VoidPattern\")\n          : assertNodeType(\n              \"Identifier\",\n              \"ArrayPattern\",\n              \"ObjectPattern\",\n              \"VoidPattern\",\n            ),\n    },\n    definite: {\n      optional: true,\n      validate: assertValueType(\"boolean\"),\n    },\n    init: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\n// --- ES2015 ---\ndefineType(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\" /* for legacy param decorators */],\n  builder: [\"left\", \"right\"],\n  aliases: process.env.BABEL_8_BREAKING\n    ? [\"FunctionParameter\", \"Pattern\", \"PatternLike\"]\n    : [\"FunctionParameter\", \"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: {\n    ...patternLikeCommon(),\n    left: {\n      validate: assertNodeType(\n        \"Identifier\",\n        \"ObjectPattern\",\n        \"ArrayPattern\",\n        \"MemberExpression\",\n        \"TSAsExpression\",\n        \"TSSatisfiesExpression\",\n        \"TSTypeAssertion\",\n        \"TSNonNullExpression\",\n      ),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    // For TypeScript\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"FunctionParameter\", \"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: {\n    ...patternLikeCommon(),\n    elements: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeOrValueType(\"null\", \"PatternLike\")),\n      ),\n    },\n  },\n});\n\ndefineType(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"typeParameters\", \"params\", \"predicate\", \"returnType\", \"body\"],\n  aliases: [\n    \"Scopable\",\n    \"Function\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Expression\",\n    \"Pureish\",\n  ],\n  fields: {\n    ...functionCommon(),\n    ...functionTypeAnnotationCommon(),\n    expression: {\n      // https://github.com/babel/babylon/issues/505\n      validate: assertValueType(\"boolean\"),\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\", \"Expression\"),\n    },\n    predicate: {\n      validate: assertNodeType(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: validateArrayOfType(\n      \"ClassMethod\",\n      \"ClassPrivateMethod\",\n      \"ClassProperty\",\n      \"ClassPrivateProperty\",\n      \"ClassAccessorProperty\",\n      \"TSDeclareMethod\",\n      \"TSIndexSignature\",\n      \"StaticBlock\",\n    ),\n  },\n});\n\ndefineType(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\n    \"decorators\",\n    \"id\",\n    \"typeParameters\",\n    \"superClass\",\n    process.env.BABEL_8_BREAKING ? \"superTypeArguments\" : \"superTypeParameters\",\n    \"mixins\",\n    \"implements\",\n    \"body\",\n  ],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n    typeParameters: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\n            \"TypeParameterDeclaration\",\n            \"TSTypeParameterDeclaration\",\n          )\n        : assertNodeType(\n            \"TypeParameterDeclaration\",\n            \"TSTypeParameterDeclaration\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"ClassBody\"),\n    },\n    superClass: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n    [process.env.BABEL_8_BREAKING\n      ? \"superTypeArguments\"\n      : \"superTypeParameters\"]: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n    implements: {\n      validate: arrayOfType(\n        // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n        process.env.BABEL_8_BREAKING\n          ? \"TSClassImplements\"\n          : \"TSExpressionWithTypeArguments\",\n        \"ClassImplements\",\n      ),\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    mixins: {\n      validate: assertNodeType(\"InterfaceExtends\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n      // The id may be omitted if this is the child of an\n      // ExportDefaultDeclaration.\n      optional: true,\n    },\n    typeParameters: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\n            \"TypeParameterDeclaration\",\n            \"TSTypeParameterDeclaration\",\n          )\n        : assertNodeType(\n            \"TypeParameterDeclaration\",\n            \"TSTypeParameterDeclaration\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"ClassBody\"),\n    },\n    superClass: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n    [process.env.BABEL_8_BREAKING\n      ? \"superTypeArguments\"\n      : \"superTypeParameters\"]: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n    implements: {\n      validate: arrayOfType(\n        // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n        process.env.BABEL_8_BREAKING\n          ? \"TSClassImplements\"\n          : \"TSExpressionWithTypeArguments\",\n        \"ClassImplements\",\n      ),\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    mixins: {\n      validate: assertNodeType(\"InterfaceExtends\"),\n      optional: true,\n    },\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    abstract: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n  },\n  validate:\n    !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n      ? undefined\n      : (function () {\n          const identifier = assertNodeType(\"Identifier\");\n          return function (parent, key, node) {\n            if (!is(\"ExportDefaultDeclaration\", parent)) {\n              identifier(node, \"id\", node.id);\n            }\n          };\n        })(),\n});\n\nexport const importAttributes = {\n  attributes: {\n    optional: true,\n    validate: arrayOfType(\"ImportAttribute\"),\n  },\n};\nif (!process.env.BABEL_8_BREAKING) {\n  // @ts-expect-error (Babel 7 only)\n  importAttributes.assertions = {\n    deprecated: true,\n    optional: true,\n    validate: arrayOfType(\"ImportAttribute\"),\n  };\n}\n\ndefineType(\"ExportAllDeclaration\", {\n  builder: [\"source\", \"attributes\"],\n  visitor: [\"source\", \"attributes\", \"assertions\"],\n  aliases: [\n    \"Statement\",\n    \"Declaration\",\n    \"ImportOrExportDeclaration\",\n    \"ExportDeclaration\",\n  ],\n  fields: {\n    source: {\n      validate: assertNodeType(\"StringLiteral\"),\n    },\n    exportKind: validateOptional(assertOneOf(\"type\", \"value\")),\n    ...importAttributes,\n  },\n});\n\ndefineType(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\n    \"Statement\",\n    \"Declaration\",\n    \"ImportOrExportDeclaration\",\n    \"ExportDeclaration\",\n  ],\n  fields: {\n    declaration: validateType(\n      \"TSDeclareFunction\",\n      \"FunctionDeclaration\",\n      \"ClassDeclaration\",\n      \"Expression\",\n    ),\n    exportKind: validateOptional(assertOneOf(\"value\")),\n  },\n});\n\ndefineType(\"ExportNamedDeclaration\", {\n  builder: [\"declaration\", \"specifiers\", \"source\", \"attributes\"],\n  visitor: process.env.BABEL_8_BREAKING\n    ? [\"declaration\", \"specifiers\", \"source\", \"attributes\"]\n    : [\"declaration\", \"specifiers\", \"source\", \"attributes\", \"assertions\"],\n  aliases: [\n    \"Statement\",\n    \"Declaration\",\n    \"ImportOrExportDeclaration\",\n    \"ExportDeclaration\",\n  ],\n  fields: {\n    declaration: {\n      optional: true,\n      validate:\n        process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n          ? chain(\n              assertNodeType(\"Declaration\"),\n              Object.assign(\n                function (node: t.ExportNamedDeclaration, key, val) {\n                  // This validator isn't put at the top level because we can run it\n                  // even if this node doesn't have a parent.\n\n                  if (val && node.specifiers.length) {\n                    throw new TypeError(\n                      \"Only declaration or specifiers is allowed on ExportNamedDeclaration\",\n                    );\n                  }\n\n                  // This validator isn't put at the top level because we can run it\n                  // even if this node doesn't have a parent.\n\n                  if (val && node.source) {\n                    throw new TypeError(\n                      \"Cannot export a declaration from a source\",\n                    );\n                  }\n                } satisfies ValidatorImpl,\n                { oneOfNodeTypes: [\"Declaration\"] as const },\n              ) satisfies ValidatorOneOfNodeTypes,\n            )\n          : assertNodeType(\"Declaration\"),\n    },\n    ...importAttributes,\n    specifiers: {\n      default: [],\n      validate: arrayOf(\n        (function () {\n          const sourced = assertNodeType(\n            \"ExportSpecifier\",\n            \"ExportDefaultSpecifier\",\n            \"ExportNamespaceSpecifier\",\n          );\n          const sourceless = assertNodeType(\"ExportSpecifier\");\n\n          if (\n            !process.env.BABEL_8_BREAKING &&\n            !process.env.BABEL_TYPES_8_BREAKING\n          )\n            return sourced;\n\n          return Object.assign(\n            function (node: t.ExportNamedDeclaration, key, val) {\n              const validator = node.source ? sourced : sourceless;\n              validator(node, key, val);\n            } satisfies ValidatorImpl,\n            {\n              oneOfNodeTypes: [\n                \"ExportSpecifier\",\n                \"ExportDefaultSpecifier\",\n                \"ExportNamespaceSpecifier\",\n              ] as const,\n            },\n          ) satisfies ValidatorOneOfNodeTypes;\n        })(),\n      ),\n    },\n    source: {\n      validate: assertNodeType(\"StringLiteral\"),\n      optional: true,\n    },\n    exportKind: validateOptional(assertOneOf(\"type\", \"value\")),\n  },\n});\n\ndefineType(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    exported: {\n      validate: assertNodeType(\"Identifier\", \"StringLiteral\"),\n    },\n    exportKind: {\n      // And TypeScript's \"export { type foo } from\"\n      validate: assertOneOf(\"type\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\n    \"Scopable\",\n    \"Statement\",\n    \"For\",\n    \"BlockParent\",\n    \"Loop\",\n    \"ForXStatement\",\n  ],\n  fields: {\n    left: {\n      validate: (function () {\n        if (\n          !process.env.BABEL_8_BREAKING &&\n          !process.env.BABEL_TYPES_8_BREAKING\n        ) {\n          return assertNodeType(\"VariableDeclaration\", \"LVal\");\n        }\n\n        const declaration = assertNodeType(\"VariableDeclaration\");\n        const lval = assertNodeType(\n          \"Identifier\",\n          \"MemberExpression\",\n          \"ArrayPattern\",\n          \"ObjectPattern\",\n          \"TSAsExpression\",\n          \"TSSatisfiesExpression\",\n          \"TSTypeAssertion\",\n          \"TSNonNullExpression\",\n        );\n\n        return Object.assign(\n          function (node, key, val) {\n            if (is(\"VariableDeclaration\", val)) {\n              declaration(node, key, val);\n            } else {\n              lval(node, key, val);\n            }\n          } satisfies ValidatorImpl,\n          {\n            oneOfNodeTypes: [\n              \"VariableDeclaration\",\n              \"Identifier\",\n              \"MemberExpression\",\n              \"ArrayPattern\",\n              \"ObjectPattern\",\n              \"TSAsExpression\",\n              \"TSSatisfiesExpression\",\n              \"TSTypeAssertion\",\n              \"TSNonNullExpression\",\n            ] as const,\n          },\n        ) satisfies ValidatorOneOfNodeTypes;\n      })(),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n    await: {\n      default: false,\n    },\n  },\n});\n\ndefineType(\"ImportDeclaration\", {\n  builder: [\"specifiers\", \"source\", \"attributes\"],\n  visitor: process.env.BABEL_8_BREAKING\n    ? [\"specifiers\", \"source\", \"attributes\"]\n    : [\"specifiers\", \"source\", \"attributes\", \"assertions\"],\n  aliases: [\"Statement\", \"Declaration\", \"ImportOrExportDeclaration\"],\n  fields: {\n    ...importAttributes,\n    module: {\n      optional: true,\n      validate: assertValueType(\"boolean\"),\n    },\n    phase: {\n      default: null,\n      validate: assertOneOf(\"source\", \"defer\"),\n    },\n    specifiers: validateArrayOfType(\n      \"ImportSpecifier\",\n      \"ImportDefaultSpecifier\",\n      \"ImportNamespaceSpecifier\",\n    ),\n    source: {\n      validate: assertNodeType(\"StringLiteral\"),\n    },\n    importKind: {\n      // Handle TypeScript/Flowtype's extension \"import type foo from\"\n      // TypeScript doesn't support typeof\n      validate: assertOneOf(\"type\", \"typeof\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"ImportSpecifier\", {\n  visitor: [\"imported\", \"local\"],\n  builder: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    imported: {\n      validate: assertNodeType(\"Identifier\", \"StringLiteral\"),\n    },\n    importKind: {\n      // Handle Flowtype's extension \"import {typeof foo} from\"\n      // And TypeScript's \"import { type foo } from\"\n      validate: assertOneOf(\"type\", \"typeof\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ImportExpression\", {\n  visitor: [\"source\", \"options\"],\n  aliases: [\"Expression\"],\n  fields: {\n    phase: {\n      default: null,\n      validate: assertOneOf(\"source\", \"defer\"),\n    },\n    source: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    options: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate:\n        process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n          ? chain(\n              assertNodeType(\"Identifier\"),\n              Object.assign(\n                function (node: t.MetaProperty, key, val) {\n                  let property;\n                  switch (val.name) {\n                    case \"function\":\n                      property = \"sent\";\n                      break;\n                    case \"new\":\n                      property = \"target\";\n                      break;\n                    case \"import\":\n                      property = \"meta\";\n                      break;\n                  }\n                  if (!is(\"Identifier\", node.property, { name: property })) {\n                    throw new TypeError(\"Unrecognised MetaProperty\");\n                  }\n                } satisfies ValidatorImpl,\n                { oneOfNodeTypes: [\"Identifier\"] as const },\n              ) satisfies ValidatorOneOfNodeTypes,\n            )\n          : assertNodeType(\"Identifier\"),\n    },\n    property: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\nexport const classMethodOrPropertyCommon = () => ({\n  abstract: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  accessibility: {\n    validate: assertOneOf(\"public\", \"private\", \"protected\"),\n    optional: true,\n  },\n  static: {\n    default: false,\n  },\n  override: {\n    default: false,\n  },\n  computed: {\n    default: false,\n  },\n  optional: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  key: {\n    validate: chain(\n      (function () {\n        const normal = assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        );\n        const computed = assertNodeType(\"Expression\");\n\n        return function (\n          node: Extract<t.Node, { computed: boolean }>,\n          key,\n          val,\n        ) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        } satisfies ValidatorImpl;\n      })(),\n      assertNodeType(\n        \"Identifier\",\n        \"StringLiteral\",\n        \"NumericLiteral\",\n        \"BigIntLiteral\",\n        \"Expression\",\n      ),\n    ),\n  },\n});\n\nexport const classMethodOrDeclareMethodCommon = () => ({\n  ...functionCommon(),\n  ...classMethodOrPropertyCommon(),\n  params: validateArrayOfType(\"FunctionParameter\", \"TSParameterProperty\"),\n  kind: {\n    validate: assertOneOf(\"get\", \"set\", \"method\", \"constructor\"),\n    default: \"method\",\n  },\n  access: {\n    validate: chain(\n      assertValueType(\"string\"),\n      assertOneOf(\"public\", \"private\", \"protected\"),\n    ),\n    optional: true,\n  },\n  decorators: {\n    validate: arrayOfType(\"Decorator\"),\n    optional: true,\n  },\n});\n\ndefineType(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\n    \"kind\",\n    \"key\",\n    \"params\",\n    \"body\",\n    \"computed\",\n    \"static\",\n    \"generator\",\n    \"async\",\n  ],\n  visitor: [\n    \"decorators\",\n    \"key\",\n    \"typeParameters\",\n    \"params\",\n    \"returnType\",\n    \"body\",\n  ],\n  ...classMethodOrPropertyUnionShapeCommon(),\n  fields: {\n    ...classMethodOrDeclareMethodCommon(),\n    ...functionTypeAnnotationCommon(),\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n});\n\ndefineType(\"ObjectPattern\", {\n  visitor: [\n    \"decorators\" /* for legacy param decorators */,\n    \"properties\",\n    \"typeAnnotation\",\n  ],\n  builder: [\"properties\"],\n  aliases: [\"FunctionParameter\", \"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: {\n    ...patternLikeCommon(),\n    properties: validateArrayOfType(\"RestElement\", \"ObjectProperty\"),\n  },\n});\n\ndefineType(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\n  \"Super\",\n  process.env.BABEL_8_BREAKING\n    ? undefined\n    : {\n        aliases: [\"Expression\"],\n      },\n);\n\ndefineType(\"TaggedTemplateExpression\", {\n  visitor: process.env.BABEL_8_BREAKING\n    ? [\"tag\", \"typeArguments\", \"quasi\"]\n    : [\"tag\", \"typeParameters\", \"quasi\"],\n  builder: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    quasi: {\n      validate: assertNodeType(\"TemplateLiteral\"),\n    },\n    [process.env.BABEL_8_BREAKING ? \"typeArguments\" : \"typeParameters\"]: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: chain(\n        assertShape({\n          raw: {\n            validate: assertValueType(\"string\"),\n          },\n          cooked: {\n            validate: assertValueType(\"string\"),\n            optional: true,\n          },\n        }),\n        function templateElementCookedValidator(node: t.TemplateElement) {\n          const raw = node.value.raw;\n\n          let unterminatedCalled = false;\n\n          const error = () => {\n            // unreachable\n            throw new Error(\"Internal @babel/types error.\");\n          };\n          const { str, firstInvalidLoc } = readStringContents(\n            \"template\",\n            raw,\n            0,\n            0,\n            0,\n            {\n              unterminated() {\n                unterminatedCalled = true;\n              },\n              strictNumericEscape: error,\n              invalidEscapeSequence: error,\n              numericSeparatorInEscapeSequence: error,\n              unexpectedNumericSeparator: error,\n              invalidDigit: error,\n              invalidCodePoint: error,\n            },\n          );\n          if (!unterminatedCalled) throw new Error(\"Invalid raw\");\n\n          node.value.cooked = firstInvalidLoc ? null : str;\n        },\n      ),\n    },\n    tail: {\n      default: false,\n    },\n  },\n});\n\ndefineType(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: validateArrayOfType(\"TemplateElement\"),\n    expressions: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          assertNodeType(\n            \"Expression\",\n            // For TypeScript template literal types\n            \"TSType\",\n          ),\n        ),\n        function (node: t.TemplateLiteral, key, val) {\n          if (node.quasis.length !== val.length + 1) {\n            throw new TypeError(\n              `Number of ${\n                node.type\n              } quasis should be exactly one more than the number of expressions.\\nExpected ${\n                val.length + 1\n              } quasis but got ${node.quasis.length}`,\n            );\n          }\n        } satisfies ValidatorImpl,\n      ),\n    },\n  },\n});\n\ndefineType(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate:\n        process.env.BABEL_8_BREAKING || process.env.BABEL_TYPES_8_BREAKING\n          ? chain(\n              assertValueType(\"boolean\"),\n              Object.assign(\n                function (node: t.YieldExpression, key, val) {\n                  if (val && !node.argument) {\n                    throw new TypeError(\n                      \"Property delegate of YieldExpression cannot be true if there is no argument\",\n                    );\n                  }\n                } satisfies ValidatorImpl,\n                { type: \"boolean\" as const },\n              ) satisfies ValidatorType,\n            )\n          : assertValueType(\"boolean\"),\n      default: false,\n    },\n    argument: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\n// --- ES2017 ---\ndefineType(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\n// --- ES2019 ---\ndefineType(\"Import\", {\n  aliases: [\"Expression\"],\n});\n\n// --- ES2020 ---\ndefineType(\"BigIntLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertValueType(\"bigint\")\n        : assertValueType(\"string\"),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"OptionalMemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  // todo: Add OptionalMemberExpression to LVal when optional-chaining-assign reaches stage 4\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    property: {\n      validate: (function () {\n        const normal = assertNodeType(\"Identifier\");\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: ValidatorOneOfNodeTypes = Object.assign(\n          function (node: t.OptionalMemberExpression, key, val) {\n            const validator = node.computed ? computed : normal;\n            validator(node, key, val);\n          } satisfies ValidatorImpl,\n          // todo(ts): can be discriminated union by `computed` property\n          { oneOfNodeTypes: [\"Expression\", \"Identifier\"] as const },\n        );\n        return validator;\n      })(),\n    },\n    computed: {\n      default: false,\n    },\n    optional: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertValueType(\"boolean\")\n          : chain(assertValueType(\"boolean\"), assertOptionalChainStart()),\n    },\n  },\n});\n\ndefineType(\"OptionalCallExpression\", {\n  visitor: process.env.BABEL_8_BREAKING\n    ? [\"callee\", \"typeArguments\", \"arguments\"]\n    : [\"callee\", \"typeParameters\", \"typeArguments\", \"arguments\"],\n  builder: [\"callee\", \"arguments\", \"optional\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    arguments: validateArrayOfType(\n      \"Expression\",\n      \"SpreadElement\",\n      \"ArgumentPlaceholder\",\n    ),\n    optional: {\n      validate:\n        !process.env.BABEL_8_BREAKING && !process.env.BABEL_TYPES_8_BREAKING\n          ? assertValueType(\"boolean\")\n          : chain(assertValueType(\"boolean\"), assertOptionalChainStart()),\n    },\n    typeArguments: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\n            \"TypeParameterInstantiation\",\n            \"TSTypeParameterInstantiation\",\n          )\n        : assertNodeType(\"TypeParameterInstantiation\"),\n      optional: true,\n    },\n    ...(process.env.BABEL_8_BREAKING\n      ? {}\n      : {\n          typeParameters: {\n            validate: assertNodeType(\"TSTypeParameterInstantiation\"),\n            optional: true,\n          },\n        }),\n  },\n});\n\n// --- ES2022 ---\ndefineType(\"ClassProperty\", {\n  visitor: [\"decorators\", \"variance\", \"key\", \"typeAnnotation\", \"value\"],\n  builder: [\n    \"key\",\n    \"value\",\n    \"typeAnnotation\",\n    \"decorators\",\n    \"computed\",\n    \"static\",\n  ],\n  aliases: [\"Property\"],\n  ...classMethodOrPropertyUnionShapeCommon(),\n  fields: {\n    ...classMethodOrPropertyCommon(),\n    value: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    definite: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    typeAnnotation: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n        : assertNodeType(\n            \"TypeAnnotation\",\n            \"TSTypeAnnotation\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    variance: {\n      validate: assertNodeType(\"Variance\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassAccessorProperty\", {\n  visitor: [\"decorators\", \"key\", \"typeAnnotation\", \"value\"],\n  builder: [\n    \"key\",\n    \"value\",\n    \"typeAnnotation\",\n    \"decorators\",\n    \"computed\",\n    \"static\",\n  ],\n  aliases: [\"Property\", \"Accessor\"],\n  ...classMethodOrPropertyUnionShapeCommon(true),\n  fields: {\n    ...classMethodOrPropertyCommon(),\n    key: {\n      validate: chain(\n        (function () {\n          const normal = assertNodeType(\n            \"Identifier\",\n            \"StringLiteral\",\n            \"NumericLiteral\",\n            \"BigIntLiteral\",\n            \"PrivateName\",\n          );\n          const computed = assertNodeType(\"Expression\");\n\n          return function (\n            node: t.ClassAccessorProperty,\n            key: string,\n            val: any,\n          ) {\n            const validator = node.computed ? computed : normal;\n            validator(node, key, val);\n          } satisfies ValidatorImpl;\n        })(),\n        assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n          \"Expression\",\n          \"PrivateName\",\n        ),\n      ),\n    },\n    value: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    definite: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    typeAnnotation: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n        : assertNodeType(\n            \"TypeAnnotation\",\n            \"TSTypeAnnotation\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    variance: {\n      validate: assertNodeType(\"Variance\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassPrivateProperty\", {\n  visitor: [\"decorators\", \"variance\", \"key\", \"typeAnnotation\", \"value\"],\n  builder: [\"key\", \"value\", \"decorators\", \"static\"],\n  aliases: [\"Property\", \"Private\"],\n  fields: {\n    key: {\n      validate: assertNodeType(\"PrivateName\"),\n    },\n    value: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    typeAnnotation: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n        : assertNodeType(\n            \"TypeAnnotation\",\n            \"TSTypeAnnotation\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    static: {\n      validate: assertValueType(\"boolean\"),\n      default: false,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    optional: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    definite: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    variance: {\n      validate: assertNodeType(\"Variance\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassPrivateMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"static\"],\n  visitor: [\n    \"decorators\",\n    \"key\",\n    \"typeParameters\",\n    \"params\",\n    \"returnType\",\n    \"body\",\n  ],\n  aliases: [\n    \"Function\",\n    \"Scopable\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Method\",\n    \"Private\",\n  ],\n  // `computed` is not included in the `builder`\n  // ...classMethodOrPropertyUnionShapeCommon(),\n  fields: {\n    ...classMethodOrDeclareMethodCommon(),\n    ...functionTypeAnnotationCommon(),\n    kind: {\n      validate: assertOneOf(\"get\", \"set\", \"method\"),\n      default: \"method\",\n    },\n    key: {\n      validate: assertNodeType(\"PrivateName\"),\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n});\n\ndefineType(\"PrivateName\", {\n  visitor: [\"id\"],\n  aliases: [\"Private\"],\n  fields: {\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"StaticBlock\", {\n  visitor: [\"body\"],\n  fields: {\n    body: validateArrayOfType(\"Statement\"),\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"FunctionParent\"],\n});\n\n// --- ES2025 ---\ndefineType(\"ImportAttribute\", {\n  visitor: [\"key\", \"value\"],\n  fields: {\n    key: {\n      validate: assertNodeType(\"Identifier\", \"StringLiteral\"),\n    },\n    value: {\n      validate: assertNodeType(\"StringLiteral\"),\n    },\n  },\n});\n"],"mappings":"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","ignoreList":[]}
node_modules/playwright-core/lib/vite/traceViewer/assets/defaultSettingsView-CJSZINFr.js:110:`:return"\\n";case"\r":return"\\r";case"	":return"\\t";default:return"\\x"+e.charCodeAt(0).toString(16).padStart(2,"0")}})+'"':n}function Vb(n){return!!(n.length===0||/^\s|\s$/.test(n)||/[\x00-\x08\x0b\x0c\x0e-\x1f\x7f-\x9f]/.test(n)||/^-/.test(n)||/[\n:](\s|$)/.test(n)||/\s#/.test(n)||/[\n\r]/.test(n)||/^[&*\],?!>|@"'#%]/.test(n)||/[{}`]/.test(n)||/^\[/.test(n)||!isNaN(Number(n))||["y","n","yes","no","true","false","on","off","null"].includes(n.toLowerCase()))}let Gb={};function FT(n){Gb=n}function il(n,e){for(;e;){if(n.contains(e))return!0;e=Yb(e)}return!1}function bt(n){if(n.parentElement)return n.parentElement;if(n.parentNode&&n.parentNode.nodeType===11&&n.parentNode.host)return n.parentNode.host}function Kb(n){let e=n;for(;e.parentNode;)e=e.parentNode;if(e.nodeType===11||e.nodeType===9)return e}function Yb(n){for(;n.parentElement;)n=n.parentElement;return bt(n)}function $a(n,e,i){for(;n;){const r=n.closest(e);if(i&&r!==i&&(r!=null&&r.contains(i)))return;if(r)return r;n=Yb(n)}}function zi(n,e){const i=e==="::before"?rd:e==="::after"?ad:sd;if(i&&i.has(n))return i.get(n);const r=n.ownerDocument&&n.ownerDocument.defaultView?n.ownerDocument.defaultView.getComputedStyle(n,e):void 0;return i==null||i.set(n,r),r}function Xb(n,e){if(e=e??zi(n),!e)return!0;if(Element.prototype.checkVisibility&&Gb.browserNameForWorkarounds!=="webkit"){if(!n.checkVisibility())return!1}else{const i=n.closest("details,summary");if(i!==n&&(i==null?void 0:i.nodeName)==="DETAILS"&&!i.open)return!1}return e.visibility==="visible"}function cc(n){const e=zi(n);if(!e)return{visible:!0,inline:!1};const i=e.cursor;if(e.display==="contents"){for(let l=n.firstChild;l;l=l.nextSibling){if(l.nodeType===1&&ji(l))return{visible:!0,inline:!1,cursor:i};if(l.nodeType===3&&Fb(l))return{visible:!0,inline:!0,cursor:i}}return{visible:!1,inline:!1,cursor:i}}if(!Xb(n,e))return{cursor:i,visible:!1,inline:!1};const r=n.getBoundingClientRect();return{cursor:i,visible:r.width>0&&r.height>0,inline:e.display==="inline"}}function ji(n){return cc(n).visible}function Fb(n){const e=n.ownerDocument.createRange();e.selectNode(n);const i=e.getBoundingClientRect();return i.width>0&&i.height>0}function Xe(n){const e=n.tagName;return typeof e=="string"?e.toUpperCase():n instanceof HTMLFormElement?"FORM":n.tagName.toUpperCase()}let sd,rd,ad,Qb=0;function ld(){++Qb,sd??(sd=new Map),rd??(rd=new Map),ad??(ad=new Map)}function od(){--Qb||(sd=void 0,rd=void 0,ad=void 0)}function p0(n){return n.hasAttribute("aria-label")||n.hasAttribute("aria-labelledby")}const g0="article:not([role]), aside:not([role]), main:not([role]), nav:not([role]), section:not([role]), [role=article], [role=complementary], [role=main], [role=navigation], [role=region]",QT=[["aria-atomic",void 0],["aria-busy",void 0],["aria-controls",void 0],["aria-current",void 0],["aria-describedby",void 0],["aria-details",void 0],["aria-dropeffect",void 0],["aria-flowto",void 0],["aria-grabbed",void 0],["aria-hidden",void 0],["aria-keyshortcuts",void 0],["aria-label",["caption","code","deletion","emphasis","generic","insertion","paragraph","presentation","strong","subscript","superscript"]],["aria-labelledby",["caption","code","deletion","emphasis","generic","insertion","paragraph","presentation","strong","subscript","superscript"]],["aria-live",void 0],["aria-owns",void 0],["aria-relevant",void 0],["aria-roledescription",["generic"]]];function Jb(n,e){return QT.some(([i,r])=>!(r!=null&&r.includes(e||""))&&n.hasAttribute(i))}function Pb(n){return!Number.isNaN(Number(String(n.getAttribute("tabindex"))))}function JT(n){return!cv(n)&&(PT(n)||Pb(n))}function PT(n){const e=Xe(n);return["BUTTON","DETAILS","SELECT","TEXTAREA"].includes(e)?!0:e==="A"||e==="AREA"?n.hasAttribute("href"):e==="INPUT"?!n.hidden:!1}const uh={A:n=>n.hasAttribute("href")?"link":null,AREA:n=>n.hasAttribute("href")?"link":null,ARTICLE:()=>"article",ASIDE:()=>"complementary",BLOCKQUOTE:()=>"blockquote",BUTTON:()=>"button",CAPTION:()=>"caption",CODE:()=>"code",DATALIST:()=>"listbox",DD:()=>"definition",DEL:()=>"deletion",DETAILS:()=>"group",DFN:()=>"term",DIALOG:()=>"dialog",DT:()=>"term",EM:()=>"emphasis",FIELDSET:()=>"group",FIGURE:()=>"figure",FOOTER:n=>$a(n,g0)?null:"contentinfo",FORM:n=>p0(n)?"form":null,H1:()=>"heading",H2:()=>"heading",H3:()=>"heading",H4:()=>"heading",H5:()=>"heading",H6:()=>"heading",HEADER:n=>$a(n,g0)?null:"banner",HR:()=>"separator",HTML:()=>"document",IMG:n=>n.getAttribute("alt")===""&&!n.getAttribute("title")&&!Jb(n)&&!Pb(n)?"presentation":"img",INPUT:n=>{const e=n.type.toLowerCase();if(e==="search")return n.hasAttribute("list")?"combobox":"searchbox";if(["email","tel","text","url",""].includes(e)){const i=Nr(n,n.getAttribute("list"))[0];return i&&Xe(i)==="DATALIST"?"combobox":"textbox"}return e==="hidden"?null:e==="file"?"button":dE[e]||"textbox"},INS:()=>"insertion",LI:()=>"listitem",MAIN:()=>"main",MARK:()=>"mark",MATH:()=>"math",MENU:()=>"list",METER:()=>"meter",NAV:()=>"navigation",OL:()=>"list",OPTGROUP:()=>"group",OPTION:()=>"option",OUTPUT:()=>"status",P:()=>"paragraph",PROGRESS:()=>"progressbar",SEARCH:()=>"search",SECTION:n=>p0(n)?"region":null,SELECT:n=>n.hasAttribute("multiple")||n.size>1?"listbox":"combobox",STRONG:()=>"strong",SUB:()=>"subscript",SUP:()=>"superscript",SVG:()=>"img",TABLE:()=>"table",TBODY:()=>"rowgroup",TD:n=>{const e=$a(n,"table"),i=e?cd(e):"";return i==="grid"||i==="treegrid"?"gridcell":"cell"},TEXTAREA:()=>"textbox",TFOOT:()=>"rowgroup",TH:n=>{const e=n.getAttribute("scope");if(e==="col"||e==="colgroup")return"columnheader";if(e==="row"||e==="rowgroup")return"rowheader";const i=n.nextElementSibling,r=n.previousElementSibling,l=n.parentElement&&Xe(n.parentElement)==="TR"?n.parentElement:void 0;if(!i&&!r){if(l){const o=$a(l,"table");if(o&&o.rows.length<=1)return null}return"columnheader"}return m0(i)&&m0(r)?"columnheader":y0(i)||y0(r)?"rowheader":"columnheader"},THEAD:()=>"rowgroup",TIME:()=>"time",TR:()=>"row",UL:()=>"list"};function m0(n){return!!n&&Xe(n)==="TH"}function y0(n){var e;return!n||Xe(n)!=="TD"?!1:!!((e=n.textContent)!=null&&e.trim()||n.children.length>0)}const ZT={DD:["DL","DIV"],DIV:["DL"],DT:["DL","DIV"],LI:["OL","UL"],TBODY:["TABLE"],TD:["TR"],TFOOT:["TABLE"],TH:["TR"],THEAD:["TABLE"],TR:["THEAD","TBODY","TFOOT","TABLE"]};function b0(n){var r;const e=((r=uh[Xe(n)])==null?void 0:r.call(uh,n))||"";if(!e)return null;let i=n;for(;i;){const l=bt(i),o=ZT[Xe(i)];if(!o||!l||!o.includes(Xe(l)))break;const u=cd(l);if((u==="none"||u==="presentation")&&!Zb(l,u))return u;i=l}return e}const WT=["alert","alertdialog","application","article","banner","blockquote","button","caption","cell","checkbox","code","columnheader","combobox","complementary","contentinfo","definition","deletion","dialog","directory","document","emphasis","feed","figure","form","generic","grid","gridcell","group","heading","img","insertion","link","list","listbox","listitem","log","main","mark","marquee","math","meter","menu","menubar","menuitem","menuitemcheckbox","menuitemradio","navigation","none","note","option","paragraph","presentation","progressbar","radio","radiogroup","region","row","rowgroup","rowheader","scrollbar","search","searchbox","separator","slider","spinbutton","status","strong","subscript","superscript","switch","tab","table","tablist","tabpanel","term","textbox","time","timer","toolbar","tooltip","tree","treegrid","treeitem"];function cd(n){return(n.getAttribute("role")||"").split(" ").map(i=>i.trim()).find(i=>WT.includes(i))||null}function Zb(n,e){return Jb(n,e)||JT(n)}function mt(n){const e=cd(n);if(!e)return b0(n);if(e==="none"||e==="presentation"){const i=b0(n);if(Zb(n,i))return i}return e}function Wb(n){return n===null?void 0:n.toLowerCase()==="true"}function ev(n){return["STYLE","SCRIPT","NOSCRIPT","TEMPLATE"].includes(Xe(n))}function ln(n){if(ev(n))return!0;const e=zi(n),i=n.nodeName==="SLOT";if((e==null?void 0:e.display)==="contents"&&!i){for(let l=n.firstChild;l;l=l.nextSibling)if(l.nodeType===1&&!ln(l)||l.nodeType===3&&Fb(l))return!1;return!0}return!(n.nodeName==="OPTION"&&!!n.closest("select"))&&!i&&!Xb(n,e)?!0:tv(n)}function tv(n){let e=Mi==null?void 0:Mi.get(n);if(e===void 0){if(e=!1,n.parentElement&&n.parentElement.shadowRoot&&!n.assignedSlot&&(e=!0),!e){const i=zi(n);e=!i||i.display==="none"||Wb(n.getAttribute("aria-hidden"))===!0}if(!e){const i=bt(n);i&&(e=tv(i))}Mi==null||Mi.set(n,e)}return e}function Nr(n,e){if(!e)return[];const i=Kb(n);if(!i)return[];try{const r=e.split(" ").filter(o=>!!o),l=[];for(const o of r){const u=i.querySelector("#"+CSS.escape(o));u&&!l.includes(u)&&l.push(u)}return l}catch{return[]}}function Pn(n){return n.trim()}function Fa(n){return n.split(" ").map(e=>e.replace(/\r\n/g,`
node_modules/playwright-core/lib/server/helper.js:26:const MAX_LOG_LENGTH = process.env.MAX_LOG_LENGTH ? +process.env.MAX_LOG_LENGTH : Infinity;
node_modules/playwright-core/lib/server/helper.js:80:        if (text.length > MAX_LOG_LENGTH)
node_modules/playwright-core/lib/server/helper.js:81:          text = text.substring(0, MAX_LOG_LENGTH / 2) + " <<<<<( LOG TRUNCATED )>>>>> " + text.substring(text.length - MAX_LOG_LENGTH / 2);
node_modules/@babel/types/lib/definitions/core.js:515:      validate: (0, _utils.assertOneOf)(..._index.LOGICAL_OPERATORS)
node_modules/@babel/types/lib/index.d.ts:2647:declare const LOGICAL_OPERATORS: string[];
node_modules/@babel/types/lib/index.d.ts:3617:export { ACCESSOR_TYPES, ALIAS_KEYS, ASSIGNMENT_OPERATORS, Accessor, Aliases, AnyTypeAnnotation, ArgumentPlaceholder, ArrayExpression, ArrayPattern, ArrayTypeAnnotation, ArrowFunctionExpression, AssignmentExpression, AssignmentPattern, AwaitExpression, BINARY_OPERATORS, BINARY_TYPES, BLOCKPARENT_TYPES, BLOCK_TYPES, BOOLEAN_BINARY_OPERATORS, BOOLEAN_NUMBER_BINARY_OPERATORS, BOOLEAN_UNARY_OPERATORS, BUILDER_KEYS, BigIntLiteral, Binary, BinaryExpression, BindExpression, Block, BlockParent, BlockStatement, BooleanLiteral, BooleanLiteralTypeAnnotation, BooleanTypeAnnotation, BreakStatement, CLASS_TYPES, COMMENT_KEYS, COMPARISON_BINARY_OPERATORS, COMPLETIONSTATEMENT_TYPES, CONDITIONAL_TYPES, CallExpression, CatchClause, Class, ClassAccessorProperty, ClassBody, ClassDeclaration, ClassExpression, ClassImplements, ClassMethod, ClassPrivateMethod, ClassPrivateProperty, ClassProperty, Comment, CommentBlock, CommentLine, CommentTypeShorthand, CompletionStatement, Conditional, ConditionalExpression, ContinueStatement, DECLARATION_TYPES, DEPRECATED_ALIASES, DEPRECATED_KEYS, DebuggerStatement, DecimalLiteral, Declaration, DeclareClass, DeclareExportAllDeclaration, DeclareExportDeclaration, DeclareFunction, DeclareInterface, DeclareModule, DeclareModuleExports, DeclareOpaqueType, DeclareTypeAlias, DeclareVariable, DeclaredPredicate, Decorator, DeprecatedAliases, Directive, DirectiveLiteral, DoExpression, DoWhileStatement, ENUMBODY_TYPES, ENUMMEMBER_TYPES, EQUALITY_BINARY_OPERATORS, EXPORTDECLARATION_TYPES, EXPRESSIONWRAPPER_TYPES, EXPRESSION_TYPES, EmptyStatement, EmptyTypeAnnotation, EnumBody, EnumBooleanBody, EnumBooleanMember, EnumDeclaration, EnumDefaultedMember, EnumMember, EnumNumberBody, EnumNumberMember, EnumStringBody, EnumStringMember, EnumSymbolBody, ExistsTypeAnnotation, ExportAllDeclaration, ExportDeclaration, ExportDefaultDeclaration, ExportDefaultSpecifier, ExportNamedDeclaration, ExportNamespaceSpecifier, ExportSpecifier, Expression, ExpressionStatement, ExpressionWrapper, FLATTENABLE_KEYS, FLIPPED_ALIAS_KEYS, FLOWBASEANNOTATION_TYPES, FLOWDECLARATION_TYPES, FLOWPREDICATE_TYPES, FLOWTYPE_TYPES, FLOW_TYPES, FORXSTATEMENT_TYPES, FOR_INIT_KEYS, FOR_TYPES, FUNCTIONPARAMETER_TYPES, FUNCTIONPARENT_TYPES, FUNCTION_TYPES, FieldOptions, File, Flow, FlowBaseAnnotation, FlowDeclaration, FlowPredicate, FlowType, For, ForInStatement, ForOfStatement, ForStatement, ForXStatement, Function, FunctionDeclaration, FunctionExpression, FunctionParameter, FunctionParent, FunctionTypeAnnotation, FunctionTypeParam, GenericTypeAnnotation, IMMUTABLE_TYPES, IMPORTOREXPORTDECLARATION_TYPES, INHERIT_KEYS, Identifier, IfStatement, Immutable, Import, ImportAttribute, ImportDeclaration, ImportDefaultSpecifier, ImportExpression, ImportNamespaceSpecifier, ImportOrExportDeclaration, ImportSpecifier, IndexedAccessType, InferredPredicate, InterfaceDeclaration, InterfaceExtends, InterfaceTypeAnnotation, InterpreterDirective, IntersectionTypeAnnotation, JSX, JSXAttribute, JSXClosingElement, JSXClosingFragment, JSXElement, JSXEmptyExpression, JSXExpressionContainer, JSXFragment, JSXIdentifier, JSXMemberExpression, JSXNamespacedName, JSXOpeningElement, JSXOpeningFragment, JSXSpreadAttribute, JSXSpreadChild, JSXText, JSX_TYPES, LITERAL_TYPES, LOGICAL_OPERATORS, LOOP_TYPES, LVAL_TYPES, LVal, LabeledStatement, Literal, LogicalExpression, Loop, METHOD_TYPES, MISCELLANEOUS_TYPES, MODULEDECLARATION_TYPES, MODULESPECIFIER_TYPES, MemberExpression, MetaProperty, Method, Miscellaneous, MixedTypeAnnotation, ModuleDeclaration, ModuleExpression, ModuleSpecifier, NODE_FIELDS, NODE_PARENT_VALIDATIONS, NUMBER_BINARY_OPERATORS, NUMBER_UNARY_OPERATORS, NewExpression, Node, Noop, NullLiteral, NullLiteralTypeAnnotation, NullableTypeAnnotation, NumberLiteral$1 as NumberLiteral, NumberLiteralTypeAnnotation, NumberTypeAnnotation, NumericLiteral, OBJECTMEMBER_TYPES, ObjectExpression, ObjectMember, ObjectMethod, ObjectPattern, ObjectProperty, ObjectTypeAnnotation, ObjectTypeCallProperty, ObjectTypeIndexer, ObjectTypeInternalSlot, ObjectTypeProperty, ObjectTypeSpreadProperty, OpaqueType, OptionalCallExpression, OptionalIndexedAccessType, OptionalMemberExpression, PATTERNLIKE_TYPES, PATTERN_TYPES, PLACEHOLDERS, PLACEHOLDERS_ALIAS, PLACEHOLDERS_FLIPPED_ALIAS, PRIVATE_TYPES, PROPERTY_TYPES, PUREISH_TYPES, ParentMaps, ParenthesizedExpression, Pattern, PatternLike, PipelineBareFunction, PipelinePrimaryTopicReference, PipelineTopicExpression, Placeholder, Private, PrivateName, Program, Property, Pureish, QualifiedTypeIdentifier, RecordExpression, RegExpLiteral, RegexLiteral$1 as RegexLiteral, Options$1 as RemovePropertiesOptions, RestElement, RestProperty$1 as RestProperty, ReturnStatement, SCOPABLE_TYPES, STANDARDIZED_TYPES, STATEMENT_OR_BLOCK_KEYS, STATEMENT_TYPES, STRING_UNARY_OPERATORS, Scopable, SequenceExpression, SourceLocation, SpreadElement, SpreadProperty$1 as SpreadProperty, Standardized, Statement, StaticBlock, StringLiteral, StringLiteralTypeAnnotation, StringTypeAnnotation, Super, SwitchCase, SwitchStatement, SymbolTypeAnnotation, TERMINATORLESS_TYPES, TSAnyKeyword, TSArrayType, TSAsExpression, TSBASETYPE_TYPES, TSBaseType, TSBigIntKeyword, TSBooleanKeyword, TSCallSignatureDeclaration, TSConditionalType, TSConstructSignatureDeclaration, TSConstructorType, TSDeclareFunction, TSDeclareMethod, TSENTITYNAME_TYPES, TSEntityName, TSEnumBody, TSEnumDeclaration, TSEnumMember, TSExportAssignment, TSExpressionWithTypeArguments, TSExternalModuleReference, TSFunctionType, TSImportEqualsDeclaration, TSImportType, TSIndexSignature, TSIndexedAccessType, TSInferType, TSInstantiationExpression, TSInterfaceBody, TSInterfaceDeclaration, TSIntersectionType, TSIntrinsicKeyword, TSLiteralType, TSMappedType, TSMethodSignature, TSModuleBlock, TSModuleDeclaration, TSNamedTupleMember, TSNamespaceExportDeclaration, TSNeverKeyword, TSNonNullExpression, TSNullKeyword, TSNumberKeyword, TSObjectKeyword, TSOptionalType, TSParameterProperty, TSParenthesizedType, TSPropertySignature, TSQualifiedName, TSRestType, TSSatisfiesExpression, TSStringKeyword, TSSymbolKeyword, TSTYPEELEMENT_TYPES, TSTYPE_TYPES, TSTemplateLiteralType, TSThisType, TSTupleType, TSType, TSTypeAliasDeclaration, TSTypeAnnotation, TSTypeAssertion, TSTypeElement, TSTypeLiteral, TSTypeOperator, TSTypeParameter, TSTypeParameterDeclaration, TSTypeParameterInstantiation, TSTypePredicate, TSTypeQuery, TSTypeReference, TSUndefinedKeyword, TSUnionType, TSUnknownKeyword, TSVoidKeyword, TYPES, TYPESCRIPT_TYPES, TaggedTemplateExpression, TemplateElement, TemplateLiteral, Terminatorless, ThisExpression, ThisTypeAnnotation, ThrowStatement, TopicReference, TraversalAncestors, TraversalHandler, TraversalHandlers, TryStatement, TupleExpression, TupleTypeAnnotation, TypeAlias, TypeAnnotation, TypeCastExpression, TypeParameter, TypeParameterDeclaration, TypeParameterInstantiation, TypeScript, TypeofTypeAnnotation, UNARYLIKE_TYPES, UNARY_OPERATORS, UPDATE_OPERATORS, USERWHITESPACABLE_TYPES, UnaryExpression, UnaryLike, UnionTypeAnnotation, UpdateExpression, UserWhitespacable, V8IntrinsicIdentifier, VISITOR_KEYS, VariableDeclaration, VariableDeclarator, Variance, VoidPattern, VoidTypeAnnotation, WHILE_TYPES, While, WhileStatement, WithStatement, YieldExpression, deprecationWarning as __internal__deprecationWarning, addComment, addComments, anyTypeAnnotation, appendToMemberExpression, argumentPlaceholder, arrayExpression, arrayPattern, arrayTypeAnnotation, arrowFunctionExpression, assertAccessor, assertAnyTypeAnnotation, assertArgumentPlaceholder, assertArrayExpression, assertArrayPattern, assertArrayTypeAnnotation, assertArrowFunctionExpression, assertAssignmentExpression, assertAssignmentPattern, assertAwaitExpression, assertBigIntLiteral, assertBinary, assertBinaryExpression, assertBindExpression, assertBlock, assertBlockParent, assertBlockStatement, assertBooleanLiteral, assertBooleanLiteralTypeAnnotation, assertBooleanTypeAnnotation, assertBreakStatement, assertCallExpression, assertCatchClause, assertClass, assertClassAccessorProperty, assertClassBody, assertClassDeclaration, assertClassExpression, assertClassImplements, assertClassMethod, assertClassPrivateMethod, assertClassPrivateProperty, assertClassProperty, assertCompletionStatement, assertConditional, assertConditionalExpression, assertContinueStatement, assertDebuggerStatement, assertDecimalLiteral, assertDeclaration, assertDeclareClass, assertDeclareExportAllDeclaration, assertDeclareExportDeclaration, assertDeclareFunction, assertDeclareInterface, assertDeclareModule, assertDeclareModuleExports, assertDeclareOpaqueType, assertDeclareTypeAlias, assertDeclareVariable, assertDeclaredPredicate, assertDecorator, assertDirective, assertDirectiveLiteral, assertDoExpression, assertDoWhileStatement, assertEmptyStatement, assertEmptyTypeAnnotation, assertEnumBody, assertEnumBooleanBody, assertEnumBooleanMember, assertEnumDeclaration, assertEnumDefaultedMember, assertEnumMember, assertEnumNumberBody, assertEnumNumberMember, assertEnumStringBody, assertEnumStringMember, assertEnumSymbolBody, assertExistsTypeAnnotation, assertExportAllDeclaration, assertExportDeclaration, assertExportDefaultDeclaration, assertExportDefaultSpecifier, assertExportNamedDeclaration, assertExportNamespaceSpecifier, assertExportSpecifier, assertExpression, assertExpressionStatement, assertExpressionWrapper, assertFile, assertFlow, assertFlowBaseAnnotation, assertFlowDeclaration, assertFlowPredicate, assertFlowType, assertFor, assertForInStatement, assertForOfStatement, assertForStatement, assertForXStatement, assertFunction, assertFunctionDeclaration, assertFunctionExpression, assertFunctionParameter, assertFunctionParent, assertFunctionTypeAnnotation, assertFunctionTypeParam, assertGenericTypeAnnotation, assertIdentifier, assertIfStatement, assertImmutable, assertImport, assertImportAttribute, assertImportDeclaration, assertImportDefaultSpecifier, assertImportExpression, assertImportNamespaceSpecifier, assertImportOrExportDeclaration, assertImportSpecifier, assertIndexedAccessType, assertInferredPredicate, assertInterfaceDeclaration, assertInterfaceExtends, assertInterfaceTypeAnnotation, assertInterpreterDirective, assertIntersectionTypeAnnotation, assertJSX, assertJSXAttribute, assertJSXClosingElement, assertJSXClosingFragment, assertJSXElement, assertJSXEmptyExpression, assertJSXExpressionContainer, assertJSXFragment, assertJSXIdentifier, assertJSXMemberExpression, assertJSXNamespacedName, assertJSXOpeningElement, assertJSXOpeningFragment, assertJSXSpreadAttribute, assertJSXSpreadChild, assertJSXText, assertLVal, assertLabeledStatement, assertLiteral, assertLogicalExpression, assertLoop, assertMemberExpression, assertMetaProperty, assertMethod, assertMiscellaneous, assertMixedTypeAnnotation, assertModuleDeclaration, assertModuleExpression, assertModuleSpecifier, assertNewExpression, assertNode, assertNoop, assertNullLiteral, assertNullLiteralTypeAnnotation, assertNullableTypeAnnotation, assertNumberLiteral, assertNumberLiteralTypeAnnotation, assertNumberTypeAnnotation, assertNumericLiteral, assertObjectExpression, assertObjectMember, assertObjectMethod, assertObjectPattern, assertObjectProperty, assertObjectTypeAnnotation, assertObjectTypeCallProperty, assertObjectTypeIndexer, assertObjectTypeInternalSlot, assertObjectTypeProperty, assertObjectTypeSpreadProperty, assertOpaqueType, assertOptionalCallExpression, assertOptionalIndexedAccessType, assertOptionalMemberExpression, assertParenthesizedExpression, assertPattern, assertPatternLike, assertPipelineBareFunction, assertPipelinePrimaryTopicReference, assertPipelineTopicExpression, assertPlaceholder, assertPrivate, assertPrivateName, assertProgram, assertProperty, assertPureish, assertQualifiedTypeIdentifier, assertRecordExpression, assertRegExpLiteral, assertRegexLiteral, assertRestElement, assertRestProperty, assertReturnStatement, assertScopable, assertSequenceExpression, assertSpreadElement, assertSpreadProperty, assertStandardized, assertStatement, assertStaticBlock, assertStringLiteral, assertStringLiteralTypeAnnotation, assertStringTypeAnnotation, assertSuper, assertSwitchCase, assertSwitchStatement, assertSymbolTypeAnnotation, assertTSAnyKeyword, assertTSArrayType, assertTSAsExpression, assertTSBaseType, assertTSBigIntKeyword, assertTSBooleanKeyword, assertTSCallSignatureDeclaration, assertTSConditionalType, assertTSConstructSignatureDeclaration, assertTSConstructorType, assertTSDeclareFunction, assertTSDeclareMethod, assertTSEntityName, assertTSEnumBody, assertTSEnumDeclaration, assertTSEnumMember, assertTSExportAssignment, assertTSExpressionWithTypeArguments, assertTSExternalModuleReference, assertTSFunctionType, assertTSImportEqualsDeclaration, assertTSImportType, assertTSIndexSignature, assertTSIndexedAccessType, assertTSInferType, assertTSInstantiationExpression, assertTSInterfaceBody, assertTSInterfaceDeclaration, assertTSIntersectionType, assertTSIntrinsicKeyword, assertTSLiteralType, assertTSMappedType, assertTSMethodSignature, assertTSModuleBlock, assertTSModuleDeclaration, assertTSNamedTupleMember, assertTSNamespaceExportDeclaration, assertTSNeverKeyword, assertTSNonNullExpression, assertTSNullKeyword, assertTSNumberKeyword, assertTSObjectKeyword, assertTSOptionalType, assertTSParameterProperty, assertTSParenthesizedType, assertTSPropertySignature, assertTSQualifiedName, assertTSRestType, assertTSSatisfiesExpression, assertTSStringKeyword, assertTSSymbolKeyword, assertTSTemplateLiteralType, assertTSThisType, assertTSTupleType, assertTSType, assertTSTypeAliasDeclaration, assertTSTypeAnnotation, assertTSTypeAssertion, assertTSTypeElement, assertTSTypeLiteral, assertTSTypeOperator, assertTSTypeParameter, assertTSTypeParameterDeclaration, assertTSTypeParameterInstantiation, assertTSTypePredicate, assertTSTypeQuery, assertTSTypeReference, assertTSUndefinedKeyword, assertTSUnionType, assertTSUnknownKeyword, assertTSVoidKeyword, assertTaggedTemplateExpression, assertTemplateElement, assertTemplateLiteral, assertTerminatorless, assertThisExpression, assertThisTypeAnnotation, assertThrowStatement, assertTopicReference, assertTryStatement, assertTupleExpression, assertTupleTypeAnnotation, assertTypeAlias, assertTypeAnnotation, assertTypeCastExpression, assertTypeParameter, assertTypeParameterDeclaration, assertTypeParameterInstantiation, assertTypeScript, assertTypeofTypeAnnotation, assertUnaryExpression, assertUnaryLike, assertUnionTypeAnnotation, assertUpdateExpression, assertUserWhitespacable, assertV8IntrinsicIdentifier, assertVariableDeclaration, assertVariableDeclarator, assertVariance, assertVoidPattern, assertVoidTypeAnnotation, assertWhile, assertWhileStatement, assertWithStatement, assertYieldExpression, assignmentExpression, assignmentPattern, awaitExpression, bigIntLiteral, binaryExpression, bindExpression, blockStatement, booleanLiteral, booleanLiteralTypeAnnotation, booleanTypeAnnotation, breakStatement, buildMatchMemberExpression, buildUndefinedNode, callExpression, catchClause, classAccessorProperty, classBody, classDeclaration, classExpression, classImplements, classMethod, classPrivateMethod, classPrivateProperty, classProperty, clone, cloneDeep, cloneDeepWithoutLoc, cloneNode, cloneWithoutLoc, conditionalExpression, continueStatement, createFlowUnionType, createTSUnionType, _default$4 as createTypeAnnotationBasedOnTypeof, createFlowUnionType as createUnionTypeAnnotation, debuggerStatement, decimalLiteral, declareClass, declareExportAllDeclaration, declareExportDeclaration, declareFunction, declareInterface, declareModule, declareModuleExports, declareOpaqueType, declareTypeAlias, declareVariable, declaredPredicate, decorator, directive, directiveLiteral, doExpression, doWhileStatement, emptyStatement, emptyTypeAnnotation, ensureBlock, enumBooleanBody, enumBooleanMember, enumDeclaration, enumDefaultedMember, enumNumberBody, enumNumberMember, enumStringBody, enumStringMember, enumSymbolBody, existsTypeAnnotation, exportAllDeclaration, exportDefaultDeclaration, exportDefaultSpecifier, exportNamedDeclaration, exportNamespaceSpecifier, exportSpecifier, expressionStatement, file, forInStatement, forOfStatement, forStatement, functionDeclaration, functionExpression, functionTypeAnnotation, functionTypeParam, genericTypeAnnotation, getAssignmentIdentifiers, getBindingIdentifiers, getFunctionName, _default as getOuterBindingIdentifiers, identifier, ifStatement, _import as import, importAttribute, importDeclaration, importDefaultSpecifier, importExpression, importNamespaceSpecifier, importSpecifier, indexedAccessType, inferredPredicate, inheritInnerComments, inheritLeadingComments, inheritTrailingComments, inherits, inheritsComments, interfaceDeclaration, interfaceExtends, interfaceTypeAnnotation, interpreterDirective, intersectionTypeAnnotation, is, isAccessor, isAnyTypeAnnotation, isArgumentPlaceholder, isArrayExpression, isArrayPattern, isArrayTypeAnnotation, isArrowFunctionExpression, isAssignmentExpression, isAssignmentPattern, isAwaitExpression, isBigIntLiteral, isBinary, isBinaryExpression, isBindExpression, isBinding, isBlock, isBlockParent, isBlockScoped, isBlockStatement, isBooleanLiteral, isBooleanLiteralTypeAnnotation, isBooleanTypeAnnotation, isBreakStatement, isCallExpression, isCatchClause, isClass, isClassAccessorProperty, isClassBody, isClassDeclaration, isClassExpression, isClassImplements, isClassMethod, isClassPrivateMethod, isClassPrivateProperty, isClassProperty, isCompletionStatement, isConditional, isConditionalExpression, isContinueStatement, isDebuggerStatement, isDecimalLiteral, isDeclaration, isDeclareClass, isDeclareExportAllDeclaration, isDeclareExportDeclaration, isDeclareFunction, isDeclareInterface, isDeclareModule, isDeclareModuleExports, isDeclareOpaqueType, isDeclareTypeAlias, isDeclareVariable, isDeclaredPredicate, isDecorator, isDirective, isDirectiveLiteral, isDoExpression, isDoWhileStatement, isEmptyStatement, isEmptyTypeAnnotation, isEnumBody, isEnumBooleanBody, isEnumBooleanMember, isEnumDeclaration, isEnumDefaultedMember, isEnumMember, isEnumNumberBody, isEnumNumberMember, isEnumStringBody, isEnumStringMember, isEnumSymbolBody, isExistsTypeAnnotation, isExportAllDeclaration, isExportDeclaration, isExportDefaultDeclaration, isExportDefaultSpecifier, isExportNamedDeclaration, isExportNamespaceSpecifier, isExportSpecifier, isExpression, isExpressionStatement, isExpressionWrapper, isFile, isFlow, isFlowBaseAnnotation, isFlowDeclaration, isFlowPredicate, isFlowType, isFor, isForInStatement, isForOfStatement, isForStatement, isForXStatement, isFunction, isFunctionDeclaration, isFunctionExpression, isFunctionParameter, isFunctionParent, isFunctionTypeAnnotation, isFunctionTypeParam, isGenericTypeAnnotation, isIdentifier, isIfStatement, isImmutable, isImport, isImportAttribute, isImportDeclaration, isImportDefaultSpecifier, isImportExpression, isImportNamespaceSpecifier, isImportOrExportDeclaration, isImportSpecifier, isIndexedAccessType, isInferredPredicate, isInterfaceDeclaration, isInterfaceExtends, isInterfaceTypeAnnotation, isInterpreterDirective, isIntersectionTypeAnnotation, isJSX, isJSXAttribute, isJSXClosingElement, isJSXClosingFragment, isJSXElement, isJSXEmptyExpression, isJSXExpressionContainer, isJSXFragment, isJSXIdentifier, isJSXMemberExpression, isJSXNamespacedName, isJSXOpeningElement, isJSXOpeningFragment, isJSXSpreadAttribute, isJSXSpreadChild, isJSXText, isLVal, isLabeledStatement, isLet, isLiteral, isLogicalExpression, isLoop, isMemberExpression, isMetaProperty, isMethod, isMiscellaneous, isMixedTypeAnnotation, isModuleDeclaration, isModuleExpression, isModuleSpecifier, isNewExpression, isNode, isNodesEquivalent, isNoop, isNullLiteral, isNullLiteralTypeAnnotation, isNullableTypeAnnotation, isNumberLiteral, isNumberLiteralTypeAnnotation, isNumberTypeAnnotation, isNumericLiteral, isObjectExpression, isObjectMember, isObjectMethod, isObjectPattern, isObjectProperty, isObjectTypeAnnotation, isObjectTypeCallProperty, isObjectTypeIndexer, isObjectTypeInternalSlot, isObjectTypeProperty, isObjectTypeSpreadProperty, isOpaqueType, isOptionalCallExpression, isOptionalIndexedAccessType, isOptionalMemberExpression, isParenthesizedExpression, isPattern, isPatternLike, isPipelineBareFunction, isPipelinePrimaryTopicReference, isPipelineTopicExpression, isPlaceholder, isPlaceholderType, isPrivate, isPrivateName, isProgram, isProperty, isPureish, isQualifiedTypeIdentifier, isRecordExpression, isReferenced, isRegExpLiteral, isRegexLiteral, isRestElement, isRestProperty, isReturnStatement, isScopable, isScope, isSequenceExpression, isSpecifierDefault, isSpreadElement, isSpreadProperty, isStandardized, isStatement, isStaticBlock, isStringLiteral, isStringLiteralTypeAnnotation, isStringTypeAnnotation, isSuper, isSwitchCase, isSwitchStatement, isSymbolTypeAnnotation, isTSAnyKeyword, isTSArrayType, isTSAsExpression, isTSBaseType, isTSBigIntKeyword, isTSBooleanKeyword, isTSCallSignatureDeclaration, isTSConditionalType, isTSConstructSignatureDeclaration, isTSConstructorType, isTSDeclareFunction, isTSDeclareMethod, isTSEntityName, isTSEnumBody, isTSEnumDeclaration, isTSEnumMember, isTSExportAssignment, isTSExpressionWithTypeArguments, isTSExternalModuleReference, isTSFunctionType, isTSImportEqualsDeclaration, isTSImportType, isTSIndexSignature, isTSIndexedAccessType, isTSInferType, isTSInstantiationExpression, isTSInterfaceBody, isTSInterfaceDeclaration, isTSIntersectionType, isTSIntrinsicKeyword, isTSLiteralType, isTSMappedType, isTSMethodSignature, isTSModuleBlock, isTSModuleDeclaration, isTSNamedTupleMember, isTSNamespaceExportDeclaration, isTSNeverKeyword, isTSNonNullExpression, isTSNullKeyword, isTSNumberKeyword, isTSObjectKeyword, isTSOptionalType, isTSParameterProperty, isTSParenthesizedType, isTSPropertySignature, isTSQualifiedName, isTSRestType, isTSSatisfiesExpression, isTSStringKeyword, isTSSymbolKeyword, isTSTemplateLiteralType, isTSThisType, isTSTupleType, isTSType, isTSTypeAliasDeclaration, isTSTypeAnnotation, isTSTypeAssertion, isTSTypeElement, isTSTypeLiteral, isTSTypeOperator, isTSTypeParameter, isTSTypeParameterDeclaration, isTSTypeParameterInstantiation, isTSTypePredicate, isTSTypeQuery, isTSTypeReference, isTSUndefinedKeyword, isTSUnionType, isTSUnknownKeyword, isTSVoidKeyword, isTaggedTemplateExpression, isTemplateElement, isTemplateLiteral, isTerminatorless, isThisExpression, isThisTypeAnnotation, isThrowStatement, isTopicReference, isTryStatement, isTupleExpression, isTupleTypeAnnotation, isType, isTypeAlias, isTypeAnnotation, isTypeCastExpression, isTypeParameter, isTypeParameterDeclaration, isTypeParameterInstantiation, isTypeScript, isTypeofTypeAnnotation, isUnaryExpression, isUnaryLike, isUnionTypeAnnotation, isUpdateExpression, isUserWhitespacable, isV8IntrinsicIdentifier, isValidES3Identifier, isValidIdentifier, isVar, isVariableDeclaration, isVariableDeclarator, isVariance, isVoidPattern, isVoidTypeAnnotation, isWhile, isWhileStatement, isWithStatement, isYieldExpression, jsxAttribute as jSXAttribute, jsxClosingElement as jSXClosingElement, jsxClosingFragment as jSXClosingFragment, jsxElement as jSXElement, jsxEmptyExpression as jSXEmptyExpression, jsxExpressionContainer as jSXExpressionContainer, jsxFragment as jSXFragment, jsxIdentifier as jSXIdentifier, jsxMemberExpression as jSXMemberExpression, jsxNamespacedName as jSXNamespacedName, jsxOpeningElement as jSXOpeningElement, jsxOpeningFragment as jSXOpeningFragment, jsxSpreadAttribute as jSXSpreadAttribute, jsxSpreadChild as jSXSpreadChild, jsxText as jSXText, jsxAttribute, jsxClosingElement, jsxClosingFragment, jsxElement, jsxEmptyExpression, jsxExpressionContainer, jsxFragment, jsxIdentifier, jsxMemberExpression, jsxNamespacedName, jsxOpeningElement, jsxOpeningFragment, jsxSpreadAttribute, jsxSpreadChild, jsxText, labeledStatement, logicalExpression, matchesPattern, memberExpression, metaProperty, mixedTypeAnnotation, moduleExpression, newExpression, noop, nullLiteral, nullLiteralTypeAnnotation, nullableTypeAnnotation, NumberLiteral as numberLiteral, numberLiteralTypeAnnotation, numberTypeAnnotation, numericLiteral, objectExpression, objectMethod, objectPattern, objectProperty, objectTypeAnnotation, objectTypeCallProperty, objectTypeIndexer, objectTypeInternalSlot, objectTypeProperty, objectTypeSpreadProperty, opaqueType, optionalCallExpression, optionalIndexedAccessType, optionalMemberExpression, parenthesizedExpression, pipelineBareFunction, pipelinePrimaryTopicReference, pipelineTopicExpression, placeholder, prependToMemberExpression, privateName, program, qualifiedTypeIdentifier, react, recordExpression, regExpLiteral, RegexLiteral as regexLiteral, removeComments, removeProperties, removePropertiesDeep, removeTypeDuplicates, restElement, RestProperty as restProperty, returnStatement, sequenceExpression, shallowEqual, spreadElement, SpreadProperty as spreadProperty, staticBlock, stringLiteral, stringLiteralTypeAnnotation, stringTypeAnnotation, _super as super, switchCase, switchStatement, symbolTypeAnnotation, tsAnyKeyword as tSAnyKeyword, tsArrayType as tSArrayType, tsAsExpression as tSAsExpression, tsBigIntKeyword as tSBigIntKeyword, tsBooleanKeyword as tSBooleanKeyword, tsCallSignatureDeclaration as tSCallSignatureDeclaration, tsConditionalType as tSConditionalType, tsConstructSignatureDeclaration as tSConstructSignatureDeclaration, tsConstructorType as tSConstructorType, tsDeclareFunction as tSDeclareFunction, tsDeclareMethod as tSDeclareMethod, tsEnumBody as tSEnumBody, tsEnumDeclaration as tSEnumDeclaration, tsEnumMember as tSEnumMember, tsExportAssignment as tSExportAssignment, tsExpressionWithTypeArguments as tSExpressionWithTypeArguments, tsExternalModuleReference as tSExternalModuleReference, tsFunctionType as tSFunctionType, tsImportEqualsDeclaration as tSImportEqualsDeclaration, tsImportType as tSImportType, tsIndexSignature as tSIndexSignature, tsIndexedAccessType as tSIndexedAccessType, tsInferType as tSInferType, tsInstantiationExpression as tSInstantiationExpression, tsInterfaceBody as tSInterfaceBody, tsInterfaceDeclaration as tSInterfaceDeclaration, tsIntersectionType as tSIntersectionType, tsIntrinsicKeyword as tSIntrinsicKeyword, tsLiteralType as tSLiteralType, tsMappedType as tSMappedType, tsMethodSignature as tSMethodSignature, tsModuleBlock as tSModuleBlock, tsModuleDeclaration as tSModuleDeclaration, tsNamedTupleMember as tSNamedTupleMember, tsNamespaceExportDeclaration as tSNamespaceExportDeclaration, tsNeverKeyword as tSNeverKeyword, tsNonNullExpression as tSNonNullExpression, tsNullKeyword as tSNullKeyword, tsNumberKeyword as tSNumberKeyword, tsObjectKeyword as tSObjectKeyword, tsOptionalType as tSOptionalType, tsParameterProperty as tSParameterProperty, tsParenthesizedType as tSParenthesizedType, tsPropertySignature as tSPropertySignature, tsQualifiedName as tSQualifiedName, tsRestType as tSRestType, tsSatisfiesExpression as tSSatisfiesExpression, tsStringKeyword as tSStringKeyword, tsSymbolKeyword as tSSymbolKeyword, tsTemplateLiteralType as tSTemplateLiteralType, tsThisType as tSThisType, tsTupleType as tSTupleType, tsTypeAliasDeclaration as tSTypeAliasDeclaration, tsTypeAnnotation as tSTypeAnnotation, tsTypeAssertion as tSTypeAssertion, tsTypeLiteral as tSTypeLiteral, tsTypeOperator as tSTypeOperator, tsTypeParameter as tSTypeParameter, tsTypeParameterDeclaration as tSTypeParameterDeclaration, tsTypeParameterInstantiation as tSTypeParameterInstantiation, tsTypePredicate as tSTypePredicate, tsTypeQuery as tSTypeQuery, tsTypeReference as tSTypeReference, tsUndefinedKeyword as tSUndefinedKeyword, tsUnionType as tSUnionType, tsUnknownKeyword as tSUnknownKeyword, tsVoidKeyword as tSVoidKeyword, taggedTemplateExpression, templateElement, templateLiteral, thisExpression, thisTypeAnnotation, throwStatement, toBindingIdentifierName, toBlock, toComputedKey, _default$3 as toExpression, toIdentifier, toKeyAlias, _default$2 as toStatement, topicReference, traverse, traverseFast, tryStatement, tsAnyKeyword, tsArrayType, tsAsExpression, tsBigIntKeyword, tsBooleanKeyword, tsCallSignatureDeclaration, tsConditionalType, tsConstructSignatureDeclaration, tsConstructorType, tsDeclareFunction, tsDeclareMethod, tsEnumBody, tsEnumDeclaration, tsEnumMember, tsExportAssignment, tsExpressionWithTypeArguments, tsExternalModuleReference, tsFunctionType, tsImportEqualsDeclaration, tsImportType, tsIndexSignature, tsIndexedAccessType, tsInferType, tsInstantiationExpression, tsInterfaceBody, tsInterfaceDeclaration, tsIntersectionType, tsIntrinsicKeyword, tsLiteralType, tsMappedType, tsMethodSignature, tsModuleBlock, tsModuleDeclaration, tsNamedTupleMember, tsNamespaceExportDeclaration, tsNeverKeyword, tsNonNullExpression, tsNullKeyword, tsNumberKeyword, tsObjectKeyword, tsOptionalType, tsParameterProperty, tsParenthesizedType, tsPropertySignature, tsQualifiedName, tsRestType, tsSatisfiesExpression, tsStringKeyword, tsSymbolKeyword, tsTemplateLiteralType, tsThisType, tsTupleType, tsTypeAliasDeclaration, tsTypeAnnotation, tsTypeAssertion, tsTypeLiteral, tsTypeOperator, tsTypeParameter, tsTypeParameterDeclaration, tsTypeParameterInstantiation, tsTypePredicate, tsTypeQuery, tsTypeReference, tsUndefinedKeyword, tsUnionType, tsUnknownKeyword, tsVoidKeyword, tupleExpression, tupleTypeAnnotation, typeAlias, typeAnnotation, typeCastExpression, typeParameter, typeParameterDeclaration, typeParameterInstantiation, typeofTypeAnnotation, unaryExpression, unionTypeAnnotation, updateExpression, v8IntrinsicIdentifier, validate, _default$1 as valueToNode, variableDeclaration, variableDeclarator, variance, voidPattern, voidTypeAnnotation, whileStatement, withStatement, yieldExpression };
node_modules/playwright-core/lib/server/trace/recorder/snapshotterInjected.js:399:          if (nodeName === "DIALOG" && element.open) {
node_modules/playwright-core/lib/server/trace/recorder/snapshotterInjected.js:479:            if (nodeName === "DIALOG" && name === "open")
node_modules/@babel/traverse/lib/path/conversion.js.map:1:{"version":3,"names":["_t","require","_template","_visitors","_context","arrowFunctionExpression","assignmentExpression","binaryExpression","blockStatement","callExpression","conditionalExpression","expressionStatement","identifier","isIdentifier","jsxIdentifier","logicalExpression","LOGICAL_OPERATORS","memberExpression","metaProperty","numericLiteral","objectExpression","restElement","returnStatement","sequenceExpression","spreadElement","stringLiteral","super","_super","thisExpression","toExpression","unaryExpression","toBindingIdentifierName","isFunction","isAssignmentPattern","isRestElement","getFunctionName","cloneNode","variableDeclaration","variableDeclarator","exportNamedDeclaration","exportSpecifier","inherits","toComputedKey","key","isMemberExpression","node","property","isProperty","isMethod","ReferenceError","computed","name","ensureBlock","body","get","bodyNode","Array","isArray","Error","isBlockStatement","statements","stringPath","listKey","isStatement","push","parentPath","setup","call","exports","arrowFunctionToShadowed","isArrowFunctionExpression","arrowFunctionToExpression","unwrapFunctionEnvironment","isFunctionExpression","isFunctionDeclaration","buildCodeFrameError","hoistFunctionEnvironment","setType","path","type","allowInsertArrow","allowInsertArrowWithRest","noNewArrows","_arguments$","arguments","specCompliant","self","_self$ensureFunctionN","ensureFunctionName","thisBinding","fnPath","fn","checkBinding","scope","generateUidIdentifier","id","init","unshiftContainer","hub","addHelper","replaceWith","getSuperCallsVisitor","environmentVisitor","CallExpression","child","allSuperCalls","isSuper","arrowParent","thisEnvFn","findParent","p","isProgram","isClassProperty","static","isClassPrivateProperty","inConstructor","isClassMethod","kind","thisPaths","argumentsPaths","newTargetPaths","superProps","superCalls","getScopeInformation","length","traverse","superBinding","getSuperBinding","forEach","superCall","callee","loc","argumentsBinding","getBinding","args","buildUndefinedNode","argumentsChild","argsRef","newTargetBinding","targetChild","targetRef","flatSuperProps","reduce","acc","superProp","concat","standardizeSuperProperty","superParentPath","isAssignment","isAssignmentExpression","left","isCall","isCallExpression","isTaggedTemplate","isTaggedTemplateExpression","tag","getSuperPropBinding","value","right","getThisBinding","hasSuperClass","thisChild","thisRef","isJSX","isLogicalOp","op","includes","operator","assignmentPath","slice","isLogicalAssignment","tmp","generateDeclaredUidIdentifier","object","rightExpression","isUpdateExpression","updateExpr","computedKey","parts","prefix","superClass","assignSuperThisVisitor","supers","has","add","replaceWithMultiple","WeakSet","argsBinding","propName","argsList","fnBody","method","unshift","valueIdent","cacheKey","data","getData","setData","getScopeInformationVisitor","ThisExpression","JSXIdentifier","isJSXMemberExpression","isJSXOpeningElement","MemberExpression","Identifier","isReferencedIdentifier","curr","hasOwnBinding","rename","parent","MetaProperty","splitExportDeclaration","isExportDeclaration","isExportAllDeclaration","isExportNamedDeclaration","declaration","isExportDefaultDeclaration","standaloneDeclaration","isClassDeclaration","exportExpr","isClassExpression","isScope","needBindingRegistration","hasBinding","updatedDeclaration","updatedExportDeclaration","insertAfter","registerDeclaration","bindingIdentifiers","getOuterBindingIdentifiers","specifiers","Object","keys","map","aliasDeclar","refersOuterBindingVisitor","ReferencedIdentifier|BindingIdentifier","state","needsRename","stop","Scope","skip","supportUnicodeId","res","test","startsWith","replace","originalNode","binding","getOwnBinding","hasGlobal","getProgramParent","references","params","i","len","getFunctionArity","template","expression","ast","count","findIndex","param"],"sources":["../../src/path/conversion.ts"],"sourcesContent":["// This file contains methods that convert the path node into another node or some other type of data.\n\nimport {\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  blockStatement,\n  callExpression,\n  conditionalExpression,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  jsxIdentifier,\n  logicalExpression,\n  LOGICAL_OPERATORS,\n  memberExpression,\n  metaProperty,\n  numericLiteral,\n  objectExpression,\n  restElement,\n  returnStatement,\n  sequenceExpression,\n  spreadElement,\n  stringLiteral,\n  super as _super,\n  thisExpression,\n  toExpression,\n  unaryExpression,\n  toBindingIdentifierName,\n  isFunction,\n  isAssignmentPattern,\n  isRestElement,\n  getFunctionName,\n  cloneNode,\n  variableDeclaration,\n  variableDeclarator,\n  exportNamedDeclaration,\n  exportSpecifier,\n  inherits,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport template from \"@babel/template\";\nimport { environmentVisitor } from \"../visitors.ts\";\nimport type NodePath from \"./index.ts\";\nimport type { Visitor } from \"../types.ts\";\nimport { setup } from \"./context.ts\";\nimport type Scope from \"../scope/index.ts\";\n\nexport function toComputedKey(this: NodePath) {\n  let key;\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  // @ts-expect-error todo(flow->ts) computed does not exist in ClassPrivateProperty\n  if (!this.node.computed) {\n    if (isIdentifier(key)) key = stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nexport function ensureBlock(\n  this: NodePath<\n    t.Loop | t.WithStatement | t.Function | t.LabeledStatement | t.CatchClause\n  >,\n): void {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    // @ts-expect-error TS throws because ensureBlock returns the body node path\n    // however, we don't use the return value and treat it as a transform and\n    // assertion utilities. For better type inference we annotate it as an\n    // assertion method\n    // TODO: Unify the implementation with the type definition\n    return bodyNode;\n  }\n\n  const statements: t.Statement[] = [];\n\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(returnStatement(body.node as t.Expression));\n    } else {\n      key = \"expression\";\n      statements.push(expressionStatement(body.node as t.Expression));\n    }\n  }\n\n  this.node.body = blockStatement(statements);\n  const parentPath = this.get(stringPath) as NodePath;\n  setup.call(\n    body,\n    parentPath,\n    listKey\n      ? // @ts-expect-error listKey must present in parent path\n        parentPath.node[listKey]\n      : parentPath.node,\n    listKey,\n    key,\n  );\n\n  // @ts-expect-error TS throws because ensureBlock returns the body node path\n  // however, we don't use the return value and treat it as a transform and\n  // assertion utilities. For better type inference we annotate it as an\n  // assertion method\n  // TODO: Unify the implementation with the type definition\n  return this.node;\n}\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  /**\n   * Keeping this for backward-compatibility. You should use arrowFunctionToExpression() for >=7.x.\n   */\n  // eslint-disable-next-line no-restricted-globals\n  exports.arrowFunctionToShadowed = function (this: NodePath) {\n    if (!this.isArrowFunctionExpression()) return;\n\n    this.arrowFunctionToExpression();\n  };\n}\n\n/**\n * Given an arbitrary function, process its content as if it were an arrow function, moving references\n * to \"this\", \"arguments\", \"super\", and such into the function's parent scope. This method is useful if\n * you have wrapped some set of items in an IIFE or other function, but want \"this\", \"arguments\", and super\"\n * to continue behaving as expected.\n */\nexport function unwrapFunctionEnvironment(this: NodePath) {\n  if (\n    !this.isArrowFunctionExpression() &&\n    !this.isFunctionExpression() &&\n    !this.isFunctionDeclaration()\n  ) {\n    throw this.buildCodeFrameError(\n      \"Can only unwrap the environment of a function.\",\n    );\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction setType<N extends t.Node, T extends N[\"type\"]>(\n  path: NodePath<N>,\n  type: T,\n): asserts path is NodePath<Extract<N, { type: T }>> {\n  path.node.type = type;\n}\n\n/**\n * Convert a given arrow function into a normal ES5 function expression.\n */\nexport function arrowFunctionToExpression(\n  this: NodePath<t.ArrowFunctionExpression>,\n  {\n    allowInsertArrow = true,\n    allowInsertArrowWithRest = allowInsertArrow,\n    noNewArrows = process.env.BABEL_8_BREAKING\n      ? // TODO(Babel 8): Consider defaulting to `false` for spec compliance\n        true\n      : !arguments[0]?.specCompliant,\n  }: {\n    allowInsertArrow?: boolean | void;\n    allowInsertArrowWithRest?: boolean | void;\n    noNewArrows?: boolean;\n  } = {},\n): NodePath<\n  Exclude<t.Function, t.Method | t.ArrowFunctionExpression> | t.CallExpression\n> {\n  if (!this.isArrowFunctionExpression()) {\n    throw (this as NodePath).buildCodeFrameError(\n      \"Cannot convert non-arrow function to a function expression.\",\n    );\n  }\n\n  let self = this;\n  if (!noNewArrows) {\n    // @ts-expect-error This is technicallynot valid on arrow functions\n    // because it adds an .id property, but we are going to convert it\n    // to a function expression anyway\n    self = self.ensureFunctionName(false) ?? self;\n  }\n\n  const { thisBinding, fnPath: fn } = hoistFunctionEnvironment(\n    self,\n    noNewArrows,\n    allowInsertArrow,\n    allowInsertArrowWithRest,\n  );\n\n  fn.ensureBlock();\n  setType(fn, \"FunctionExpression\");\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding\n      ? null\n      : fn.scope.generateUidIdentifier(\"arrowCheckId\");\n    if (checkBinding) {\n      fn.parentPath.scope.push({\n        id: checkBinding,\n        init: objectExpression([]),\n      });\n    }\n\n    fn.get(\"body\").unshiftContainer(\n      \"body\",\n      expressionStatement(\n        callExpression(this.hub.addHelper(\"newArrowCheck\"), [\n          thisExpression(),\n          checkBinding\n            ? identifier(checkBinding.name)\n            : identifier(thisBinding),\n        ]),\n      ),\n    );\n\n    fn.replaceWith(\n      callExpression(memberExpression(fn.node, identifier(\"bind\")), [\n        checkBinding ? identifier(checkBinding.name) : thisExpression(),\n      ]),\n    );\n\n    return fn.get(\"callee.object\");\n  }\n\n  return fn;\n}\n\nconst getSuperCallsVisitor = environmentVisitor<{\n  allSuperCalls: NodePath<t.CallExpression>[];\n}>({\n  CallExpression(child, { allSuperCalls }) {\n    if (!child.get(\"callee\").isSuper()) return;\n    allSuperCalls.push(child);\n  },\n});\n\n/**\n * Given a function, traverse its contents, and if there are references to \"this\", \"arguments\", \"super\",\n * or \"new.target\", ensure that these references reference the parent environment around this function.\n *\n * @returns `thisBinding`: the name of the injected reference to `this`; for example \"_this\"\n * @returns `fnPath`: the new path to the function node. This is different from the fnPath\n *                    parameter when the function node is wrapped in another node.\n */\nfunction hoistFunctionEnvironment(\n  fnPath: NodePath<t.Function>,\n  // TODO(Babel 8): Consider defaulting to `false` for spec compliance\n  noNewArrows: boolean | void = true,\n  allowInsertArrow: boolean | void = true,\n  allowInsertArrowWithRest: boolean | void = true,\n): { thisBinding: string; fnPath: NodePath<t.Function> } {\n  let arrowParent;\n  let thisEnvFn: NodePath<t.Function> = fnPath.findParent(p => {\n    if (p.isArrowFunctionExpression()) {\n      arrowParent ??= p;\n      return false;\n    }\n    return (\n      p.isFunction() ||\n      p.isProgram() ||\n      p.isClassProperty({ static: false }) ||\n      p.isClassPrivateProperty({ static: false })\n    );\n  }) as NodePath<t.Function>;\n  const inConstructor = thisEnvFn.isClassMethod({ kind: \"constructor\" });\n\n  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {\n    if (arrowParent) {\n      thisEnvFn = arrowParent;\n    } else if (allowInsertArrow) {\n      // It's safe to wrap this function in another and not hoist to the\n      // top level because the 'this' binding is constant in class\n      // properties (since 'super()' has already been called), so we don't\n      // need to capture/reassign it at the top level.\n      fnPath.replaceWith(\n        callExpression(\n          arrowFunctionExpression([], toExpression(fnPath.node)),\n          [],\n        ),\n      );\n      thisEnvFn = fnPath.get(\"callee\") as NodePath<t.ArrowFunctionExpression>;\n      fnPath = thisEnvFn.get(\"body\") as NodePath<t.FunctionExpression>;\n    } else {\n      throw fnPath.buildCodeFrameError(\n        \"Unable to transform arrow inside class property\",\n      );\n    }\n  }\n\n  const { thisPaths, argumentsPaths, newTargetPaths, superProps, superCalls } =\n    getScopeInformation(fnPath);\n\n  // Convert all super() calls in the constructor, if super is used in an arrow.\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\n        \"When using '@babel/plugin-transform-arrow-functions', \" +\n          \"it's not possible to compile `super()` in an arrow function without compiling classes.\\n\" +\n          \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\",\n      );\n    }\n    if (!allowInsertArrowWithRest) {\n      // preset-env with target `since 2017` enables `transform-parameters` without `transform-classes`.\n      throw superCalls[0].buildCodeFrameError(\n        \"When using '@babel/plugin-transform-parameters', \" +\n          \"it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\\n\" +\n          \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\",\n      );\n    }\n    const allSuperCalls: NodePath<t.CallExpression>[] = [];\n    thisEnvFn.traverse(getSuperCallsVisitor, { allSuperCalls });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  // Convert all \"arguments\" references in the arrow to point at the alias.\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => {\n      const args = () => identifier(\"arguments\");\n      if (thisEnvFn.scope.path.isProgram()) {\n        return conditionalExpression(\n          binaryExpression(\n            \"===\",\n            unaryExpression(\"typeof\", args()),\n            stringLiteral(\"undefined\"),\n          ),\n          thisEnvFn.scope.buildUndefinedNode(),\n          args(),\n        );\n      } else {\n        return args();\n      }\n    });\n\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  // Convert all \"new.target\" references in the arrow to point at the alias.\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () =>\n      metaProperty(identifier(\"new\"), identifier(\"target\")),\n    );\n\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  // Convert all \"super.prop\" references to point at aliases.\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\n        \"When using '@babel/plugin-transform-arrow-functions', \" +\n          \"it's not possible to compile `super.prop` in an arrow function without compiling classes.\\n\" +\n          \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\",\n      );\n    }\n\n    const flatSuperProps = superProps.reduce(\n      (acc, superProp) => acc.concat(standardizeSuperProperty(superProp)),\n      [] as NodePath<t.MemberExpression>[],\n    );\n\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed\n        ? \"\"\n        : // @ts-expect-error super property must not contain private name\n          superProp.get(\"property\").node.name;\n\n      const superParentPath = superProp.parentPath;\n\n      const isAssignment = superParentPath.isAssignmentExpression({\n        left: superProp.node,\n      });\n      const isCall = superParentPath.isCallExpression({\n        callee: superProp.node,\n      });\n      const isTaggedTemplate = superParentPath.isTaggedTemplateExpression({\n        tag: superProp.node,\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n\n      const args: t.Expression[] = [];\n      if (superProp.node.computed) {\n        // SuperProperty must not be a private name\n        args.push(superProp.get(\"property\").node as t.Expression);\n      }\n\n      if (isAssignment) {\n        const value = superParentPath.node.right;\n        args.push(value);\n      }\n\n      const call = callExpression(identifier(superBinding), args);\n\n      if (isCall) {\n        superParentPath.unshiftContainer(\"arguments\", thisExpression());\n        superProp.replaceWith(memberExpression(call, identifier(\"call\")));\n\n        thisPaths.push(\n          superParentPath.get(\"arguments.0\") as NodePath<t.ThisExpression>,\n        );\n      } else if (isAssignment) {\n        // Replace not only the super.prop, but the whole assignment\n        superParentPath.replaceWith(call);\n      } else if (isTaggedTemplate) {\n        superProp.replaceWith(\n          callExpression(memberExpression(call, identifier(\"bind\"), false), [\n            thisExpression(),\n          ]),\n        );\n\n        thisPaths.push(\n          superProp.get(\"arguments.0\") as NodePath<t.ThisExpression>,\n        );\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  // Convert all \"this\" references in the arrow to point at the alias.\n  let thisBinding: string | null;\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (\n      noNewArrows ||\n      // In subclass constructors, still need to rewrite because \"this\" can't be bound in spec mode\n      // because it might not have been initialized yet.\n      (inConstructor && hasSuperClass(thisEnvFn))\n    ) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX()\n          ? jsxIdentifier(thisBinding!)\n          : identifier(thisBinding!);\n\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return { thisBinding: thisBinding!, fnPath };\n}\n\ntype LogicalOp = Parameters<typeof logicalExpression>[0];\ntype BinaryOp = Parameters<typeof binaryExpression>[0];\n\nfunction isLogicalOp(op: string): op is LogicalOp {\n  return LOGICAL_OPERATORS.includes(op);\n}\n\nfunction standardizeSuperProperty(\n  superProp: NodePath<t.MemberExpression>,\n):\n  | [NodePath<t.MemberExpression>]\n  | [NodePath<t.MemberExpression>, NodePath<t.MemberExpression>] {\n  if (\n    superProp.parentPath.isAssignmentExpression() &&\n    superProp.parentPath.node.operator !== \"=\"\n  ) {\n    const assignmentPath = superProp.parentPath;\n\n    const op = assignmentPath.node.operator.slice(0, -1) as\n      | LogicalOp\n      | BinaryOp;\n\n    const value = assignmentPath.node.right;\n\n    const isLogicalAssignment = isLogicalOp(op);\n\n    if (superProp.node.computed) {\n      // from: super[foo] **= 4;\n      // to:   super[tmp = foo] = super[tmp] ** 4;\n\n      // from: super[foo] ??= 4;\n      // to:   super[tmp = foo] ?? super[tmp] = 4;\n\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n\n      const { object, property } = superProp.node;\n\n      assignmentPath.get(\"left\").replaceWith(\n        memberExpression(\n          object,\n          // @ts-ignore(Babel 7 vs Babel 8) Babel 8 has better type definitions\n          assignmentExpression(\"=\", tmp, property),\n          true /* computed */,\n        ),\n      );\n\n      assignmentPath\n        .get(\"right\")\n        .replaceWith(\n          rightExpression(\n            isLogicalAssignment ? \"=\" : op,\n            memberExpression(object, identifier(tmp.name), true /* computed */),\n            value,\n          ),\n        );\n    } else {\n      // from: super.foo **= 4;\n      // to:   super.foo = super.foo ** 4;\n\n      // from: super.foo ??= 4;\n      // to:   super.foo ?? super.foo = 4;\n\n      const object = superProp.node.object;\n      const property = superProp.node.property as t.Identifier;\n\n      assignmentPath\n        .get(\"left\")\n        .replaceWith(memberExpression(object, property));\n\n      assignmentPath\n        .get(\"right\")\n        .replaceWith(\n          rightExpression(\n            isLogicalAssignment ? \"=\" : op,\n            memberExpression(object, identifier(property.name)),\n            value,\n          ),\n        );\n    }\n\n    if (isLogicalAssignment) {\n      assignmentPath.replaceWith(\n        logicalExpression(\n          op,\n          assignmentPath.node.left as t.MemberExpression,\n          assignmentPath.node.right,\n        ),\n      );\n    } else {\n      assignmentPath.node.operator = \"=\";\n    }\n\n    return [\n      assignmentPath.get(\"left\") as NodePath<t.MemberExpression>,\n      assignmentPath.get(\"right\").get(\"left\") as NodePath<t.MemberExpression>,\n    ];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed\n      ? superProp.scope.generateDeclaredUidIdentifier(\"prop\")\n      : null;\n\n    const parts: t.Expression[] = [\n      assignmentExpression(\n        \"=\",\n        tmp,\n        memberExpression(\n          superProp.node.object,\n          computedKey\n            ? assignmentExpression(\n                \"=\",\n                computedKey,\n                superProp.node.property as t.Expression,\n              )\n            : superProp.node.property,\n          superProp.node.computed,\n        ),\n      ),\n      assignmentExpression(\n        \"=\",\n        memberExpression(\n          superProp.node.object,\n          computedKey ? identifier(computedKey.name) : superProp.node.property,\n          superProp.node.computed,\n        ),\n        binaryExpression(\n          // map `++` to `+`, and `--` to `-`\n          superProp.parentPath.node.operator[0] as \"+\" | \"-\",\n          identifier(tmp.name),\n          numericLiteral(1),\n        ),\n      ),\n    ];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(sequenceExpression(parts));\n\n    const left = updateExpr.get(\n      \"expressions.0.right\",\n    ) as NodePath<t.MemberExpression>;\n    const right = updateExpr.get(\n      \"expressions.1.left\",\n    ) as NodePath<t.MemberExpression>;\n    return [left, right];\n  }\n\n  return [superProp];\n\n  function rightExpression(\n    op: BinaryOp | \"=\",\n    left: t.MemberExpression,\n    right: t.Expression,\n  ) {\n    if (op === \"=\") {\n      return assignmentExpression(\"=\", left, right);\n    } else {\n      return binaryExpression(op, left, right);\n    }\n  }\n}\n\nfunction hasSuperClass(thisEnvFn: NodePath<t.Function>) {\n  return (\n    thisEnvFn.isClassMethod() &&\n    !!(thisEnvFn.parentPath.parentPath.node as t.Class).superClass\n  );\n}\n\nconst assignSuperThisVisitor = environmentVisitor<{\n  supers: WeakSet<t.CallExpression>;\n  thisBinding: string;\n}>({\n  CallExpression(child, { supers, thisBinding }) {\n    if (!child.get(\"callee\").isSuper()) return;\n    if (supers.has(child.node)) return;\n    supers.add(child.node);\n\n    child.replaceWithMultiple([\n      child.node,\n      assignmentExpression(\"=\", identifier(thisBinding), identifier(\"this\")),\n    ]);\n  },\n});\n\n// Create a binding that evaluates to the \"this\" of the given function.\nfunction getThisBinding(\n  thisEnvFn: NodePath<t.Function>,\n  inConstructor: boolean,\n) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();\n\n    thisEnvFn.traverse(assignSuperThisVisitor, {\n      supers: new WeakSet(),\n      thisBinding,\n    });\n  });\n}\n\n// Create a binding for a function that will call \"super()\" with arguments passed through.\nfunction getSuperBinding(thisEnvFn: NodePath<t.Function>) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return arrowFunctionExpression(\n      [restElement(argsBinding)],\n      callExpression(_super(), [spreadElement(identifier(argsBinding.name))]),\n    );\n  });\n}\n\n// Create a binding for a function that will call \"super.foo\" or \"super[foo]\".\nfunction getSuperPropBinding(\n  thisEnvFn: NodePath<t.Function>,\n  isAssignment: boolean,\n  propName: string,\n) {\n  const op = isAssignment ? \"set\" : \"get\";\n\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n\n    let fnBody;\n    if (propName) {\n      // () => super.foo\n      fnBody = memberExpression(_super(), identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      // (method) => super[method]\n      argsList.unshift(method);\n      fnBody = memberExpression(\n        _super(),\n        identifier(method.name),\n        true /* computed */,\n      );\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n\n      fnBody = assignmentExpression(\"=\", fnBody, identifier(valueIdent.name));\n    }\n\n    return arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(\n  thisEnvFn: NodePath,\n  key: string,\n  init: (name: string) => t.Expression | undefined,\n) {\n  const cacheKey = \"binding:\" + key;\n  let data: string | undefined = thisEnvFn.getData(cacheKey);\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data),\n    });\n  }\n\n  return data;\n}\n\ntype ScopeInfo = {\n  thisPaths: NodePath<t.ThisExpression | t.JSXIdentifier>[];\n  superCalls: NodePath<t.CallExpression>[];\n  superProps: NodePath<t.MemberExpression>[];\n  argumentsPaths: NodePath<t.Identifier | t.JSXIdentifier>[];\n  newTargetPaths: NodePath<t.MetaProperty>[];\n};\n\nconst getScopeInformationVisitor = environmentVisitor<ScopeInfo>({\n  ThisExpression(child, { thisPaths }) {\n    thisPaths.push(child);\n  },\n  JSXIdentifier(child, { thisPaths }) {\n    if (child.node.name !== \"this\") return;\n    if (\n      !child.parentPath.isJSXMemberExpression({ object: child.node }) &&\n      !child.parentPath.isJSXOpeningElement({ name: child.node })\n    ) {\n      return;\n    }\n\n    thisPaths.push(child);\n  },\n  CallExpression(child, { superCalls }) {\n    if (child.get(\"callee\").isSuper()) superCalls.push(child);\n  },\n  MemberExpression(child, { superProps }) {\n    if (child.get(\"object\").isSuper()) superProps.push(child);\n  },\n  Identifier(child, { argumentsPaths }) {\n    if (!child.isReferencedIdentifier({ name: \"arguments\" })) return;\n\n    let curr: Scope | undefined = child.scope;\n    do {\n      if (curr.hasOwnBinding(\"arguments\")) {\n        curr.rename(\"arguments\");\n        return;\n      }\n      if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {\n        break;\n      }\n    } while ((curr = curr.parent));\n\n    argumentsPaths.push(child);\n  },\n  MetaProperty(child, { newTargetPaths }) {\n    if (!child.get(\"meta\").isIdentifier({ name: \"new\" })) return;\n    if (!child.get(\"property\").isIdentifier({ name: \"target\" })) return;\n\n    newTargetPaths.push(child);\n  },\n});\n\nfunction getScopeInformation(fnPath: NodePath) {\n  const thisPaths: ScopeInfo[\"thisPaths\"] = [];\n  const argumentsPaths: ScopeInfo[\"argumentsPaths\"] = [];\n  const newTargetPaths: ScopeInfo[\"newTargetPaths\"] = [];\n  const superProps: ScopeInfo[\"superProps\"] = [];\n  const superCalls: ScopeInfo[\"superCalls\"] = [];\n\n  fnPath.traverse(getScopeInformationVisitor, {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls,\n  });\n\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls,\n  };\n}\n\nexport function splitExportDeclaration(\n  this: NodePath<t.ExportDefaultDeclaration | t.ExportNamedDeclaration>,\n): NodePath<t.Declaration> {\n  if (!this.isExportDeclaration() || this.isExportAllDeclaration()) {\n    throw new Error(\"Only default and named export declarations can be split.\");\n  }\n  if (this.isExportNamedDeclaration() && this.get(\"specifiers\").length > 0) {\n    throw new Error(\"It doesn't make sense to split exported specifiers.\");\n  }\n\n  const declaration = this.get(\"declaration\");\n\n  if (this.isExportDefaultDeclaration()) {\n    const standaloneDeclaration =\n      declaration.isFunctionDeclaration() || declaration.isClassDeclaration();\n    const exportExpr =\n      declaration.isFunctionExpression() || declaration.isClassExpression();\n\n    const scope = declaration.isScope()\n      ? declaration.scope.parent!\n      : declaration.scope;\n\n    // @ts-expect-error id is not defined in expressions other than function/class\n    let id = declaration.node.id;\n    let needBindingRegistration = false;\n\n    if (!id) {\n      needBindingRegistration = true;\n\n      id = scope.generateUidIdentifier(\"default\");\n\n      if (standaloneDeclaration || exportExpr) {\n        declaration.node.id = cloneNode(id);\n      }\n    } else if (exportExpr && scope.hasBinding(id.name)) {\n      needBindingRegistration = true;\n\n      id = scope.generateUidIdentifier(id.name);\n    }\n\n    const updatedDeclaration = standaloneDeclaration\n      ? declaration.node\n      : variableDeclaration(\"var\", [\n          variableDeclarator(\n            cloneNode(id),\n            // @ts-expect-error When `standaloneDeclaration` is false, declaration must not be a Function/ClassDeclaration\n            declaration.node,\n          ),\n        ]);\n\n    const updatedExportDeclaration = exportNamedDeclaration(null, [\n      exportSpecifier(cloneNode(id), identifier(\"default\")),\n    ]);\n\n    this.insertAfter(updatedExportDeclaration);\n    this.replaceWith(updatedDeclaration);\n\n    if (needBindingRegistration) {\n      scope.registerDeclaration(this);\n    }\n\n    return this;\n  } else if (this.get(\"specifiers\").length > 0) {\n    throw new Error(\"It doesn't make sense to split exported specifiers.\");\n  }\n\n  const bindingIdentifiers = declaration.getOuterBindingIdentifiers();\n\n  const specifiers = Object.keys(bindingIdentifiers).map(name => {\n    return exportSpecifier(identifier(name), identifier(name));\n  });\n\n  const aliasDeclar = exportNamedDeclaration(null, specifiers);\n\n  this.insertAfter(aliasDeclar);\n  this.replaceWith(declaration.node!);\n  return this;\n}\n\nconst refersOuterBindingVisitor: Visitor<{\n  needsRename: boolean;\n  name: string;\n}> = {\n  \"ReferencedIdentifier|BindingIdentifier\"(\n    path: NodePath<t.Identifier>,\n    state,\n  ) {\n    // check if this node matches our function id\n    if (path.node.name !== state.name) return;\n    state.needsRename = true;\n    path.stop();\n  },\n  Scope(path, state) {\n    if (path.scope.hasOwnBinding(state.name)) {\n      path.skip();\n    }\n  },\n};\n\nexport function ensureFunctionName<\n  N extends t.FunctionExpression | t.ClassExpression,\n>(this: NodePath<N>, supportUnicodeId: boolean): null | NodePath<N> {\n  if (this.node.id) return this;\n\n  const res = getFunctionName(this.node, this.parent);\n  if (res == null) return this;\n  let { name } = res;\n\n  if (!supportUnicodeId && /[\\uD800-\\uDFFF]/.test(name)) {\n    return null;\n  }\n\n  if (name.startsWith(\"get \") || name.startsWith(\"set \")) {\n    // TODO: Remove this to support naming getters and setters\n    return null;\n  }\n\n  name = toBindingIdentifierName(name.replace(/[/ ]/g, \"_\"));\n  const id = identifier(name);\n  inherits(id, res.originalNode);\n\n  const state = { needsRename: false, name };\n\n  // check to see if we have a local binding of the id we're setting inside of\n  // the function, this is important as there are caveats associated\n\n  const { scope } = this;\n  const binding = scope.getOwnBinding(name);\n  if (binding) {\n    if (binding.kind === \"param\") {\n      // safari will blow up in strict mode with code like:\n      //\n      //   let t = function t(t) {};\n      //\n      // with the error:\n      //\n      //   Cannot declare a parameter named 't' as it shadows the name of a\n      //   strict mode function.\n      //\n      // this isn't to the spec and they've invented this behaviour which is\n      // **extremely** annoying so we avoid setting the name if it has a param\n      // with the same id\n      state.needsRename = true;\n    } else {\n      // otherwise it's defined somewhere in scope like:\n      //\n      //   let t = function () {\n      //     let t = 2;\n      //   };\n      //\n      // so we can safely just set the id and move along as it shadows the\n      // bound function id\n    }\n  } else if (scope.parent!.hasBinding(name) || scope.hasGlobal(name)) {\n    this.traverse(refersOuterBindingVisitor, state);\n  }\n\n  if (!state.needsRename) {\n    this.node.id = id;\n    if (process.env.BABEL_8_BREAKING) {\n      scope.getProgramParent().referencesSet.add(id.name);\n    } else {\n      // @ts-expect-error Babel 7\n      scope.getProgramParent().references[id.name] = true;\n    }\n    return this;\n  }\n\n  if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {\n    // we can just munge the local binding\n    scope.rename(id.name);\n    this.node.id = id;\n    if (process.env.BABEL_8_BREAKING) {\n      scope.getProgramParent().referencesSet.add(id.name);\n    } else {\n      // @ts-expect-error Babel 7\n      scope.getProgramParent().references[id.name] = true;\n    }\n    return this;\n  }\n\n  // TODO: we don't currently support wrapping class expressions\n  if (!isFunction(this.node)) return null;\n\n  // need to add a wrapper since we can't change the references\n\n  const key = scope.generateUidIdentifier(id.name);\n  // shim in dummy params to retain function arity, if you try to read the\n  // source then you'll get the original since it's proxied so it's all good\n  const params = [];\n  for (let i = 0, len = getFunctionArity(this.node); i < len; i++) {\n    params.push(scope.generateUidIdentifier(\"x\"));\n  }\n  const call = template.expression.ast`\n    (function (${key}) {\n      function ${id}(${params}) {\n        return ${cloneNode(key)}.apply(this, arguments);\n      }\n\n      ${cloneNode(id)}.toString = function () {\n        return ${cloneNode(key)}.toString();\n      }\n\n      return ${cloneNode(id)};\n    })(${toExpression(this.node)})\n  ` as t.CallExpression;\n\n  return this.replaceWith(call)[0].get(\"arguments.0\") as NodePath<N>;\n}\n\nfunction getFunctionArity(node: t.Function): number {\n  const count = node.params.findIndex(\n    param => isAssignmentPattern(param) || isRestElement(param),\n  );\n  return count === -1 ? node.params.length : count;\n}\n"],"mappings":"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","ignoreList":[]}
node_modules/@babel/traverse/lib/path/conversion.js:28:  LOGICAL_OPERATORS,
node_modules/@babel/traverse/lib/path/conversion.js:291:  return LOGICAL_OPERATORS.includes(op);
node_modules/@babel/types/lib/constants/index.js.map:1:{"version":3,"names":["STATEMENT_OR_BLOCK_KEYS","exports","FLATTENABLE_KEYS","FOR_INIT_KEYS","COMMENT_KEYS","LOGICAL_OPERATORS","UPDATE_OPERATORS","BOOLEAN_NUMBER_BINARY_OPERATORS","EQUALITY_BINARY_OPERATORS","COMPARISON_BINARY_OPERATORS","BOOLEAN_BINARY_OPERATORS","NUMBER_BINARY_OPERATORS","BINARY_OPERATORS","ASSIGNMENT_OPERATORS","map","op","BOOLEAN_UNARY_OPERATORS","NUMBER_UNARY_OPERATORS","STRING_UNARY_OPERATORS","UNARY_OPERATORS","INHERIT_KEYS","optional","force","BLOCK_SCOPED_SYMBOL","Symbol","for","NOT_LOCAL_BINDING"],"sources":["../../src/constants/index.ts"],"sourcesContent":["export const STATEMENT_OR_BLOCK_KEYS = [\"consequent\", \"body\", \"alternate\"];\nexport const FLATTENABLE_KEYS = [\"body\", \"expressions\"];\nexport const FOR_INIT_KEYS = [\"left\", \"init\"];\nexport const COMMENT_KEYS = [\n  \"leadingComments\",\n  \"trailingComments\",\n  \"innerComments\",\n] as const;\n\nexport const LOGICAL_OPERATORS = [\"||\", \"&&\", \"??\"];\nexport const UPDATE_OPERATORS = [\"++\", \"--\"];\n\nexport const BOOLEAN_NUMBER_BINARY_OPERATORS = [\">\", \"<\", \">=\", \"<=\"];\nexport const EQUALITY_BINARY_OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\nexport const COMPARISON_BINARY_OPERATORS = [\n  ...EQUALITY_BINARY_OPERATORS,\n  \"in\",\n  \"instanceof\",\n];\nexport const BOOLEAN_BINARY_OPERATORS = [\n  ...COMPARISON_BINARY_OPERATORS,\n  ...BOOLEAN_NUMBER_BINARY_OPERATORS,\n];\nexport const NUMBER_BINARY_OPERATORS = [\n  \"-\",\n  \"/\",\n  \"%\",\n  \"*\",\n  \"**\",\n  \"&\",\n  \"|\",\n  \">>\",\n  \">>>\",\n  \"<<\",\n  \"^\",\n];\nexport const BINARY_OPERATORS = [\n  \"+\",\n  ...NUMBER_BINARY_OPERATORS,\n  ...BOOLEAN_BINARY_OPERATORS,\n  \"|>\",\n];\n\nexport const ASSIGNMENT_OPERATORS = [\n  \"=\",\n  \"+=\",\n  ...NUMBER_BINARY_OPERATORS.map(op => op + \"=\"),\n  ...LOGICAL_OPERATORS.map(op => op + \"=\"),\n];\n\nexport const BOOLEAN_UNARY_OPERATORS = [\"delete\", \"!\"];\nexport const NUMBER_UNARY_OPERATORS = [\"+\", \"-\", \"~\"];\nexport const STRING_UNARY_OPERATORS = [\"typeof\"];\nexport const UNARY_OPERATORS = [\n  \"void\",\n  \"throw\",\n  ...BOOLEAN_UNARY_OPERATORS,\n  ...NUMBER_UNARY_OPERATORS,\n  ...STRING_UNARY_OPERATORS,\n];\n\nexport const INHERIT_KEYS = {\n  optional: [\"typeAnnotation\", \"typeParameters\", \"returnType\"],\n  force: [\"start\", \"loc\", \"end\"],\n} as const;\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  // eslint-disable-next-line no-restricted-globals\n  exports.BLOCK_SCOPED_SYMBOL = Symbol.for(\"var used to be block scoped\");\n  // eslint-disable-next-line no-restricted-globals\n  exports.NOT_LOCAL_BINDING = Symbol.for(\n    \"should not be considered a local binding\",\n  );\n}\n"],"mappings":";;;;;;AAAO,MAAMA,uBAAuB,GAAAC,OAAA,CAAAD,uBAAA,GAAG,CAAC,YAAY,EAAE,MAAM,EAAE,WAAW,CAAC;AACnE,MAAME,gBAAgB,GAAAD,OAAA,CAAAC,gBAAA,GAAG,CAAC,MAAM,EAAE,aAAa,CAAC;AAChD,MAAMC,aAAa,GAAAF,OAAA,CAAAE,aAAA,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC;AACtC,MAAMC,YAAY,GAAAH,OAAA,CAAAG,YAAA,GAAG,CAC1B,iBAAiB,EACjB,kBAAkB,EAClB,eAAe,CACP;AAEH,MAAMC,iBAAiB,GAAAJ,OAAA,CAAAI,iBAAA,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;AAC5C,MAAMC,gBAAgB,GAAAL,OAAA,CAAAK,gBAAA,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC;AAErC,MAAMC,+BAA+B,GAAAN,OAAA,CAAAM,+BAAA,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,CAAC;AAC9D,MAAMC,yBAAyB,GAAAP,OAAA,CAAAO,yBAAA,GAAG,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC;AAC5D,MAAMC,2BAA2B,GAAAR,OAAA,CAAAQ,2BAAA,GAAG,CACzC,GAAGD,yBAAyB,EAC5B,IAAI,EACJ,YAAY,CACb;AACM,MAAME,wBAAwB,GAAAT,OAAA,CAAAS,wBAAA,GAAG,CACtC,GAAGD,2BAA2B,EAC9B,GAAGF,+BAA+B,CACnC;AACM,MAAMI,uBAAuB,GAAAV,OAAA,CAAAU,uBAAA,GAAG,CACrC,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,IAAI,EACJ,GAAG,EACH,GAAG,EACH,IAAI,EACJ,KAAK,EACL,IAAI,EACJ,GAAG,CACJ;AACM,MAAMC,gBAAgB,GAAAX,OAAA,CAAAW,gBAAA,GAAG,CAC9B,GAAG,EACH,GAAGD,uBAAuB,EAC1B,GAAGD,wBAAwB,EAC3B,IAAI,CACL;AAEM,MAAMG,oBAAoB,GAAAZ,OAAA,CAAAY,oBAAA,GAAG,CAClC,GAAG,EACH,IAAI,EACJ,GAAGF,uBAAuB,CAACG,GAAG,CAACC,EAAE,IAAIA,EAAE,GAAG,GAAG,CAAC,EAC9C,GAAGV,iBAAiB,CAACS,GAAG,CAACC,EAAE,IAAIA,EAAE,GAAG,GAAG,CAAC,CACzC;AAEM,MAAMC,uBAAuB,GAAAf,OAAA,CAAAe,uBAAA,GAAG,CAAC,QAAQ,EAAE,GAAG,CAAC;AAC/C,MAAMC,sBAAsB,GAAAhB,OAAA,CAAAgB,sBAAA,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AAC9C,MAAMC,sBAAsB,GAAAjB,OAAA,CAAAiB,sBAAA,GAAG,CAAC,QAAQ,CAAC;AACzC,MAAMC,eAAe,GAAAlB,OAAA,CAAAkB,eAAA,GAAG,CAC7B,MAAM,EACN,OAAO,EACP,GAAGH,uBAAuB,EAC1B,GAAGC,sBAAsB,EACzB,GAAGC,sBAAsB,CAC1B;AAEM,MAAME,YAAY,GAAAnB,OAAA,CAAAmB,YAAA,GAAG;EAC1BC,QAAQ,EAAE,CAAC,gBAAgB,EAAE,gBAAgB,EAAE,YAAY,CAAC;EAC5DC,KAAK,EAAE,CAAC,OAAO,EAAE,KAAK,EAAE,KAAK;AAC/B,CAAU;AAIRrB,OAAO,CAACsB,mBAAmB,GAAGC,MAAM,CAACC,GAAG,CAAC,6BAA6B,CAAC;AAEvExB,OAAO,CAACyB,iBAAiB,GAAGF,MAAM,CAACC,GAAG,CACpC,0CACF,CAAC","ignoreList":[]}
node_modules/@babel/types/lib/constants/index.js:6:exports.UPDATE_OPERATORS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.STATEMENT_OR_BLOCK_KEYS = exports.NUMBER_UNARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.LOGICAL_OPERATORS = exports.INHERIT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.EQUALITY_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.COMMENT_KEYS = exports.BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.BINARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = void 0;
node_modules/@babel/types/lib/constants/index.js:11:const LOGICAL_OPERATORS = exports.LOGICAL_OPERATORS = ["||", "&&", "??"];
node_modules/@babel/types/lib/constants/index.js:19:const ASSIGNMENT_OPERATORS = exports.ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map(op => op + "="), ...LOGICAL_OPERATORS.map(op => op + "=")];
node_modules/@babel/parser/CHANGELOG.md:16:See the [Babel Changelog](https://github.com/babel/babel/blob/main/CHANGELOG.md) for the pre-6.8.0 version Changelog.
node_modules/playwright-core/lib/utilsBundleImpl/index.js:155:${o}`:r}}t?(Array.prototype.push.apply(e.errors,this.errors),Array.prototype.push.apply(e.warnings,this.warnings)):(e.errors=this.errors,e.warnings=this.warnings),this.prelude=[],this.errors=[],this.warnings=[]}streamInfo(){return{comment:ly(this.prelude).comment,directives:this.directives,errors:this.errors,warnings:this.warnings}}*compose(e,t=!1,r=-1){for(let n of e)yield*this.next(n);yield*this.end(t,r)}*next(e){switch(process.env.LOG_STREAM&&console.dir(e,{depth:null}),e.type){case"directive":this.directives.add(e.source,(t,r,n)=>{let s=zn(e);s[0]+=t,this.onError(s,"BAD_DIRECTIVE",r,n)}),this.prelude.push(e.source),this.atDirectives=!0;break;case"document":{let t=JT.composeDoc(this.options,this.directives,e,this.onError);this.atDirectives&&!t.directives.docStart&&this.onError(e,"MISSING_CHAR","Missing directives-end/doc-start indicator line"),this.decorate(t,!1),this.doc&&(yield this.doc),this.doc=t,this.atDirectives=!1;break}case"byte-order-mark":case"space":break;case"comment":case"newline":this.prelude.push(e.source);break;case"error":{let t=e.source?`${e.message}: ${JSON.stringify(e.source)}`:e.message,r=new Kn.YAMLParseError(zn(e),"UNEXPECTED_TOKEN",t);this.atDirectives||!this.doc?this.errors.push(r):this.doc.errors.push(r);break}case"doc-end":{if(!this.doc){let r="Unexpected doc-end without preceding document";this.errors.push(new Kn.YAMLParseError(zn(e),"UNEXPECTED_TOKEN",r));break}this.doc.directives.docEnd=!0;let t=ZT.resolveEnd(e.end,e.offset+e.source.length,this.doc.options.strict,this.onError);if(this.decorate(this.doc,!0),t.comment){let r=this.doc.comment;this.doc.comment=r?`${r}
node_modules/playwright-core/lib/utilsBundleImpl/index.js:185:`?yield*this.pushCount(2):0}*pushSpaces(e){let t=this.pos-1,r;do r=this.buffer[++t];while(r===" "||e&&r==="	");let n=t-this.pos;return n>0&&(yield this.buffer.substr(this.pos,n),this.pos=t),n}*pushUntil(e){let t=this.pos,r=this.buffer[t];for(;!e(r);)r=this.buffer[++t];return yield*this.pushToIndex(t,!1)}};_y.Lexer=rf});var of=x(wy=>{"use strict";var sf=class{constructor(){this.lineStarts=[],this.addNewLine=e=>this.lineStarts.push(e),this.linePos=e=>{let t=0,r=this.lineStarts.length;for(;t<r;){let s=t+r>>1;this.lineStarts[s]<e?t=s+1:r=s}if(this.lineStarts[t]===e)return{line:t+1,col:1};if(t===0)return{line:0,col:e};let n=this.lineStarts[t-1];return{line:t,col:e-n+1}}}};wy.LineCounter=sf});var lf=x(ky=>{"use strict";var xy=aa(),mA=nf();function ur(i,e){for(let t=0;t<i.length;++t)if(i[t].type===e)return!0;return!1}function Sy(i){for(let e=0;e<i.length;++e)switch(i[e].type){case"space":case"comment":case"newline":break;default:return e}return-1}function Oy(i){switch(i==null?void 0:i.type){case"alias":case"scalar":case"single-quoted-scalar":case"double-quoted-scalar":case"flow-collection":return!0;default:return!1}}function ca(i){var e;switch(i.type){case"document":return i.start;case"block-map":{let t=i.items[i.items.length-1];return(e=t.sep)!=null?e:t.start}case"block-seq":return i.items[i.items.length-1].start;default:return[]}}function Jr(i){var t;if(i.length===0)return[];let e=i.length;e:for(;--e>=0;)switch(i[e].type){case"doc-start":case"explicit-key-ind":case"map-value-ind":case"seq-item-ind":case"newline":break e}for(;((t=i[++e])==null?void 0:t.type)==="space";);return i.splice(e,i.length)}function Ey(i){if(i.start.type==="flow-seq-start")for(let e of i.items)e.sep&&!e.value&&!ur(e.start,"explicit-key-ind")&&!ur(e.sep,"map-value-ind")&&(e.key&&(e.value=e.key),delete e.key,Oy(e.value)?e.value.end?Array.prototype.push.apply(e.value.end,e.sep):e.value.end=e.sep:Array.prototype.push.apply(e.start,e.sep),delete e.sep)}var af=class{constructor(e){this.atNewLine=!0,this.atScalar=!1,this.indent=0,this.offset=0,this.onKeyLine=!1,this.stack=[],this.source="",this.type="",this.lexer=new mA.Lexer,this.onNewLine=e}*parse(e,t=!1){this.onNewLine&&this.offset===0&&this.onNewLine(0);for(let r of this.lexer.lex(e,t))yield*this.next(r);t||(yield*this.end())}*next(e){if(this.source=e,process.env.LOG_TOKENS&&console.log("|",xy.prettyToken(e)),this.atScalar){this.atScalar=!1,yield*this.step(),this.offset+=e.length;return}let t=xy.tokenType(e);if(t)if(t==="scalar")this.atNewLine=!1,this.atScalar=!0,this.type="scalar";else{switch(this.type=t,yield*this.step(),t){case"newline":this.atNewLine=!0,this.indent=0,this.onNewLine&&this.onNewLine(this.offset+e.length);break;case"space":this.atNewLine&&e[0]===" "&&(this.indent+=e.length);break;case"explicit-key-ind":case"map-value-ind":case"seq-item-ind":this.atNewLine&&(this.indent+=e.length);break;case"doc-mode":case"flow-error-end":return;default:this.atNewLine=!1}this.offset+=e.length}else{let r=`Not a YAML token: ${e}`;yield*this.pop({type:"error",offset:this.offset,message:r,source:e}),this.offset+=e.length}}*end(){for(;this.stack.length>0;)yield*this.pop()}get sourceToken(){return{type:this.type,offset:this.offset,indent:this.indent,source:this.source}}*step(){let e=this.peek(1);if(this.type==="doc-end"&&(!e||e.type!=="doc-end")){for(;this.stack.length>0;)yield*this.pop();this.stack.push({type:"doc-end",offset:this.offset,source:this.source});return}if(!e)return yield*this.stream();switch(e.type){case"document":return yield*this.document(e);case"alias":case"scalar":case"single-quoted-scalar":case"double-quoted-scalar":return yield*this.scalar(e);case"block-scalar":return yield*this.blockScalar(e);case"block-map":return yield*this.blockMap(e);case"block-seq":return yield*this.blockSequence(e);case"flow-collection":return yield*this.flowCollection(e);case"doc-end":return yield*this.documentEnd(e)}yield*this.pop()}peek(e){return this.stack[this.stack.length-e]}*pop(e){let t=e!=null?e:this.stack.pop();if(!t)yield{type:"error",offset:this.offset,source:"",message:"Tried to pop an empty stack"};else if(this.stack.length===0)yield t;else{let r=this.peek(1);switch(t.type==="block-scalar"?t.indent="indent"in r?r.indent:0:t.type==="flow-collection"&&r.type==="document"&&(t.indent=0),t.type==="flow-collection"&&Ey(t),r.type){case"document":r.value=t;break;case"block-scalar":r.props.push(t);break;case"block-map":{let n=r.items[r.items.length-1];if(n.value){r.items.push({start:[],key:t,sep:[]}),this.onKeyLine=!0;return}else if(n.sep)n.value=t;else{Object.assign(n,{key:t,sep:[]}),this.onKeyLine=!n.explicitKey;return}break}case"block-seq":{let n=r.items[r.items.length-1];n.value?r.items.push({start:[],value:t}):n.value=t;break}case"flow-collection":{let n=r.items[r.items.length-1];!n||n.value?r.items.push({start:[],key:t,sep:[]}):n.sep?n.value=t:Object.assign(n,{key:t,sep:[]});return}default:yield*this.pop(),yield*this.pop(t)}if((r.type==="document"||r.type==="block-map"||r.type==="block-seq")&&(t.type==="block-map"||t.type==="block-seq")){let n=t.items[t.items.length-1];n&&!n.sep&&!n.value&&n.start.length>0&&Sy(n.start)===-1&&(t.indent===0||n.start.every(s=>s.type!=="comment"||s.indent<t.indent))&&(r.type==="document"?r.end=n.start:r.items.push({start:n.start}),t.items.splice(-1,1))}}}*stream(){switch(this.type){case"directive-line":yield{type:"directive",offset:this.offset,source:this.source};return;case"byte-order-mark":case"space":case"comment":case"newline":yield this.sourceToken;return;case"doc-mode":case"doc-start":{let e={type:"document",offset:this.offset,start:[]};this.type==="doc-start"&&e.start.push(this.sourceToken),this.stack.push(e);return}}yield{type:"error",offset:this.offset,message:`Unexpected ${this.type} token in YAML stream`,source:this.source}}*document(e){if(e.value)return yield*this.lineEnd(e);switch(this.type){case"doc-start":{Sy(e.start)!==-1?(yield*this.pop(),yield*this.step()):e.start.push(this.sourceToken);return}case"anchor":case"tag":case"space":case"comment":case"newline":e.start.push(this.sourceToken);return}let t=this.startBlockValue(e);t?this.stack.push(t):yield{type:"error",offset:this.offset,message:`Unexpected ${this.type} token in YAML document`,source:this.source}}*scalar(e){if(this.type==="map-value-ind"){let t=ca(this.peek(2)),r=Jr(t),n;e.end?(n=e.end,n.push(this.sourceToken),delete e.end):n=[this.sourceToken];let s={type:"block-map",offset:e.offset,indent:e.indent,items:[{start:r,key:e,sep:n}]};this.onKeyLine=!0,this.stack[this.stack.length-1]=s}else yield*this.lineEnd(e)}*blockScalar(e){switch(this.type){case"space":case"comment":case"newline":e.props.push(this.sourceToken);return;case"scalar":if(e.source=this.source,this.atNewLine=!0,this.indent=0,this.onNewLine){let t=this.source.indexOf(`
node_modules/playwright-core/lib/mcpBundleImpl/index.js:107:]`;continue}n+=o[l],o[l]==="\\"?i=!0:a&&o[l]==="]"?a=!1:!a&&o[l]==="["&&(a=!0)}try{new RegExp(n)}catch{return console.warn(`Could not convert regex pattern at ${e.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`),t.source}return n}function xf(t,e){var o,n,i,a,c,u,l;if(e.target==="openAi"&&console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead."),e.target==="openApi3"&&((o=t.keyType)==null?void 0:o._def.typeName)===E.ZodEnum)return{type:"object",required:t.keyType._def.values,properties:t.keyType._def.values.reduce((d,s)=>{var f;return{...d,[s]:(f=H(t.valueType._def,{...e,currentPath:[...e.currentPath,"properties",s]}))!=null?f:Te(e)}},{}),additionalProperties:e.rejectedAdditionalProperties};let r={type:"object",additionalProperties:(n=H(t.valueType._def,{...e,currentPath:[...e.currentPath,"additionalProperties"]}))!=null?n:e.allowedAdditionalProperties};if(e.target==="openApi3")return r;if(((i=t.keyType)==null?void 0:i._def.typeName)===E.ZodString&&((a=t.keyType._def.checks)!=null&&a.length)){let{type:d,...s}=bf(t.keyType._def,e);return{...r,propertyNames:s}}else{if(((c=t.keyType)==null?void 0:c._def.typeName)===E.ZodEnum)return{...r,propertyNames:{enum:t.keyType._def.values}};if(((u=t.keyType)==null?void 0:u._def.typeName)===E.ZodBranded&&t.keyType._def.type._def.typeName===E.ZodString&&((l=t.keyType._def.type._def.checks)!=null&&l.length)){let{type:d,...s}=$f(t.keyType._def,e);return{...r,propertyNames:s}}}return r}function uw(t,e){if(e.mapStrategy==="record")return xf(t,e);let r=H(t.keyType._def,{...e,currentPath:[...e.currentPath,"items","items","0"]})||Te(e),o=H(t.valueType._def,{...e,currentPath:[...e.currentPath,"items","items","1"]})||Te(e);return{type:"array",maxItems:125,items:{type:"array",items:[r,o],minItems:2,maxItems:2}}}function lw(t){let e=t.values,o=Object.keys(t.values).filter(i=>typeof e[e[i]]!="number").map(i=>e[i]),n=Array.from(new Set(o.map(i=>typeof i)));return{type:n.length===1?n[0]==="string"?"string":"number":["string","number"],enum:o}}function dw(t){return t.target==="openAi"?void 0:{not:Te({...t,currentPath:[...t.currentPath,"not"]})}}function fw(t){return t.target==="openApi3"?{enum:["null"],nullable:!0}:{type:"null"}}var Xs={ZodString:"string",ZodNumber:"number",ZodBigInt:"integer",ZodBoolean:"boolean",ZodNull:"null"};function mw(t,e){if(e.target==="openApi3")return pw(t,e);let r=t.options instanceof Map?Array.from(t.options.values()):t.options;if(r.every(o=>o._def.typeName in Xs&&(!o._def.checks||!o._def.checks.length))){let o=r.reduce((n,i)=>{let a=Xs[i._def.typeName];return a&&!n.includes(a)?[...n,a]:n},[]);return{type:o.length>1?o:o[0]}}else if(r.every(o=>o._def.typeName==="ZodLiteral"&&!o.description)){let o=r.reduce((n,i)=>{let a=typeof i._def.value;switch(a){case"string":case"number":case"boolean":return[...n,a];case"bigint":return[...n,"integer"];case"object":if(i._def.value===null)return[...n,"null"];case"symbol":case"undefined":case"function":default:return n}},[]);if(o.length===r.length){let n=o.filter((i,a,c)=>c.indexOf(i)===a);return{type:n.length>1?n:n[0],enum:r.reduce((i,a)=>i.includes(a._def.value)?i:[...i,a._def.value],[])}}}else if(r.every(o=>o._def.typeName==="ZodEnum"))return{type:"string",enum:r.reduce((o,n)=>[...o,...n._def.values.filter(i=>!o.includes(i))],[])};return pw(t,e)}var pw=(t,e)=>{let r=(t.options instanceof Map?Array.from(t.options.values()):t.options).map((o,n)=>H(o._def,{...e,currentPath:[...e.currentPath,"anyOf",`${n}`]})).filter(o=>!!o&&(!e.strictUnions||typeof o=="object"&&Object.keys(o).length>0));return r.length?{anyOf:r}:void 0};function hw(t,e){if(["ZodString","ZodNumber","ZodBigInt","ZodBoolean","ZodNull"].includes(t.innerType._def.typeName)&&(!t.innerType._def.checks||!t.innerType._def.checks.length))return e.target==="openApi3"?{type:Xs[t.innerType._def.typeName],nullable:!0}:{type:[Xs[t.innerType._def.typeName],"null"]};if(e.target==="openApi3"){let o=H(t.innerType._def,{...e,currentPath:[...e.currentPath]});return o&&"$ref"in o?{allOf:[o],nullable:!0}:o&&{...o,nullable:!0}}let r=H(t.innerType._def,{...e,currentPath:[...e.currentPath,"anyOf","0"]});return r&&{anyOf:[r,{type:"null"}]}}function gw(t,e){let r={type:"number"};if(!t.checks)return r;for(let o of t.checks)switch(o.kind){case"int":r.type="integer",Dv(r,"type",o.message,e);break;case"min":e.target==="jsonSchema7"?o.inclusive?ce(r,"minimum",o.value,o.message,e):ce(r,"exclusiveMinimum",o.value,o.message,e):(o.inclusive||(r.exclusiveMinimum=!0),ce(r,"minimum",o.value,o.message,e));break;case"max":e.target==="jsonSchema7"?o.inclusive?ce(r,"maximum",o.value,o.message,e):ce(r,"exclusiveMaximum",o.value,o.message,e):(o.inclusive||(r.exclusiveMaximum=!0),ce(r,"maximum",o.value,o.message,e));break;case"multipleOf":ce(r,"multipleOf",o.value,o.message,e);break}return r}function vw(t,e){let r=e.target==="openAi",o={type:"object",properties:{}},n=[],i=t.shape();for(let c in i){let u=i[c];if(u===void 0||u._def===void 0)continue;let l=MO(u);l&&r&&(u._def.typeName==="ZodOptional"&&(u=u._def.innerType),u.isNullable()||(u=u.nullable()),l=!1);let d=H(u._def,{...e,currentPath:[...e.currentPath,"properties",c],propertyPath:[...e.currentPath,"properties",c]});d!==void 0&&(o.properties[c]=d,l||n.push(c))}n.length&&(o.required=n);let a=ZO(t,e);return a!==void 0&&(o.additionalProperties=a),o}function ZO(t,e){if(t.catchall._def.typeName!=="ZodNever")return H(t.catchall._def,{...e,currentPath:[...e.currentPath,"additionalProperties"]});switch(t.unknownKeys){case"passthrough":return e.allowedAdditionalProperties;case"strict":return e.rejectedAdditionalProperties;case"strip":return e.removeAdditionalStrategy==="strict"?e.allowedAdditionalProperties:e.rejectedAdditionalProperties}}function MO(t){try{return t.isOptional()}catch{return!0}}var _w=(t,e)=>{var o;if(e.currentPath.toString()===((o=e.propertyPath)==null?void 0:o.toString()))return H(t.innerType._def,e);let r=H(t.innerType._def,{...e,currentPath:[...e.currentPath,"anyOf","1"]});return r?{anyOf:[{not:Te(e)},r]}:Te(e)};var yw=(t,e)=>{if(e.pipeStrategy==="input")return H(t.in._def,e);if(e.pipeStrategy==="output")return H(t.out._def,e);let r=H(t.in._def,{...e,currentPath:[...e.currentPath,"allOf","0"]}),o=H(t.out._def,{...e,currentPath:[...e.currentPath,"allOf",r?"1":"0"]});return{allOf:[r,o].filter(n=>n!==void 0)}};function $w(t,e){return H(t.type._def,e)}function bw(t,e){let o={type:"array",uniqueItems:!0,items:H(t.valueType._def,{...e,currentPath:[...e.currentPath,"items"]})};return t.minSize&&ce(o,"minItems",t.minSize.value,t.minSize.message,e),t.maxSize&&ce(o,"maxItems",t.maxSize.value,t.maxSize.message,e),o}function xw(t,e){return t.rest?{type:"array",minItems:t.items.length,items:t.items.map((r,o)=>H(r._def,{...e,currentPath:[...e.currentPath,"items",`${o}`]})).reduce((r,o)=>o===void 0?r:[...r,o],[]),additionalItems:H(t.rest._def,{...e,currentPath:[...e.currentPath,"additionalItems"]})}:{type:"array",minItems:t.items.length,maxItems:t.items.length,items:t.items.map((r,o)=>H(r._def,{...e,currentPath:[...e.currentPath,"items",`${o}`]})).reduce((r,o)=>o===void 0?r:[...r,o],[])}}function ww(t){return{not:Te(t)}}function kw(t){return Te(t)}var Sw=(t,e)=>H(t.innerType._def,e);var zw=(t,e,r)=>{switch(e){case E.ZodString:return bf(t,r);case E.ZodNumber:return gw(t,r);case E.ZodObject:return vw(t,r);case E.ZodBigInt:return ew(t,r);case E.ZodBoolean:return tw();case E.ZodDate:return Uv(t,r);case E.ZodUndefined:return ww(r);case E.ZodNull:return fw(r);case E.ZodArray:return Qx(t,r);case E.ZodUnion:case E.ZodDiscriminatedUnion:return mw(t,r);case E.ZodIntersection:return aw(t,r);case E.ZodTuple:return xw(t,r);case E.ZodRecord:return xf(t,r);case E.ZodLiteral:return sw(t,r);case E.ZodEnum:return iw(t);case E.ZodNativeEnum:return lw(t);case E.ZodNullable:return hw(t,r);case E.ZodOptional:return _w(t,r);case E.ZodMap:return uw(t,r);case E.ZodSet:return bw(t,r);case E.ZodLazy:return()=>t.getter()._def;case E.ZodPromise:return $w(t,r);case E.ZodNaN:case E.ZodNever:return dw(r);case E.ZodEffects:return ow(t,r);case E.ZodAny:return Te(r);case E.ZodUnknown:return kw(r);case E.ZodDefault:return nw(t,r);case E.ZodBranded:return $f(t,r);case E.ZodReadonly:return Sw(t,r);case E.ZodCatch:return rw(t,r);case E.ZodPipeline:return yw(t,r);case E.ZodFunction:case E.ZodVoid:case E.ZodSymbol:return;default:return(o=>{})(e)}};function H(t,e,r=!1){var c;let o=e.seen.get(t);if(e.override){let u=(c=e.override)==null?void 0:c.call(e,t,e,o,r);if(u!==Gx)return u}if(o&&!r){let u=qO(o,e);if(u!==void 0)return u}let n={def:t,path:e.currentPath,jsonSchema:void 0};e.seen.set(t,n);let i=zw(t,t.typeName,e),a=typeof i=="function"?H(i(),e):i;if(a&&LO(t,e,a),e.postProcess){let u=e.postProcess(a,t,e);return n.jsonSchema=a,u}return n.jsonSchema=a,a}var qO=(t,e)=>{switch(e.$refStrategy){case"root":return{$ref:t.path.join("/")};case"relative":return{$ref:yf(e.currentPath,t.path)};case"none":case"seen":return t.path.length<e.currentPath.length&&t.path.every((r,o)=>e.currentPath[o]===r)?(console.warn(`Recursive reference detected at ${e.currentPath.join("/")}! Defaulting to any`),Te(e)):e.$refStrategy==="seen"?Te(e):void 0}},LO=(t,e,r)=>(t.description&&(r.description=t.description,e.markdownDescription&&(r.markdownDescription=t.description)),r);var wf=(t,e)=>{var u;let r=Yx(e),o=typeof e=="object"&&e.definitions?Object.entries(e.definitions).reduce((l,[d,s])=>{var f;return{...l,[d]:(f=H(s._def,{...r,currentPath:[...r.basePath,r.definitionPath,d]},!0))!=null?f:Te(r)}},{}):void 0,n=typeof e=="string"?e:(e==null?void 0:e.nameStrategy)==="title"||e==null?void 0:e.name,i=(u=H(t._def,n===void 0?r:{...r,currentPath:[...r.basePath,r.definitionPath,n]},!1))!=null?u:Te(r),a=typeof e=="object"&&e.name!==void 0&&e.nameStrategy==="title"?e.name:void 0;a!==void 0&&(i.title=a),r.flags.hasReferencedOpenAiAnyType&&(o||(o={}),o[r.openAiAnyTypeName]||(o[r.openAiAnyTypeName]={type:["string","number","integer","boolean","array","null"],items:{$ref:r.$refStrategy==="relative"?"1":[...r.basePath,r.definitionPath,r.openAiAnyTypeName].join("/")}}));let c=n===void 0?o?{...i,[r.definitionPath]:o}:i:{$ref:[...r.$refStrategy==="relative"?[]:r.basePath,r.definitionPath,n].join("/"),[r.definitionPath]:{...o,[n]:i}};return r.target==="jsonSchema7"?c.$schema="http://json-schema.org/draft-07/schema#":(r.target==="jsonSchema2019-09"||r.target==="openAi")&&(c.$schema="https://json-schema.org/draft/2019-09/schema#"),r.target==="openAi"&&("anyOf"in c||"oneOf"in c||"allOf"in c||"type"in c&&Array.isArray(c.type))&&console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property."),c};function Mv(t){let e=Ko(t),r=e==null?void 0:e.method;if(!r)throw new Error("Schema is missing a method literal");let o=zx(r);if(typeof o!="string")throw new Error("Schema method literal must be a string");return o}function qv(t,e){let r=it(t,e);if(!r.success)throw r.error;return r.data}var VO=6e4,pi=class{constructor(e){this._options=e,this._requestMessageId=0,this._requestHandlers=new Map,this._requestHandlerAbortControllers=new Map,this._notificationHandlers=new Map,this._responseHandlers=new Map,this._progressHandlers=new Map,this._timeoutInfo=new Map,this._pendingDebouncedNotifications=new Set,this._taskProgressTokens=new Map,this._requestResolvers=new Map,this.setNotificationHandler(lf,r=>{this._oncancel(r)}),this.setNotificationHandler(li,r=>{this._onprogress(r)}),this.setRequestHandler(ui,r=>({})),this._taskStore=e==null?void 0:e.taskStore,this._taskMessageQueue=e==null?void 0:e.taskMessageQueue,this._taskStore&&(this.setRequestHandler(pf,async(r,o)=>{let n=await this._taskStore.getTask(r.params.taskId,o.sessionId);if(!n)throw new q(F.InvalidParams,"Failed to retrieve task: Task not found");return{...n}}),this.setRequestHandler(hf,async(r,o)=>{let n=async()=>{var c;let i=r.params.taskId;if(this._taskMessageQueue){let u;for(;u=await this._taskMessageQueue.dequeue(i,o.sessionId);){if(u.type==="response"||u.type==="error"){let l=u.message,d=l.id,s=this._requestResolvers.get(d);if(s)if(this._requestResolvers.delete(d),u.type==="response")s(l);else{let f=l,p=new q(f.error.code,f.error.message,f.error.data);s(p)}else{let f=u.type==="response"?"Response":"Error";this._onerror(new Error(`${f} handler missing for request ${d}`))}continue}await((c=this._transport)==null?void 0:c.send(u.message,{relatedRequestId:o.requestId}))}}let a=await this._taskStore.getTask(i,o.sessionId);if(!a)throw new q(F.InvalidParams,`Task not found: ${i}`);if(!cn(a.status))return await this._waitForTaskUpdate(i,o.signal),await n();if(cn(a.status)){let u=await this._taskStore.getTaskResult(i,o.sessionId);return this._clearTaskQueue(i),{...u,_meta:{...u._meta,[an]:{taskId:i}}}}return await n()};return await n()}),this.setRequestHandler(gf,async(r,o)=>{var n;try{let{tasks:i,nextCursor:a}=await this._taskStore.listTasks((n=r.params)==null?void 0:n.cursor,o.sessionId);return{tasks:i,nextCursor:a,_meta:{}}}catch(i){throw new q(F.InvalidParams,`Failed to list tasks: ${i instanceof Error?i.message:String(i)}`)}}),this.setRequestHandler(_f,async(r,o)=>{try{let n=await this._taskStore.getTask(r.params.taskId,o.sessionId);if(!n)throw new q(F.InvalidParams,`Task not found: ${r.params.taskId}`);if(cn(n.status))throw new q(F.InvalidParams,`Cannot cancel task in terminal status: ${n.status}`);await this._taskStore.updateTaskStatus(r.params.taskId,"cancelled","Client cancelled task execution.",o.sessionId),this._clearTaskQueue(r.params.taskId);let i=await this._taskStore.getTask(r.params.taskId,o.sessionId);if(!i)throw new q(F.InvalidParams,`Task not found after cancellation: ${r.params.taskId}`);return{_meta:{},...i}}catch(n){throw n instanceof q?n:new q(F.InvalidRequest,`Failed to cancel task: ${n instanceof Error?n.message:String(n)}`)}}))}async _oncancel(e){if(!e.params.requestId)return;let r=this._requestHandlerAbortControllers.get(e.params.requestId);r==null||r.abort(e.params.reason)}_setupTimeout(e,r,o,n,i=!1){this._timeoutInfo.set(e,{timeoutId:setTimeout(n,r),startTime:Date.now(),timeout:r,maxTotalTimeout:o,resetTimeoutOnProgress:i,onTimeout:n})}_resetTimeout(e){let r=this._timeoutInfo.get(e);if(!r)return!1;let o=Date.now()-r.startTime;if(r.maxTotalTimeout&&o>=r.maxTotalTimeout)throw this._timeoutInfo.delete(e),q.fromError(F.RequestTimeout,"Maximum total timeout exceeded",{maxTotalTimeout:r.maxTotalTimeout,totalElapsed:o});return clearTimeout(r.timeoutId),r.timeoutId=setTimeout(r.onTimeout,r.timeout),!0}_cleanupTimeout(e){let r=this._timeoutInfo.get(e);r&&(clearTimeout(r.timeoutId),this._timeoutInfo.delete(e))}async connect(e){var i,a,c;this._transport=e;let r=(i=this.transport)==null?void 0:i.onclose;this._transport.onclose=()=>{r==null||r(),this._onclose()};let o=(a=this.transport)==null?void 0:a.onerror;this._transport.onerror=u=>{o==null||o(u),this._onerror(u)};let n=(c=this._transport)==null?void 0:c.onmessage;this._transport.onmessage=(u,l)=>{n==null||n(u,l),Ft(u)||ci(u)?this._onresponse(u):ar(u)?this._onrequest(u,l):Zx(u)?this._onnotification(u):this._onerror(new Error(`Unknown message type: ${JSON.stringify(u)}`))},await this._transport.start()}_onclose(){var o;let e=this._responseHandlers;this._responseHandlers=new Map,this._progressHandlers.clear(),this._taskProgressTokens.clear(),this._pendingDebouncedNotifications.clear();let r=q.fromError(F.ConnectionClosed,"Connection closed");this._transport=void 0,(o=this.onclose)==null||o.call(this);for(let n of e.values())n(r)}_onerror(e){var r;(r=this.onerror)==null||r.call(this,e)}_onnotification(e){var o;let r=(o=this._notificationHandlers.get(e.method))!=null?o:this.fallbackNotificationHandler;r!==void 0&&Promise.resolve().then(()=>r(e)).catch(n=>this._onerror(new Error(`Uncaught error in notification handler: ${n}`)))}_onrequest(e,r){var d,s,f,p,m;let o=(d=this._requestHandlers.get(e.method))!=null?d:this.fallbackRequestHandler,n=this._transport,i=(p=(f=(s=e.params)==null?void 0:s._meta)==null?void 0:f[an])==null?void 0:p.taskId;if(o===void 0){let h={jsonrpc:"2.0",id:e.id,error:{code:F.MethodNotFound,message:"Method not found"}};i&&this._taskMessageQueue?this._enqueueTaskMessage(i,{type:"error",message:h,timestamp:Date.now()},n==null?void 0:n.sessionId).catch(g=>this._onerror(new Error(`Failed to enqueue error response: ${g}`))):n==null||n.send(h).catch(g=>this._onerror(new Error(`Failed to send an error response: ${g}`)));return}let a=new AbortController;this._requestHandlerAbortControllers.set(e.id,a);let c=Dx(e.params)?e.params.task:void 0,u=this._taskStore?this.requestTaskStore(e,n==null?void 0:n.sessionId):void 0,l={signal:a.signal,sessionId:n==null?void 0:n.sessionId,_meta:(m=e.params)==null?void 0:m._meta,sendNotification:async h=>{let g={relatedRequestId:e.id};i&&(g.relatedTask={taskId:i}),await this.notification(h,g)},sendRequest:async(h,g,y)=>{var b,x;let w={...y,relatedRequestId:e.id};i&&!w.relatedTask&&(w.relatedTask={taskId:i});let k=(x=(b=w.relatedTask)==null?void 0:b.taskId)!=null?x:i;return k&&u&&await u.updateTaskStatus(k,"input_required"),await this.request(h,g,w)},authInfo:r==null?void 0:r.authInfo,requestId:e.id,requestInfo:r==null?void 0:r.requestInfo,taskId:i,taskStore:u,taskRequestedTtl:c==null?void 0:c.ttl,closeSSEStream:r==null?void 0:r.closeSSEStream,closeStandaloneSSEStream:r==null?void 0:r.closeStandaloneSSEStream};Promise.resolve().then(()=>{c&&this.assertTaskHandlerCapability(e.method)}).then(()=>o(e,l)).then(async h=>{if(a.signal.aborted)return;let g={result:h,jsonrpc:"2.0",id:e.id};i&&this._taskMessageQueue?await this._enqueueTaskMessage(i,{type:"response",message:g,timestamp:Date.now()},n==null?void 0:n.sessionId):await(n==null?void 0:n.send(g))},async h=>{var y;if(a.signal.aborted)return;let g={jsonrpc:"2.0",id:e.id,error:{code:Number.isSafeInteger(h.code)?h.code:F.InternalError,message:(y=h.message)!=null?y:"Internal error",...h.data!==void 0&&{data:h.data}}};i&&this._taskMessageQueue?await this._enqueueTaskMessage(i,{type:"error",message:g,timestamp:Date.now()},n==null?void 0:n.sessionId):await(n==null?void 0:n.send(g))}).catch(h=>this._onerror(new Error(`Failed to send response: ${h}`))).finally(()=>{this._requestHandlerAbortControllers.delete(e.id)})}_onprogress(e){let{progressToken:r,...o}=e.params,n=Number(r),i=this._progressHandlers.get(n);if(!i){this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(e)}`));return}let a=this._responseHandlers.get(n),c=this._timeoutInfo.get(n);if(c&&a&&c.resetTimeoutOnProgress)try{this._resetTimeout(n)}catch(u){this._responseHandlers.delete(n),this._progressHandlers.delete(n),this._cleanupTimeout(n),a(u);return}i(o)}_onresponse(e){let r=Number(e.id),o=this._requestResolvers.get(r);if(o){if(this._requestResolvers.delete(r),Ft(e))o(e);else{let a=new q(e.error.code,e.error.message,e.error.data);o(a)}return}let n=this._responseHandlers.get(r);if(n===void 0){this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(e)}`));return}this._responseHandlers.delete(r),this._cleanupTimeout(r);let i=!1;if(Ft(e)&&e.result&&typeof e.result=="object"){let a=e.result;if(a.task&&typeof a.task=="object"){let c=a.task;typeof c.taskId=="string"&&(i=!0,this._taskProgressTokens.set(c.taskId,r))}}if(i||this._progressHandlers.delete(r),Ft(e))n(e);else{let a=q.fromError(e.error.code,e.error.message,e.error.data);n(a)}}get transport(){return this._transport}async close(){var e;await((e=this._transport)==null?void 0:e.close())}async*requestStream(e,r,o){var a,c,u,l;let{task:n}=o!=null?o:{};if(!n){try{yield{type:"result",result:await this.request(e,r,o)}}catch(d){yield{type:"error",error:d instanceof q?d:new q(F.InternalError,String(d))}}return}let i;try{let d=await this.request(e,wr,o);if(d.task)i=d.task.taskId,yield{type:"taskCreated",task:d.task};else throw new q(F.InternalError,"Task creation did not return a task");for(;;){let s=await this.getTask({taskId:i},o);if(yield{type:"taskStatus",task:s},cn(s.status)){s.status==="completed"?yield{type:"result",result:await this.getTaskResult({taskId:i},r,o)}:s.status==="failed"?yield{type:"error",error:new q(F.InternalError,`Task ${i} failed`)}:s.status==="cancelled"&&(yield{type:"error",error:new q(F.InternalError,`Task ${i} was cancelled`)});return}if(s.status==="input_required"){yield{type:"result",result:await this.getTaskResult({taskId:i},r,o)};return}let f=(u=(c=s.pollInterval)!=null?c:(a=this._options)==null?void 0:a.defaultTaskPollInterval)!=null?u:1e3;await new Promise(p=>setTimeout(p,f)),(l=o==null?void 0:o.signal)==null||l.throwIfAborted()}}catch(d){yield{type:"error",error:d instanceof q?d:new q(F.InternalError,String(d))}}}request(e,r,o){let{relatedRequestId:n,resumptionToken:i,onresumptiontoken:a,task:c,relatedTask:u}=o!=null?o:{};return new Promise((l,d)=>{var w,k,b,x,D,V,K;let s=se=>{d(se)};if(!this._transport){s(new Error("Not connected"));return}if(((w=this._options)==null?void 0:w.enforceStrictCapabilities)===!0)try{this.assertCapabilityForMethod(e.method),c&&this.assertTaskCapability(e.method)}catch(se){s(se);return}(k=o==null?void 0:o.signal)==null||k.throwIfAborted();let f=this._requestMessageId++,p={...e,jsonrpc:"2.0",id:f};o!=null&&o.onprogress&&(this._progressHandlers.set(f,o.onprogress),p.params={...e.params,_meta:{...((b=e.params)==null?void 0:b._meta)||{},progressToken:f}}),c&&(p.params={...p.params,task:c}),u&&(p.params={...p.params,_meta:{...((x=p.params)==null?void 0:x._meta)||{},[an]:u}});let m=se=>{var Oe;this._responseHandlers.delete(f),this._progressHandlers.delete(f),this._cleanupTimeout(f),(Oe=this._transport)==null||Oe.send({jsonrpc:"2.0",method:"notifications/cancelled",params:{requestId:f,reason:String(se)}},{relatedRequestId:n,resumptionToken:i,onresumptiontoken:a}).catch(Qt=>this._onerror(new Error(`Failed to send cancellation: ${Qt}`)));let De=se instanceof q?se:new q(F.RequestTimeout,String(se));d(De)};this._responseHandlers.set(f,se=>{var De;if(!((De=o==null?void 0:o.signal)!=null&&De.aborted)){if(se instanceof Error)return d(se);try{let Oe=it(r,se.result);Oe.success?l(Oe.data):d(Oe.error)}catch(Oe){d(Oe)}}}),(D=o==null?void 0:o.signal)==null||D.addEventListener("abort",()=>{var se;m((se=o==null?void 0:o.signal)==null?void 0:se.reason)});let h=(V=o==null?void 0:o.timeout)!=null?V:VO,g=()=>m(q.fromError(F.RequestTimeout,"Request timed out",{timeout:h}));this._setupTimeout(f,h,o==null?void 0:o.maxTotalTimeout,g,(K=o==null?void 0:o.resetTimeoutOnProgress)!=null?K:!1);let y=u==null?void 0:u.taskId;if(y){let se=De=>{let Oe=this._responseHandlers.get(f);Oe?Oe(De):this._onerror(new Error(`Response handler missing for side-channeled request ${f}`))};this._requestResolvers.set(f,se),this._enqueueTaskMessage(y,{type:"request",message:p,timestamp:Date.now()}).catch(De=>{this._cleanupTimeout(f),d(De)})}else this._transport.send(p,{relatedRequestId:n,resumptionToken:i,onresumptiontoken:a}).catch(se=>{this._cleanupTimeout(f),d(se)})})}async getTask(e,r){return this.request({method:"tasks/get",params:e},mf,r)}async getTaskResult(e,r,o){return this.request({method:"tasks/result",params:e},r,o)}async listTasks(e,r){return this.request({method:"tasks/list",params:e},vf,r)}async cancelTask(e,r){return this.request({method:"tasks/cancel",params:e},Lx,r)}async notification(e,r){var c,u,l,d,s;if(!this._transport)throw new Error("Not connected");this.assertNotificationCapability(e.method);let o=(c=r==null?void 0:r.relatedTask)==null?void 0:c.taskId;if(o){let f={...e,jsonrpc:"2.0",params:{...e.params,_meta:{...((u=e.params)==null?void 0:u._meta)||{},[an]:r.relatedTask}}};await this._enqueueTaskMessage(o,{type:"notification",message:f,timestamp:Date.now()});return}if(((d=(l=this._options)==null?void 0:l.debouncedNotificationMethods)!=null?d:[]).includes(e.method)&&!e.params&&!(r!=null&&r.relatedRequestId)&&!(r!=null&&r.relatedTask)){if(this._pendingDebouncedNotifications.has(e.method))return;this._pendingDebouncedNotifications.add(e.method),Promise.resolve().then(()=>{var p,m;if(this._pendingDebouncedNotifications.delete(e.method),!this._transport)return;let f={...e,jsonrpc:"2.0"};r!=null&&r.relatedTask&&(f={...f,params:{...f.params,_meta:{...((p=f.params)==null?void 0:p._meta)||{},[an]:r.relatedTask}}}),(m=this._transport)==null||m.send(f,r).catch(h=>this._onerror(h))});return}let a={...e,jsonrpc:"2.0"};r!=null&&r.relatedTask&&(a={...a,params:{...a.params,_meta:{...((s=a.params)==null?void 0:s._meta)||{},[an]:r.relatedTask}}}),await this._transport.send(a,r)}setRequestHandler(e,r){let o=Mv(e);this.assertRequestHandlerCapability(o),this._requestHandlers.set(o,(n,i)=>{let a=qv(e,n);return Promise.resolve(r(a,i))})}removeRequestHandler(e){this._requestHandlers.delete(e)}assertCanSetRequestHandler(e){if(this._requestHandlers.has(e))throw new Error(`A request handler for ${e} already exists, which would be overridden`)}setNotificationHandler(e,r){let o=Mv(e);this._notificationHandlers.set(o,n=>{let i=qv(e,n);return Promise.resolve(r(i))})}removeNotificationHandler(e){this._notificationHandlers.delete(e)}_cleanupTaskProgressHandler(e){let r=this._taskProgressTokens.get(e);r!==void 0&&(this._progressHandlers.delete(r),this._taskProgressTokens.delete(e))}async _enqueueTaskMessage(e,r,o){var i;if(!this._taskStore||!this._taskMessageQueue)throw new Error("Cannot enqueue task message: taskStore and taskMessageQueue are not configured");let n=(i=this._options)==null?void 0:i.maxTaskQueueSize;await this._taskMessageQueue.enqueue(e,r,o,n)}async _clearTaskQueue(e,r){if(this._taskMessageQueue){let o=await this._taskMessageQueue.dequeueAll(e,r);for(let n of o)if(n.type==="request"&&ar(n.message)){let i=n.message.id,a=this._requestResolvers.get(i);a?(a(new q(F.InternalError,"Task cancelled or completed")),this._requestResolvers.delete(i)):this._onerror(new Error(`Resolver missing for request ${i} during task ${e} cleanup`))}}}async _waitForTaskUpdate(e,r){var n,i,a;let o=(i=(n=this._options)==null?void 0:n.defaultTaskPollInterval)!=null?i:1e3;try{let c=await((a=this._taskStore)==null?void 0:a.getTask(e));c!=null&&c.pollInterval&&(o=c.pollInterval)}catch{}return new Promise((c,u)=>{if(r.aborted){u(new q(F.InvalidRequest,"Request cancelled"));return}let l=setTimeout(c,o);r.addEventListener("abort",()=>{clearTimeout(l),u(new q(F.InvalidRequest,"Request cancelled"))},{once:!0})})}requestTaskStore(e,r){let o=this._taskStore;if(!o)throw new Error("No task store configured");return{createTask:async n=>{if(!e)throw new Error("No request provided");return await o.createTask(n,e.id,{method:e.method,params:e.params},r)},getTask:async n=>{let i=await o.getTask(n,r);if(!i)throw new q(F.InvalidParams,"Failed to retrieve task: Task not found");return i},storeTaskResult:async(n,i,a)=>{await o.storeTaskResult(n,i,a,r);let c=await o.getTask(n,r);if(c){let u=Hs.parse({method:"notifications/tasks/status",params:c});await this.notification(u),cn(c.status)&&this._cleanupTaskProgressHandler(n)}},getTaskResult:n=>o.getTaskResult(n,r),updateTaskStatus:async(n,i,a)=>{let c=await o.getTask(n,r);if(!c)throw new q(F.InvalidParams,`Task "${n}" not found - it may have been cleaned up`);if(cn(c.status))throw new q(F.InvalidParams,`Cannot update task "${n}" from terminal status "${c.status}" to "${i}". Terminal states (completed, failed, cancelled) cannot transition to other states.`);await o.updateTaskStatus(n,i,a,r);let u=await o.getTask(n,r);if(u){let l=Hs.parse({method:"notifications/tasks/status",params:u});await this.notification(l),cn(u.status)&&this._cleanupTaskProgressHandler(n)}},listTasks:n=>o.listTasks(n,r)}}};function Iw(t){return t!==null&&typeof t=="object"&&!Array.isArray(t)}function kf(t,e){let r={...t};for(let o in e){let n=o,i=e[n];if(i===void 0)continue;let a=r[n];Iw(a)&&Iw(i)?r[n]={...a,...i}:r[n]=i}return r}var p0=er(zy(),1),m0=er(f0(),1);function RC(){let t=new p0.default({strict:!1,validateFormats:!0,validateSchema:!1,allErrors:!0});return(0,m0.default)(t),t}var Ei=class{constructor(e){this._ajv=e!=null?e:RC()}getValidator(e){var o;let r="$id"in e&&typeof e.$id=="string"?(o=this._ajv.getSchema(e.$id))!=null?o:this._ajv.compile(e):this._ajv.compile(e);return n=>r(n)?{valid:!0,data:n,errorMessage:void 0}:{valid:!1,data:void 0,errorMessage:this._ajv.errorsText(r.errors)}}};var sp=class{constructor(e){this._client=e}async*callToolStream(e,r=sn,o){var u;let n=this._client,i={...o,task:(u=o==null?void 0:o.task)!=null?u:n.isToolTask(e.name)?{}:void 0},a=n.requestStream({method:"tools/call",params:e},r,i),c=n.getToolOutputValidator(e.name);for await(let l of a){if(l.type==="result"&&c){let d=l.result;if(!d.structuredContent&&!d.isError){yield{type:"error",error:new q(F.InvalidRequest,`Tool ${e.name} has an output schema but did not return structured content`)};return}if(d.structuredContent)try{let s=c(d.structuredContent);if(!s.valid){yield{type:"error",error:new q(F.InvalidParams,`Structured content does not match the tool's output schema: ${s.errorMessage}`)};return}}catch(s){if(s instanceof q){yield{type:"error",error:s};return}yield{type:"error",error:new q(F.InvalidParams,`Failed to validate structured content: ${s instanceof Error?s.message:String(s)}`)};return}}yield l}}async getTask(e,r){return this._client.getTask({taskId:e},r)}async getTaskResult(e,r,o){return this._client.getTaskResult({taskId:e},r,o)}async listTasks(e,r){return this._client.listTasks(e?{cursor:e}:void 0,r)}async cancelTask(e,r){return this._client.cancelTask({taskId:e},r)}requestStream(e,r,o){return this._client.requestStream(e,r,o)}};function cp(t,e,r){var o;if(!t)throw new Error(`${r} does not support task creation (required for ${e})`);switch(e){case"tools/call":if(!((o=t.tools)!=null&&o.call))throw new Error(`${r} does not support task creation for tools/call (required for ${e})`);break;default:break}}function up(t,e,r){var o,n;if(!t)throw new Error(`${r} does not support task creation (required for ${e})`);switch(e){case"sampling/createMessage":if(!((o=t.sampling)!=null&&o.createMessage))throw new Error(`${r} does not support task creation for sampling/createMessage (required for ${e})`);break;case"elicitation/create":if(!((n=t.elicitation)!=null&&n.create))throw new Error(`${r} does not support task creation for elicitation/create (required for ${e})`);break;default:break}}function lp(t,e){if(!(!t||e===null||typeof e!="object")){if(t.type==="object"&&t.properties&&typeof t.properties=="object"){let r=e,o=t.properties;for(let n of Object.keys(o)){let i=o[n];r[n]===void 0&&Object.prototype.hasOwnProperty.call(i,"default")&&(r[n]=i.default),r[n]!==void 0&&lp(i,r[n])}}if(Array.isArray(t.anyOf))for(let r of t.anyOf)typeof r!="boolean"&&lp(r,e);if(Array.isArray(t.oneOf))for(let r of t.oneOf)typeof r!="boolean"&&lp(r,e)}}function NC(t){if(!t)return{supportsFormMode:!1,supportsUrlMode:!1};let e=t.form!==void 0,r=t.url!==void 0;return{supportsFormMode:e||!e&&!r,supportsUrlMode:r}}var dp=class extends pi{constructor(e,r){var o,n;super(r),this._clientInfo=e,this._cachedToolOutputValidators=new Map,this._cachedKnownTaskTools=new Set,this._cachedRequiredTaskTools=new Set,this._listChangedDebounceTimers=new Map,this._capabilities=(o=r==null?void 0:r.capabilities)!=null?o:{},this._jsonSchemaValidator=(n=r==null?void 0:r.jsonSchemaValidator)!=null?n:new Ei,r!=null&&r.listChanged&&(this._pendingListChangedConfig=r.listChanged)}_setupListChangedHandlers(e){var r,o,n,i,a,c;e.tools&&((o=(r=this._serverCapabilities)==null?void 0:r.tools)!=null&&o.listChanged)&&this._setupListChangedHandler("tools",Pv,e.tools,async()=>(await this.listTools()).tools),e.prompts&&((i=(n=this._serverCapabilities)==null?void 0:n.prompts)!=null&&i.listChanged)&&this._setupListChangedHandler("prompts",Sv,e.prompts,async()=>(await this.listPrompts()).prompts),e.resources&&((c=(a=this._serverCapabilities)==null?void 0:a.resources)!=null&&c.listChanged)&&this._setupListChangedHandler("resources",_v,e.resources,async()=>(await this.listResources()).resources)}get experimental(){return this._experimental||(this._experimental={tasks:new sp(this)}),this._experimental}registerCapabilities(e){if(this.transport)throw new Error("Cannot register capabilities after connecting to transport");this._capabilities=kf(this._capabilities,e)}setRequestHandler(e,r){var c,u,l;let o=Ko(e),n=o==null?void 0:o.method;if(!n)throw new Error("Schema is missing a method literal");let i;if(rn(n)){let d=n,s=(c=d._zod)==null?void 0:c.def;i=(u=s==null?void 0:s.value)!=null?u:d.value}else{let d=n,s=d._def;i=(l=s==null?void 0:s.value)!=null?l:d.value}if(typeof i!="string")throw new Error("Schema method literal must be a string");let a=i;if(a==="elicitation/create"){let d=async(s,f)=>{var x,D,V;let p=it(jv,s);if(!p.success){let K=p.error instanceof Error?p.error.message:String(p.error);throw new q(F.InvalidParams,`Invalid elicitation request: ${K}`)}let{params:m}=p.data;m.mode=(x=m.mode)!=null?x:"form";let{supportsFormMode:h,supportsUrlMode:g}=NC(this._capabilities.elicitation);if(m.mode==="form"&&!h)throw new q(F.InvalidParams,"Client does not support form-mode elicitation requests");if(m.mode==="url"&&!g)throw new q(F.InvalidParams,"Client does not support URL-mode elicitation requests");let y=await Promise.resolve(r(s,f));if(m.task){let K=it(wr,y);if(!K.success){let se=K.error instanceof Error?K.error.message:String(K.error);throw new q(F.InvalidParams,`Invalid task creation result: ${se}`)}return K.data}let w=it(fi,y);if(!w.success){let K=w.error instanceof Error?w.error.message:String(w.error);throw new q(F.InvalidParams,`Invalid elicitation result: ${K}`)}let k=w.data,b=m.mode==="form"?m.requestedSchema:void 0;if(m.mode==="form"&&k.action==="accept"&&k.content&&b&&(V=(D=this._capabilities.elicitation)==null?void 0:D.form)!=null&&V.applyDefaults)try{lp(b,k.content)}catch{}return k};return super.setRequestHandler(e,d)}if(a==="sampling/createMessage"){let d=async(s,f)=>{let p=it(Ev,s);if(!p.success){let y=p.error instanceof Error?p.error.message:String(p.error);throw new q(F.InvalidParams,`Invalid sampling request: ${y}`)}let{params:m}=p.data,h=await Promise.resolve(r(s,f));if(m.task){let y=it(wr,h);if(!y.success){let w=y.error instanceof Error?y.error.message:String(y.error);throw new q(F.InvalidParams,`Invalid task creation result: ${w}`)}return y.data}let g=it(Gs,h);if(!g.success){let y=g.error instanceof Error?g.error.message:String(g.error);throw new q(F.InvalidParams,`Invalid sampling result: ${y}`)}return g.data};return super.setRequestHandler(e,d)}return super.setRequestHandler(e,r)}assertCapability(e,r){var o;if(!((o=this._serverCapabilities)!=null&&o[e]))throw new Error(`Server does not support ${e} (required for ${r})`)}async connect(e,r){if(await super.connect(e),e.sessionId===void 0)try{let o=await this.request({method:"initialize",params:{protocolVersion:on,capabilities:this._capabilities,clientInfo:this._clientInfo}},fv,r);if(o===void 0)throw new Error(`Server sent invalid initialize result: ${o}`);if(!Jn.includes(o.protocolVersion))throw new Error(`Server's protocol version is not supported: ${o.protocolVersion}`);this._serverCapabilities=o.capabilities,this._serverVersion=o.serverInfo,e.setProtocolVersion&&e.setProtocolVersion(o.protocolVersion),this._instructions=o.instructions,await this.notification({method:"notifications/initialized"}),this._pendingListChangedConfig&&(this._setupListChangedHandlers(this._pendingListChangedConfig),this._pendingListChangedConfig=void 0)}catch(o){throw this.close(),o}}getServerCapabilities(){return this._serverCapabilities}getServerVersion(){return this._serverVersion}getInstructions(){return this._instructions}assertCapabilityForMethod(e){var r,o,n,i,a;switch(e){case"logging/setLevel":if(!((r=this._serverCapabilities)!=null&&r.logging))throw new Error(`Server does not support logging (required for ${e})`);break;case"prompts/get":case"prompts/list":if(!((o=this._serverCapabilities)!=null&&o.prompts))throw new Error(`Server does not support prompts (required for ${e})`);break;case"resources/list":case"resources/templates/list":case"resources/read":case"resources/subscribe":case"resources/unsubscribe":if(!((n=this._serverCapabilities)!=null&&n.resources))throw new Error(`Server does not support resources (required for ${e})`);if(e==="resources/subscribe"&&!this._serverCapabilities.resources.subscribe)throw new Error(`Server does not support resource subscriptions (required for ${e})`);break;case"tools/call":case"tools/list":if(!((i=this._serverCapabilities)!=null&&i.tools))throw new Error(`Server does not support tools (required for ${e})`);break;case"completion/complete":if(!((a=this._serverCapabilities)!=null&&a.completions))throw new Error(`Server does not support completions (required for ${e})`);break;case"initialize":break;case"ping":break}}assertNotificationCapability(e){var r;switch(e){case"notifications/roots/list_changed":if(!((r=this._capabilities.roots)!=null&&r.listChanged))throw new Error(`Client does not support roots list changed notifications (required for ${e})`);break;case"notifications/initialized":break;case"notifications/cancelled":break;case"notifications/progress":break}}assertRequestHandlerCapability(e){if(this._capabilities)switch(e){case"sampling/createMessage":if(!this._capabilities.sampling)throw new Error(`Client does not support sampling capability (required for ${e})`);break;case"elicitation/create":if(!this._capabilities.elicitation)throw new Error(`Client does not support elicitation capability (required for ${e})`);break;case"roots/list":if(!this._capabilities.roots)throw new Error(`Client does not support roots capability (required for ${e})`);break;case"tasks/get":case"tasks/list":case"tasks/result":case"tasks/cancel":if(!this._capabilities.tasks)throw new Error(`Client does not support tasks capability (required for ${e})`);break;case"ping":break}}assertTaskCapability(e){var r,o;cp((o=(r=this._serverCapabilities)==null?void 0:r.tasks)==null?void 0:o.requests,e,"Server")}assertTaskHandlerCapability(e){var r;this._capabilities&&up((r=this._capabilities.tasks)==null?void 0:r.requests,e,"Client")}async ping(e){return this.request({method:"ping"},xr,e)}async complete(e,r){return this.request({method:"completion/complete",params:e},Rv,r)}async setLoggingLevel(e,r){return this.request({method:"logging/setLevel",params:{level:e}},xr,r)}async getPrompt(e,r){return this.request({method:"prompts/get",params:e},kv,r)}async listPrompts(e,r){return this.request({method:"prompts/list",params:e},yv,r)}async listResources(e,r){return this.request({method:"resources/list",params:e},mv,r)}async listResourceTemplates(e,r){return this.request({method:"resources/templates/list",params:e},hv,r)}async readResource(e,r){return this.request({method:"resources/read",params:e},vv,r)}async subscribeResource(e,r){return this.request({method:"resources/subscribe",params:e},xr,r)}async unsubscribeResource(e,r){return this.request({method:"resources/unsubscribe",params:e},xr,r)}async callTool(e,r=sn,o){if(this.isToolTaskRequired(e.name))throw new q(F.InvalidRequest,`Tool "${e.name}" requires task-based execution. Use client.experimental.tasks.callToolStream() instead.`);let n=await this.request({method:"tools/call",params:e},r,o),i=this.getToolOutputValidator(e.name);if(i){if(!n.structuredContent&&!n.isError)throw new q(F.InvalidRequest,`Tool ${e.name} has an output schema but did not return structured content`);if(n.structuredContent)try{let a=i(n.structuredContent);if(!a.valid)throw new q(F.InvalidParams,`Structured content does not match the tool's output schema: ${a.errorMessage}`)}catch(a){throw a instanceof q?a:new q(F.InvalidParams,`Failed to validate structured content: ${a instanceof Error?a.message:String(a)}`)}}return n}isToolTask(e){var r,o,n,i;return(i=(n=(o=(r=this._serverCapabilities)==null?void 0:r.tasks)==null?void 0:o.requests)==null?void 0:n.tools)!=null&&i.call?this._cachedKnownTaskTools.has(e):!1}isToolTaskRequired(e){return this._cachedRequiredTaskTools.has(e)}cacheToolMetadata(e){var r;this._cachedToolOutputValidators.clear(),this._cachedKnownTaskTools.clear(),this._cachedRequiredTaskTools.clear();for(let o of e){if(o.outputSchema){let i=this._jsonSchemaValidator.getValidator(o.outputSchema);this._cachedToolOutputValidators.set(o.name,i)}let n=(r=o.execution)==null?void 0:r.taskSupport;(n==="required"||n==="optional")&&this._cachedKnownTaskTools.add(o.name),n==="required"&&this._cachedRequiredTaskTools.add(o.name)}}getToolOutputValidator(e){return this._cachedToolOutputValidators.get(e)}async listTools(e,r){let o=await this.request({method:"tools/list",params:e},Iv,r);return this.cacheToolMetadata(o.tools),o}_setupListChangedHandler(e,r,o,n){let i=Bx.safeParse(o);if(!i.success)throw new Error(`Invalid ${e} listChanged options: ${i.error.message}`);if(typeof o.onChanged!="function")throw new Error(`Invalid ${e} listChanged options: onChanged must be a function`);let{autoRefresh:a,debounceMs:c}=i.data,{onChanged:u}=o,l=async()=>{if(!a){u(null,null);return}try{let s=await n();u(null,s)}catch(s){let f=s instanceof Error?s:new Error(String(s));u(f,null)}},d=()=>{if(c){let s=this._listChangedDebounceTimers.get(e);s&&clearTimeout(s);let f=setTimeout(l,c);this._listChangedDebounceTimers.set(e,f)}else l()};this.setNotificationHandler(r,d)}async sendRootsListChanged(){return this.notification({method:"notifications/roots/list_changed"})}};var fp=class{constructor(e){this._server=e}requestStream(e,r,o){return this._server.requestStream(e,r,o)}async getTask(e,r){return this._server.getTask({taskId:e},r)}async getTaskResult(e,r,o){return this._server.getTaskResult({taskId:e},r,o)}async listTasks(e,r){return this._server.listTasks(e?{cursor:e}:void 0,r)}async cancelTask(e,r){return this._server.cancelTask({taskId:e},r)}};var pp=class extends pi{constructor(e,r){var o,n;super(r),this._serverInfo=e,this._loggingLevels=new Map,this.LOG_LEVEL_SEVERITY=new Map(Ks.options.map((i,a)=>[i,a])),this.isMessageIgnored=(i,a)=>{let c=this._loggingLevels.get(a);return c?this.LOG_LEVEL_SEVERITY.get(i)<this.LOG_LEVEL_SEVERITY.get(c):!1},this._capabilities=(o=r==null?void 0:r.capabilities)!=null?o:{},this._instructions=r==null?void 0:r.instructions,this._jsonSchemaValidator=(n=r==null?void 0:r.jsonSchemaValidator)!=null?n:new Ei,this.setRequestHandler(df,i=>this._oninitialize(i)),this.setNotificationHandler(ff,()=>{var i;return(i=this.oninitialized)==null?void 0:i.call(this)}),this._capabilities.logging&&this.setRequestHandler(Tv,async(i,a)=>{var d;let c=a.sessionId||((d=a.requestInfo)==null?void 0:d.headers["mcp-session-id"])||void 0,{level:u}=i.params,l=Ks.safeParse(u);return l.success&&this._loggingLevels.set(c,l.data),{}})}get experimental(){return this._experimental||(this._experimental={tasks:new fp(this)}),this._experimental}registerCapabilities(e){if(this.transport)throw new Error("Cannot register capabilities after connecting to transport");this._capabilities=kf(this._capabilities,e)}setRequestHandler(e,r){var c,u,l;let o=Ko(e),n=o==null?void 0:o.method;if(!n)throw new Error("Schema is missing a method literal");let i;if(rn(n)){let d=n,s=(c=d._zod)==null?void 0:c.def;i=(u=s==null?void 0:s.value)!=null?u:d.value}else{let d=n,s=d._def;i=(l=s==null?void 0:s.value)!=null?l:d.value}if(typeof i!="string")throw new Error("Schema method literal must be a string");if(i==="tools/call"){let d=async(s,f)=>{let p=it(Bs,s);if(!p.success){let y=p.error instanceof Error?p.error.message:String(p.error);throw new q(F.InvalidParams,`Invalid tools/call request: ${y}`)}let{params:m}=p.data,h=await Promise.resolve(r(s,f));if(m.task){let y=it(wr,h);if(!y.success){let w=y.error instanceof Error?y.error.message:String(y.error);throw new q(F.InvalidParams,`Invalid task creation result: ${w}`)}return y.data}let g=it(sn,h);if(!g.success){let y=g.error instanceof Error?g.error.message:String(g.error);throw new q(F.InvalidParams,`Invalid tools/call result: ${y}`)}return g.data};return super.setRequestHandler(e,d)}return super.setRequestHandler(e,r)}assertCapabilityForMethod(e){var r,o,n;switch(e){case"sampling/createMessage":if(!((r=this._clientCapabilities)!=null&&r.sampling))throw new Error(`Client does not support sampling (required for ${e})`);break;case"elicitation/create":if(!((o=this._clientCapabilities)!=null&&o.elicitation))throw new Error(`Client does not support elicitation (required for ${e})`);break;case"roots/list":if(!((n=this._clientCapabilities)!=null&&n.roots))throw new Error(`Client does not support listing roots (required for ${e})`);break;case"ping":break}}assertNotificationCapability(e){var r,o;switch(e){case"notifications/message":if(!this._capabilities.logging)throw new Error(`Server does not support logging (required for ${e})`);break;case"notifications/resources/updated":case"notifications/resources/list_changed":if(!this._capabilities.resources)throw new Error(`Server does not support notifying about resources (required for ${e})`);break;case"notifications/tools/list_changed":if(!this._capabilities.tools)throw new Error(`Server does not support notifying of tool list changes (required for ${e})`);break;case"notifications/prompts/list_changed":if(!this._capabilities.prompts)throw new Error(`Server does not support notifying of prompt list changes (required for ${e})`);break;case"notifications/elicitation/complete":if(!((o=(r=this._clientCapabilities)==null?void 0:r.elicitation)!=null&&o.url))throw new Error(`Client does not support URL elicitation (required for ${e})`);break;case"notifications/cancelled":break;case"notifications/progress":break}}assertRequestHandlerCapability(e){if(this._capabilities)switch(e){case"completion/complete":if(!this._capabilities.completions)throw new Error(`Server does not support completions (required for ${e})`);break;case"logging/setLevel":if(!this._capabilities.logging)throw new Error(`Server does not support logging (required for ${e})`);break;case"prompts/get":case"prompts/list":if(!this._capabilities.prompts)throw new Error(`Server does not support prompts (required for ${e})`);break;case"resources/list":case"resources/templates/list":case"resources/read":if(!this._capabilities.resources)throw new Error(`Server does not support resources (required for ${e})`);break;case"tools/call":case"tools/list":if(!this._capabilities.tools)throw new Error(`Server does not support tools (required for ${e})`);break;case"tasks/get":case"tasks/list":case"tasks/result":case"tasks/cancel":if(!this._capabilities.tasks)throw new Error(`Server does not support tasks capability (required for ${e})`);break;case"ping":case"initialize":break}}assertTaskCapability(e){var r,o;up((o=(r=this._clientCapabilities)==null?void 0:r.tasks)==null?void 0:o.requests,e,"Client")}assertTaskHandlerCapability(e){var r;this._capabilities&&cp((r=this._capabilities.tasks)==null?void 0:r.requests,e,"Server")}async _oninitialize(e){let r=e.params.protocolVersion;return this._clientCapabilities=e.params.capabilities,this._clientVersion=e.params.clientInfo,{protocolVersion:Jn.includes(r)?r:on,capabilities:this.getCapabilities(),serverInfo:this._serverInfo,...this._instructions&&{instructions:this._instructions}}}getClientCapabilities(){return this._clientCapabilities}getClientVersion(){return this._clientVersion}getCapabilities(){return this._capabilities}async ping(){return this.request({method:"ping"},xr)}async createMessage(e,r){var o,n;if((e.tools||e.toolChoice)&&!((n=(o=this._clientCapabilities)==null?void 0:o.sampling)!=null&&n.tools))throw new Error("Client does not support sampling tools capability.");if(e.messages.length>0){let i=e.messages[e.messages.length-1],a=Array.isArray(i.content)?i.content:[i.content],c=a.some(s=>s.type==="tool_result"),u=e.messages.length>1?e.messages[e.messages.length-2]:void 0,l=u?Array.isArray(u.content)?u.content:[u.content]:[],d=l.some(s=>s.type==="tool_use");if(c){if(a.some(s=>s.type!=="tool_result"))throw new Error("The last message must contain only tool_result content if any is present");if(!d)throw new Error("tool_result blocks are not matching any tool_use from the previous message")}if(d){let s=new Set(l.filter(p=>p.type==="tool_use").map(p=>p.id)),f=new Set(a.filter(p=>p.type==="tool_result").map(p=>p.toolUseId));if(s.size!==f.size||![...s].every(p=>f.has(p)))throw new Error("ids of tool_result blocks and tool_use blocks from previous message do not match")}}return e.tools?this.request({method:"sampling/createMessage",params:e},Ov,r):this.request({method:"sampling/createMessage",params:e},Gs,r)}async elicitInput(e,r){var n,i,a,c,u;switch((n=e.mode)!=null?n:"form"){case"url":{if(!((a=(i=this._clientCapabilities)==null?void 0:i.elicitation)!=null&&a.url))throw new Error("Client does not support url elicitation.");let l=e;return this.request({method:"elicitation/create",params:l},fi,r)}case"form":{if(!((u=(c=this._clientCapabilities)==null?void 0:c.elicitation)!=null&&u.form))throw new Error("Client does not support form elicitation.");let l=e.mode==="form"?e:{...e,mode:"form"},d=await this.request({method:"elicitation/create",params:l},fi,r);if(d.action==="accept"&&d.content&&l.requestedSchema)try{let f=this._jsonSchemaValidator.getValidator(l.requestedSchema)(d.content);if(!f.valid)throw new q(F.InvalidParams,`Elicitation response content does not match requested schema: ${f.errorMessage}`)}catch(s){throw s instanceof q?s:new q(F.InternalError,`Error validating elicitation response: ${s instanceof Error?s.message:String(s)}`)}return d}}}createElicitationCompletionNotifier(e,r){var o,n;if(!((n=(o=this._clientCapabilities)==null?void 0:o.elicitation)!=null&&n.url))throw new Error("Client does not support URL elicitation (required for notifications/elicitation/complete)");return()=>this.notification({method:"notifications/elicitation/complete",params:{elicitationId:e}},r)}async listRoots(e,r){return this.request({method:"roots/list",params:e},Cv,r)}async sendLoggingMessage(e,r){if(this._capabilities.logging&&!this.isMessageIgnored(e.level,r))return this.notification({method:"notifications/message",params:e})}async sendResourceUpdated(e){return this.notification({method:"notifications/resources/updated",params:e})}async sendResourceListChanged(){return this.notification({method:"notifications/resources/list_changed"})}async sendToolListChanged(){return this.notification({method:"notifications/tools/list_changed"})}async sendPromptListChanged(){return this.notification({method:"notifications/prompts/list_changed"})}};var mp=class extends Error{constructor(e,r){super(e),this.name="ParseError",this.type=r.type,this.field=r.field,this.value=r.value,this.line=r.line}};function Ny(t){}function hp(t){if(typeof t=="function")throw new TypeError("`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?");let{onEvent:e=Ny,onError:r=Ny,onRetry:o=Ny,onComment:n}=t,i="",a=!0,c,u="",l="";function d(h){let g=a?h.replace(/^\xEF\xBB\xBF/,""):h,[y,w]=CC(`${i}${g}`);for(let k of y)s(k);i=w,a=!1}function s(h){if(h===""){p();return}if(h.startsWith(":")){n&&n(h.slice(h.startsWith(": ")?2:1));return}let g=h.indexOf(":");if(g!==-1){let y=h.slice(0,g),w=h[g+1]===" "?2:1,k=h.slice(g+w);f(y,k,h);return}f(h,"",h)}function f(h,g,y){switch(h){case"event":l=g;break;case"data":u=`${u}${g}
node_modules/playwright-core/lib/mcpBundleImpl/index.js:119:`}var GD=Vc.default.platform==="win32"?["APPDATA","HOMEDRIVE","HOMEPATH","LOCALAPPDATA","PATH","PROCESSOR_ARCHITECTURE","SYSTEMDRIVE","SYSTEMROOT","TEMP","USERNAME","USERPROFILE","PROGRAMFILES"]:["HOME","LOGNAME","PATH","SHELL","TERM","USER"];function XD(){let t={};for(let e of GD){let r=Vc.default.env[e];r!==void 0&&(r.startsWith("()")||(t[e]=r))}return t}var Sp=class{constructor(e){this._readBuffer=new Mi,this._stderrStream=null,this._serverParams=e,(e.stderr==="pipe"||e.stderr==="overlapped")&&(this._stderrStream=new Rz.PassThrough)}async start(){if(this._process)throw new Error("StdioClientTransport already started! If using Client class, note that connect() calls start() automatically.");return new Promise((e,r)=>{var o,n,i,a,c;this._process=(0,jz.default)(this._serverParams.command,(o=this._serverParams.args)!=null?o:[],{env:{...XD(),...this._serverParams.env},stdio:["pipe","pipe",(n=this._serverParams.stderr)!=null?n:"inherit"],shell:!1,windowsHide:Vc.default.platform==="win32"&&YD(),cwd:this._serverParams.cwd}),this._process.on("error",u=>{var l;r(u),(l=this.onerror)==null||l.call(this,u)}),this._process.on("spawn",()=>{e()}),this._process.on("close",u=>{var l;this._process=void 0,(l=this.onclose)==null||l.call(this)}),(i=this._process.stdin)==null||i.on("error",u=>{var l;(l=this.onerror)==null||l.call(this,u)}),(a=this._process.stdout)==null||a.on("data",u=>{this._readBuffer.append(u),this.processReadBuffer()}),(c=this._process.stdout)==null||c.on("error",u=>{var l;(l=this.onerror)==null||l.call(this,u)}),this._stderrStream&&this._process.stderr&&this._process.stderr.pipe(this._stderrStream)})}get stderr(){var e,r;return this._stderrStream?this._stderrStream:(r=(e=this._process)==null?void 0:e.stderr)!=null?r:null}get pid(){var e,r;return(r=(e=this._process)==null?void 0:e.pid)!=null?r:null}processReadBuffer(){var e,r;for(;;)try{let o=this._readBuffer.readMessage();if(o===null)break;(e=this.onmessage)==null||e.call(this,o)}catch(o){(r=this.onerror)==null||r.call(this,o)}}async close(){var e;if(this._process){let r=this._process;this._process=void 0;let o=new Promise(n=>{r.once("close",()=>{n()})});try{(e=r.stdin)==null||e.end()}catch{}if(await Promise.race([o,new Promise(n=>setTimeout(n,2e3).unref())]),r.exitCode===null){try{r.kill("SIGTERM")}catch{}await Promise.race([o,new Promise(n=>setTimeout(n,2e3).unref())])}if(r.exitCode===null)try{r.kill("SIGKILL")}catch{}}this._readBuffer.clear()}send(e){return new Promise(r=>{var n;if(!((n=this._process)!=null&&n.stdin))throw new Error("Not connected");let o=kp(e);this._process.stdin.write(o)?r():this._process.stdin.once("drain",r)})}};function YD(){return"type"in Vc.default}var l$=er(require("node:process"),1);var zp=class{constructor(e=l$.default.stdin,r=l$.default.stdout){this._stdin=e,this._stdout=r,this._readBuffer=new Mi,this._started=!1,this._ondata=o=>{this._readBuffer.append(o),this.processReadBuffer()},this._onerror=o=>{var n;(n=this.onerror)==null||n.call(this,o)}}async start(){if(this._started)throw new Error("StdioServerTransport already started! If using Server class, note that connect() calls start() automatically.");this._started=!0,this._stdin.on("data",this._ondata),this._stdin.on("error",this._onerror)}processReadBuffer(){var e,r;for(;;)try{let o=this._readBuffer.readMessage();if(o===null)break;(e=this.onmessage)==null||e.call(this,o)}catch(o){(r=this.onerror)==null||r.call(this,o)}}async close(){var r;this._stdin.off("data",this._ondata),this._stdin.off("error",this._onerror),this._stdin.listenerCount("data")===0&&this._stdin.pause(),this._readBuffer.clear(),(r=this.onclose)==null||r.call(this)}send(e){return new Promise(r=>{let o=kp(e);this._stdout.write(o)?r():this._stdout.once("drain",r)})}};var Nz=require("http2"),Pp=require("http2"),p$=require("stream"),Az=er(require("crypto"),1);var co=class extends Error{constructor(t,e){super(t,e),this.name="RequestError"}},QD=t=>t instanceof co?t:new co(t.message,{cause:t}),eU=global.Request,Fc=class extends eU{constructor(t,e){var r,o;typeof t=="object"&&Vi in t&&(t=t[Vi]()),typeof((r=e==null?void 0:e.body)==null?void 0:r.getReader)!="undefined"&&((o=e.duplex)!=null||(e.duplex="half")),super(t,e)}},tU=t=>{let e=[],r=t.rawHeaders;for(let o=0;o<r.length;o+=2){let{[o]:n,[o+1]:i}=r;n.charCodeAt(0)!==58&&e.push([n,i])}return new Headers(e)},Cz=Symbol("wrapBodyStream"),rU=(t,e,r,o,n)=>{let i={method:t,headers:r,signal:n.signal};if(t==="TRACE"){i.method="GET";let a=new Fc(e,i);return Object.defineProperty(a,"method",{get(){return"TRACE"}}),a}if(!(t==="GET"||t==="HEAD"))if("rawBody"in o&&o.rawBody instanceof Buffer)i.body=new ReadableStream({start(a){a.enqueue(o.rawBody),a.close()}});else if(o[Cz]){let a;i.body=new ReadableStream({async pull(c){try{a||(a=p$.Readable.toWeb(o).getReader());let{done:u,value:l}=await a.read();u?c.close():c.enqueue(l)}catch(u){c.error(u)}}})}else i.body=p$.Readable.toWeb(o);return new Fc(e,i)},Vi=Symbol("getRequestCache"),d$=Symbol("requestCache"),Tp=Symbol("incomingKey"),Ep=Symbol("urlKey"),f$=Symbol("headersKey"),yn=Symbol("abortControllerKey"),nU=Symbol("getAbortController"),Op={get method(){return this[Tp].method||"GET"},get url(){return this[Ep]},get headers(){return this[f$]||(this[f$]=tU(this[Tp]))},[nU](){return this[Vi](),this[yn]},[Vi](){return this[yn]||(this[yn]=new AbortController),this[d$]||(this[d$]=rU(this.method,this[Ep],this.headers,this[Tp],this[yn]))}};["body","bodyUsed","cache","credentials","destination","integrity","mode","redirect","referrer","referrerPolicy","signal","keepalive"].forEach(t=>{Object.defineProperty(Op,t,{get(){return this[Vi]()[t]}})});["arrayBuffer","blob","clone","formData","json","text"].forEach(t=>{Object.defineProperty(Op,t,{value:function(){return this[Vi]()[t]()}})});Object.setPrototypeOf(Op,Fc.prototype);var oU=(t,e)=>{let r=Object.create(Op);r[Tp]=t;let o=t.url||"";if(o[0]!=="/"&&(o.startsWith("http://")||o.startsWith("https://"))){if(t instanceof Pp.Http2ServerRequest)throw new co("Absolute URL for :path is not allowed in HTTP/2");try{let c=new URL(o);r[Ep]=c.href}catch(c){throw new co("Invalid absolute URL",{cause:c})}return r}let n=(t instanceof Pp.Http2ServerRequest?t.authority:t.headers.host)||e;if(!n)throw new co("Missing host header");let i;if(t instanceof Pp.Http2ServerRequest){if(i=t.scheme,!(i==="http"||i==="https"))throw new co("Unsupported scheme")}else i=t.socket&&t.socket.encrypted?"https":"http";let a=new URL(`${i}://${n}${o}`);if(a.hostname.length!==n.length&&a.hostname!==n.replace(/:\d+$/,""))throw new co("Invalid host header");return r[Ep]=a.href,r},Ip=Symbol("responseCache"),qi=Symbol("getResponseCache"),uo=Symbol("cache"),h$=global.Response,Jc,jr,Li,Hc=(Li=class{constructor(e,r){Vp(this,Jc);Vp(this,jr);let o;if(Wi(this,Jc,e),r instanceof Li){let n=r[Ip];if(n){Wi(this,jr,n),this[qi]();return}else Wi(this,jr,Hi(r,jr)),o=new Headers(Hi(r,jr).headers)}else Wi(this,jr,r);(typeof e=="string"||typeof(e==null?void 0:e.getReader)!="undefined"||e instanceof Blob||e instanceof Uint8Array)&&(o||(o=(r==null?void 0:r.headers)||{"content-type":"text/plain; charset=UTF-8"}),this[uo]=[(r==null?void 0:r.status)||200,e,o])}[qi](){return delete this[uo],this[Ip]||(this[Ip]=new h$(Hi(this,Jc),Hi(this,jr)))}get headers(){let e=this[uo];return e?(e[2]instanceof Headers||(e[2]=new Headers(e[2])),e[2]):this[qi]().headers}get status(){var e,r;return(r=(e=this[uo])==null?void 0:e[0])!=null?r:this[qi]().status}get ok(){let e=this.status;return e>=200&&e<300}},Jc=new WeakMap,jr=new WeakMap,Li);["body","bodyUsed","redirected","statusText","trailers","type","url"].forEach(t=>{Object.defineProperty(Hc.prototype,t,{get(){return this[qi]()[t]}})});["arrayBuffer","blob","clone","formData","json","text"].forEach(t=>{Object.defineProperty(Hc.prototype,t,{value:function(){return this[qi]()[t]()}})});Object.setPrototypeOf(Hc,h$);Object.setPrototypeOf(Hc.prototype,h$.prototype);async function iU(t){return Promise.race([t,Promise.resolve().then(()=>Promise.resolve(void 0))])}function Dz(t,e,r){let o=c=>{t.cancel(c).catch(()=>{})};return e.on("close",o),e.on("error",o),(r!=null?r:t.read()).then(a,n),t.closed.finally(()=>{e.off("close",o),e.off("error",o)});function n(c){c&&e.destroy(c)}function i(){t.read().then(a,n)}function a({done:c,value:u}){try{if(c)e.end();else if(!e.write(u))e.once("drain",i);else return t.read().then(a,n)}catch(l){n(l)}}}function aU(t,e){if(t.locked)throw new TypeError("ReadableStream is locked.");return e.destroyed?void 0:Dz(t.getReader(),e)}var Uz=t=>{var o;let e={};t instanceof Headers||(t=new Headers(t!=null?t:void 0));let r=[];for(let[n,i]of t)n==="set-cookie"?r.push(i):e[n]=i;return r.length>0&&(e["set-cookie"]=r),(o=e["content-type"])!=null||(e["content-type"]="text/plain; charset=UTF-8"),e},sU="x-hono-already-sent",cU=global.fetch;typeof global.crypto=="undefined"&&(global.crypto=Az.default);global.fetch=(t,e)=>(e={compress:!1,...e},cU(t,e));var g$=Symbol("outgoingEnded"),uU=()=>new Response(null,{status:400}),Zz=t=>new Response(null,{status:t instanceof Error&&(t.name==="TimeoutError"||t.constructor.name==="TimeoutError")?504:500}),m$=(t,e)=>{let r=t instanceof Error?t:new Error("unknown error",{cause:t});r.code==="ERR_STREAM_PREMATURE_CLOSE"?console.info("The user aborted a request."):(console.error(t),e.headersSent||e.writeHead(500,{"Content-Type":"text/plain"}),e.end(`Error: ${r.message}`),e.destroy(r))},Mz=t=>{"flushHeaders"in t&&t.writable&&t.flushHeaders()},qz=async(t,e)=>{var i,a;let[r,o,n]=t[uo];n instanceof Headers&&(n=Uz(n)),typeof o=="string"?n["Content-Length"]=Buffer.byteLength(o):o instanceof Uint8Array?n["Content-Length"]=o.byteLength:o instanceof Blob&&(n["Content-Length"]=o.size),e.writeHead(r,n),typeof o=="string"||o instanceof Uint8Array?e.end(o):o instanceof Blob?e.end(new Uint8Array(await o.arrayBuffer())):(Mz(e),await((i=aU(o,e))==null?void 0:i.catch(c=>m$(c,e)))),(a=e[g$])==null||a.call(e)},lU=t=>typeof t.then=="function",dU=async(t,e,r={})=>{var n;if(lU(t))if(r.errorHandler)try{t=await t}catch(i){let a=await r.errorHandler(i);if(!a)return;t=a}else t=await t.catch(Zz);if(uo in t)return qz(t,e);let o=Uz(t.headers);if(t.body){let i=t.body.getReader(),a=[],c=!1,u;if(o["transfer-encoding"]!=="chunked"){let l=2;for(let d=0;d<l;d++){u||(u=i.read());let s=await iU(u).catch(f=>{console.error(f),c=!0});if(!s){if(d===1){await new Promise(f=>setTimeout(f)),l=3;continue}break}if(u=void 0,s.value&&a.push(s.value),s.done){c=!0;break}}c&&!("content-length"in o)&&(o["content-length"]=a.reduce((d,s)=>d+s.length,0))}e.writeHead(t.status,o),a.forEach(l=>{e.write(l)}),c?e.end():(a.length===0&&Mz(e),await Dz(i,e,u))}else o[sU]||(e.writeHead(t.status,o),e.end());(n=e[g$])==null||n.call(e)},v$=(t,e={})=>{var o;let r=(o=e.autoCleanupIncoming)!=null?o:!0;return e.overrideGlobalObjects!==!1&&global.Request!==Fc&&(Object.defineProperty(global,"Request",{value:Fc}),Object.defineProperty(global,"Response",{value:Hc})),async(n,i)=>{let a,c;try{c=oU(n,e.hostname);let u=!r||n.method==="GET"||n.method==="HEAD";if(u||(n[Cz]=!0,n.on("end",()=>{u=!0}),n instanceof Nz.Http2ServerRequest&&(i[g$]=()=>{u||setTimeout(()=>{u||setTimeout(()=>{n.destroy(),i.destroy()})})})),i.on("close",()=>{c[yn]&&(n.errored?c[yn].abort(n.errored.toString()):i.writableFinished||c[yn].abort("Client connection prematurely closed.")),u||setTimeout(()=>{u||setTimeout(()=>{n.destroy()})})}),a=t(c,{incoming:n,outgoing:i}),uo in a)return qz(a,i)}catch(u){if(a)return m$(u,i);if(e.errorHandler){if(a=await e.errorHandler(c?u:QD(u)),!a)return}else c?a=Zz(u):a=uU()}try{return await dU(a,i,e)}catch(u){return m$(u,i)}}};var jp=class{constructor(e={}){var r,o;this._started=!1,this._streamMapping=new Map,this._requestToStreamMapping=new Map,this._requestResponseMap=new Map,this._initialized=!1,this._enableJsonResponse=!1,this._standaloneSseStreamId="_GET_stream",this.sessionIdGenerator=e.sessionIdGenerator,this._enableJsonResponse=(r=e.enableJsonResponse)!=null?r:!1,this._eventStore=e.eventStore,this._onsessioninitialized=e.onsessioninitialized,this._onsessionclosed=e.onsessionclosed,this._allowedHosts=e.allowedHosts,this._allowedOrigins=e.allowedOrigins,this._enableDnsRebindingProtection=(o=e.enableDnsRebindingProtection)!=null?o:!1,this._retryInterval=e.retryInterval}async start(){if(this._started)throw new Error("Transport already started");this._started=!0}createJsonErrorResponse(e,r,o,n){let i={code:r,message:o};return(n==null?void 0:n.data)!==void 0&&(i.data=n.data),new Response(JSON.stringify({jsonrpc:"2.0",error:i,id:null}),{status:e,headers:{"Content-Type":"application/json",...n==null?void 0:n.headers}})}validateRequestHeaders(e){var r,o;if(this._enableDnsRebindingProtection){if(this._allowedHosts&&this._allowedHosts.length>0){let n=e.headers.get("host");if(!n||!this._allowedHosts.includes(n)){let i=`Invalid Host header: ${n}`;return(r=this.onerror)==null||r.call(this,new Error(i)),this.createJsonErrorResponse(403,-32e3,i)}}if(this._allowedOrigins&&this._allowedOrigins.length>0){let n=e.headers.get("origin");if(n&&!this._allowedOrigins.includes(n)){let i=`Invalid Origin header: ${n}`;return(o=this.onerror)==null||o.call(this,new Error(i)),this.createJsonErrorResponse(403,-32e3,i)}}}}async handleRequest(e,r){let o=this.validateRequestHeaders(e);if(o)return o;switch(e.method){case"POST":return this.handlePostRequest(e,r);case"GET":return this.handleGetRequest(e);case"DELETE":return this.handleDeleteRequest(e);default:return this.handleUnsupportedRequest()}}async writePrimingEvent(e,r,o,n){if(!this._eventStore||n<"2025-11-25")return;let i=await this._eventStore.storeEvent(o,{}),a=`id: ${i}
node_modules/caniuse-lite/dist/unpacker/feature.js:8:const MATH2LOG = Math.log(2)
node_modules/caniuse-lite/dist/unpacker/feature.js:21:    let note = Math.floor(Math.log(notes) / MATH2LOG) + 1
node_modules/playwright-core/lib/generated/injectedScriptSource.js:24:const source = '\nvar __commonJS = obj => {\n  let required = false;\n  let result;\n  return function __require() {\n    if (!required) {\n      required = true;\n      let fn;\n      for (const name in obj) { fn = obj[name]; break; }\n      const module = { exports: {} };\n      fn(module.exports, module);\n      result = module.exports;\n    }\n    return result;\n  }\n};\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\nvar __toESM = mod => ({ ...mod, \'default\': mod });\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\n\n\n// packages/injected/src/injectedScript.ts\nvar injectedScript_exports = {};\n__export(injectedScript_exports, {\n  InjectedScript: () => InjectedScript\n});\nmodule.exports = __toCommonJS(injectedScript_exports);\n\n// packages/playwright-core/src/utils/isomorphic/ariaSnapshot.ts\nfunction ariaNodesEqual(a, b) {\n  if (a.role !== b.role || a.name !== b.name)\n    return false;\n  if (!ariaPropsEqual(a, b) || hasPointerCursor(a) !== hasPointerCursor(b))\n    return false;\n  const aKeys = Object.keys(a.props);\n  const bKeys = Object.keys(b.props);\n  return aKeys.length === bKeys.length && aKeys.every((k) => a.props[k] === b.props[k]);\n}\nfunction hasPointerCursor(ariaNode) {\n  return ariaNode.box.cursor === "pointer";\n}\nfunction ariaPropsEqual(a, b) {\n  return a.active === b.active && a.checked === b.checked && a.disabled === b.disabled && a.expanded === b.expanded && a.selected === b.selected && a.level === b.level && a.pressed === b.pressed;\n}\nfunction parseAriaSnapshot(yaml, text, options = {}) {\n  var _a;\n  const lineCounter = new yaml.LineCounter();\n  const parseOptions = {\n    keepSourceTokens: true,\n    lineCounter,\n    ...options\n  };\n  const yamlDoc = yaml.parseDocument(text, parseOptions);\n  const errors = [];\n  const convertRange = (range) => {\n    return [lineCounter.linePos(range[0]), lineCounter.linePos(range[1])];\n  };\n  const addError = (error) => {\n    errors.push({\n      message: error.message,\n      range: [lineCounter.linePos(error.pos[0]), lineCounter.linePos(error.pos[1])]\n    });\n  };\n  const convertSeq = (container, seq) => {\n    for (const item of seq.items) {\n      const itemIsString = item instanceof yaml.Scalar && typeof item.value === "string";\n      if (itemIsString) {\n        const childNode = KeyParser.parse(item, parseOptions, errors);\n        if (childNode) {\n          container.children = container.children || [];\n          container.children.push(childNode);\n        }\n        continue;\n      }\n      const itemIsMap = item instanceof yaml.YAMLMap;\n      if (itemIsMap) {\n        convertMap(container, item);\n        continue;\n      }\n      errors.push({\n        message: "Sequence items should be strings or maps",\n        range: convertRange(item.range || seq.range)\n      });\n    }\n  };\n  const convertMap = (container, map) => {\n    var _a2;\n    for (const entry of map.items) {\n      container.children = container.children || [];\n      const keyIsString = entry.key instanceof yaml.Scalar && typeof entry.key.value === "string";\n      if (!keyIsString) {\n        errors.push({\n          message: "Only string keys are supported",\n          range: convertRange(entry.key.range || map.range)\n        });\n        continue;\n      }\n      const key = entry.key;\n      const value = entry.value;\n      if (key.value === "text") {\n        const valueIsString = value instanceof yaml.Scalar && typeof value.value === "string";\n        if (!valueIsString) {\n          errors.push({\n            message: "Text value should be a string",\n            range: convertRange(entry.value.range || map.range)\n          });\n          continue;\n        }\n        container.children.push({\n          kind: "text",\n          text: textValue(value.value)\n        });\n        continue;\n      }\n      if (key.value === "/children") {\n        const valueIsString = value instanceof yaml.Scalar && typeof value.value === "string";\n        if (!valueIsString || value.value !== "contain" && value.value !== "equal" && value.value !== "deep-equal") {\n          errors.push({\n            message: \'Strict value should be "contain", "equal" or "deep-equal"\',\n            range: convertRange(entry.value.range || map.range)\n          });\n          continue;\n        }\n        container.containerMode = value.value;\n        continue;\n      }\n      if (key.value.startsWith("/")) {\n        const valueIsString = value instanceof yaml.Scalar && typeof value.value === "string";\n        if (!valueIsString) {\n          errors.push({\n            message: "Property value should be a string",\n            range: convertRange(entry.value.range || map.range)\n          });\n          continue;\n        }\n        container.props = (_a2 = container.props) != null ? _a2 : {};\n        container.props[key.value.slice(1)] = textValue(value.value);\n        continue;\n      }\n      const childNode = KeyParser.parse(key, parseOptions, errors);\n      if (!childNode)\n        continue;\n      const valueIsScalar = value instanceof yaml.Scalar;\n      if (valueIsScalar) {\n        const type = typeof value.value;\n        if (type !== "string" && type !== "number" && type !== "boolean") {\n          errors.push({\n            message: "Node value should be a string or a sequence",\n            range: convertRange(entry.value.range || map.range)\n          });\n          continue;\n        }\n        container.children.push({\n          ...childNode,\n          children: [{\n            kind: "text",\n            text: textValue(String(value.value))\n          }]\n        });\n        continue;\n      }\n      const valueIsSequence = value instanceof yaml.YAMLSeq;\n      if (valueIsSequence) {\n        container.children.push(childNode);\n        convertSeq(childNode, value);\n        continue;\n      }\n      errors.push({\n        message: "Map values should be strings or sequences",\n        range: convertRange(entry.value.range || map.range)\n      });\n    }\n  };\n  const fragment = { kind: "role", role: "fragment" };\n  yamlDoc.errors.forEach(addError);\n  if (errors.length)\n    return { errors, fragment };\n  if (!(yamlDoc.contents instanceof yaml.YAMLSeq)) {\n    errors.push({\n      message: \'Aria snapshot must be a YAML sequence, elements starting with " -"\',\n      range: yamlDoc.contents ? convertRange(yamlDoc.contents.range) : [{ line: 0, col: 0 }, { line: 0, col: 0 }]\n    });\n  }\n  if (errors.length)\n    return { errors, fragment };\n  convertSeq(fragment, yamlDoc.contents);\n  if (errors.length)\n    return { errors, fragment: emptyFragment };\n  if (((_a = fragment.children) == null ? void 0 : _a.length) === 1 && (!fragment.containerMode || fragment.containerMode === "contain"))\n    return { fragment: fragment.children[0], errors: [] };\n  return { fragment, errors: [] };\n}\nvar emptyFragment = { kind: "role", role: "fragment" };\nfunction normalizeWhitespace(text) {\n  return text.replace(/[\\u200b\\u00ad]/g, "").replace(/[\\r\\n\\s\\t]+/g, " ").trim();\n}\nfunction textValue(value) {\n  return {\n    raw: value,\n    normalized: normalizeWhitespace(value)\n  };\n}\nvar KeyParser = class _KeyParser {\n  static parse(text, options, errors) {\n    try {\n      return new _KeyParser(text.value)._parse();\n    } catch (e) {\n      if (e instanceof ParserError) {\n        const message = options.prettyErrors === false ? e.message : e.message + ":\\n\\n" + text.value + "\\n" + " ".repeat(e.pos) + "^\\n";\n        errors.push({\n          message,\n          range: [options.lineCounter.linePos(text.range[0]), options.lineCounter.linePos(text.range[0] + e.pos)]\n        });\n        return null;\n      }\n      throw e;\n    }\n  }\n  constructor(input) {\n    this._input = input;\n    this._pos = 0;\n    this._length = input.length;\n  }\n  _peek() {\n    return this._input[this._pos] || "";\n  }\n  _next() {\n    if (this._pos < this._length)\n      return this._input[this._pos++];\n    return null;\n  }\n  _eof() {\n    return this._pos >= this._length;\n  }\n  _isWhitespace() {\n    return !this._eof() && /\\s/.test(this._peek());\n  }\n  _skipWhitespace() {\n    while (this._isWhitespace())\n      this._pos++;\n  }\n  _readIdentifier(type) {\n    if (this._eof())\n      this._throwError(`Unexpected end of input when expecting ${type}`);\n    const start = this._pos;\n    while (!this._eof() && /[a-zA-Z]/.test(this._peek()))\n      this._pos++;\n    return this._input.slice(start, this._pos);\n  }\n  _readString() {\n    let result = "";\n    let escaped = false;\n    while (!this._eof()) {\n      const ch = this._next();\n      if (escaped) {\n        result += ch;\n        escaped = false;\n      } else if (ch === "\\\\") {\n        escaped = true;\n      } else if (ch === \'"\') {\n        return result;\n      } else {\n        result += ch;\n      }\n    }\n    this._throwError("Unterminated string");\n  }\n  _throwError(message, offset = 0) {\n    throw new ParserError(message, offset || this._pos);\n  }\n  _readRegex() {\n    let result = "";\n    let escaped = false;\n    let insideClass = false;\n    while (!this._eof()) {\n      const ch = this._next();\n      if (escaped) {\n        result += ch;\n        escaped = false;\n      } else if (ch === "\\\\") {\n        escaped = true;\n        result += ch;\n      } else if (ch === "/" && !insideClass) {\n        return { pattern: result };\n      } else if (ch === "[") {\n        insideClass = true;\n        result += ch;\n      } else if (ch === "]" && insideClass) {\n        result += ch;\n        insideClass = false;\n      } else {\n        result += ch;\n      }\n    }\n    this._throwError("Unterminated regex");\n  }\n  _readStringOrRegex() {\n    const ch = this._peek();\n    if (ch === \'"\') {\n      this._next();\n      return normalizeWhitespace(this._readString());\n    }\n    if (ch === "/") {\n      this._next();\n      return this._readRegex();\n    }\n    return null;\n  }\n  _readAttributes(result) {\n    let errorPos = this._pos;\n    while (true) {\n      this._skipWhitespace();\n      if (this._peek() === "[") {\n        this._next();\n        this._skipWhitespace();\n        errorPos = this._pos;\n        const flagName = this._readIdentifier("attribute");\n        this._skipWhitespace();\n        let flagValue = "";\n        if (this._peek() === "=") {\n          this._next();\n          this._skipWhitespace();\n          errorPos = this._pos;\n          while (this._peek() !== "]" && !this._isWhitespace() && !this._eof())\n            flagValue += this._next();\n        }\n        this._skipWhitespace();\n        if (this._peek() !== "]")\n          this._throwError("Expected ]");\n        this._next();\n        this._applyAttribute(result, flagName, flagValue || "true", errorPos);\n      } else {\n        break;\n      }\n    }\n  }\n  _parse() {\n    this._skipWhitespace();\n    const role = this._readIdentifier("role");\n    this._skipWhitespace();\n    const name = this._readStringOrRegex() || "";\n    const result = { kind: "role", role, name };\n    this._readAttributes(result);\n    this._skipWhitespace();\n    if (!this._eof())\n      this._throwError("Unexpected input");\n    return result;\n  }\n  _applyAttribute(node, key, value, errorPos) {\n    if (key === "checked") {\n      this._assert(value === "true" || value === "false" || value === "mixed", \'Value of "checked" attribute must be a boolean or "mixed"\', errorPos);\n      node.checked = value === "true" ? true : value === "false" ? false : "mixed";\n      return;\n    }\n    if (key === "disabled") {\n      this._assert(value === "true" || value === "false", \'Value of "disabled" attribute must be a boolean\', errorPos);\n      node.disabled = value === "true";\n      return;\n    }\n    if (key === "expanded") {\n      this._assert(value === "true" || value === "false", \'Value of "expanded" attribute must be a boolean\', errorPos);\n      node.expanded = value === "true";\n      return;\n    }\n    if (key === "active") {\n      this._assert(value === "true" || value === "false", \'Value of "active" attribute must be a boolean\', errorPos);\n      node.active = value === "true";\n      return;\n    }\n    if (key === "level") {\n      this._assert(!isNaN(Number(value)), \'Value of "level" attribute must be a number\', errorPos);\n      node.level = Number(value);\n      return;\n    }\n    if (key === "pressed") {\n      this._assert(value === "true" || value === "false" || value === "mixed", \'Value of "pressed" attribute must be a boolean or "mixed"\', errorPos);\n      node.pressed = value === "true" ? true : value === "false" ? false : "mixed";\n      return;\n    }\n    if (key === "selected") {\n      this._assert(value === "true" || value === "false", \'Value of "selected" attribute must be a boolean\', errorPos);\n      node.selected = value === "true";\n      return;\n    }\n    this._assert(false, `Unsupported attribute [${key}]`, errorPos);\n  }\n  _assert(value, message, valuePos) {\n    if (!value)\n      this._throwError(message || "Assertion error", valuePos);\n  }\n};\nvar ParserError = class extends Error {\n  constructor(message, pos) {\n    super(message);\n    this.pos = pos;\n  }\n};\nfunction findNewNode(from, to) {\n  var _a, _b;\n  function fillMap(root, map, position) {\n    let size = 1;\n    let childPosition = position + size;\n    for (const child of root.children || []) {\n      if (typeof child === "string") {\n        size++;\n        childPosition++;\n      } else {\n        size += fillMap(child, map, childPosition);\n        childPosition += size;\n      }\n    }\n    if (!["none", "presentation", "fragment", "iframe", "generic"].includes(root.role) && root.name) {\n      let byRole = map.get(root.role);\n      if (!byRole) {\n        byRole = /* @__PURE__ */ new Map();\n        map.set(root.role, byRole);\n      }\n      const existing = byRole.get(root.name);\n      const sizeAndPosition = size * 100 - position;\n      if (!existing || existing.sizeAndPosition < sizeAndPosition)\n        byRole.set(root.name, { node: root, sizeAndPosition });\n    }\n    return size;\n  }\n  const fromMap = /* @__PURE__ */ new Map();\n  if (from)\n    fillMap(from, fromMap, 0);\n  const toMap = /* @__PURE__ */ new Map();\n  fillMap(to, toMap, 0);\n  const result = [];\n  for (const [role, byRole] of toMap) {\n    for (const [name, byName] of byRole) {\n      const inFrom = (_a = fromMap.get(role)) == null ? void 0 : _a.get(name);\n      if (!inFrom)\n        result.push(byName);\n    }\n  }\n  result.sort((a, b) => b.sizeAndPosition - a.sizeAndPosition);\n  return (_b = result[0]) == null ? void 0 : _b.node;\n}\n\n// packages/playwright-core/src/utils/isomorphic/cssTokenizer.ts\nvar between = function(num, first, last) {\n  return num >= first && num <= last;\n};\nfunction digit(code) {\n  return between(code, 48, 57);\n}\nfunction hexdigit(code) {\n  return digit(code) || between(code, 65, 70) || between(code, 97, 102);\n}\nfunction uppercaseletter(code) {\n  return between(code, 65, 90);\n}\nfunction lowercaseletter(code) {\n  return between(code, 97, 122);\n}\nfunction letter(code) {\n  return uppercaseletter(code) || lowercaseletter(code);\n}\nfunction nonascii(code) {\n  return code >= 128;\n}\nfunction namestartchar(code) {\n  return letter(code) || nonascii(code) || code === 95;\n}\nfunction namechar(code) {\n  return namestartchar(code) || digit(code) || code === 45;\n}\nfunction nonprintable(code) {\n  return between(code, 0, 8) || code === 11 || between(code, 14, 31) || code === 127;\n}\nfunction newline(code) {\n  return code === 10;\n}\nfunction whitespace(code) {\n  return newline(code) || code === 9 || code === 32;\n}\nvar maximumallowedcodepoint = 1114111;\nvar InvalidCharacterError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = "InvalidCharacterError";\n  }\n};\nfunction preprocess(str) {\n  const codepoints = [];\n  for (let i = 0; i < str.length; i++) {\n    let code = str.charCodeAt(i);\n    if (code === 13 && str.charCodeAt(i + 1) === 10) {\n      code = 10;\n      i++;\n    }\n    if (code === 13 || code === 12)\n      code = 10;\n    if (code === 0)\n      code = 65533;\n    if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {\n      const lead = code - 55296;\n      const trail = str.charCodeAt(i + 1) - 56320;\n      code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\n      i++;\n    }\n    codepoints.push(code);\n  }\n  return codepoints;\n}\nfunction stringFromCode(code) {\n  if (code <= 65535)\n    return String.fromCharCode(code);\n  code -= Math.pow(2, 16);\n  const lead = Math.floor(code / Math.pow(2, 10)) + 55296;\n  const trail = code % Math.pow(2, 10) + 56320;\n  return String.fromCharCode(lead) + String.fromCharCode(trail);\n}\nfunction tokenize(str1) {\n  const str = preprocess(str1);\n  let i = -1;\n  const tokens = [];\n  let code;\n  let line = 0;\n  let column = 0;\n  let lastLineLength = 0;\n  const incrLineno = function() {\n    line += 1;\n    lastLineLength = column;\n    column = 0;\n  };\n  const locStart = { line, column };\n  const codepoint = function(i2) {\n    if (i2 >= str.length)\n      return -1;\n    return str[i2];\n  };\n  const next = function(num) {\n    if (num === void 0)\n      num = 1;\n    if (num > 3)\n      throw "Spec Error: no more than three codepoints of lookahead.";\n    return codepoint(i + num);\n  };\n  const consume = function(num) {\n    if (num === void 0)\n      num = 1;\n    i += num;\n    code = codepoint(i);\n    if (newline(code))\n      incrLineno();\n    else\n      column += num;\n    return true;\n  };\n  const reconsume = function() {\n    i -= 1;\n    if (newline(code)) {\n      line -= 1;\n      column = lastLineLength;\n    } else {\n      column -= 1;\n    }\n    locStart.line = line;\n    locStart.column = column;\n    return true;\n  };\n  const eof = function(codepoint2) {\n    if (codepoint2 === void 0)\n      codepoint2 = code;\n    return codepoint2 === -1;\n  };\n  const donothing = function() {\n  };\n  const parseerror = function() {\n  };\n  const consumeAToken = function() {\n    consumeComments();\n    consume();\n    if (whitespace(code)) {\n      while (whitespace(next()))\n        consume();\n      return new WhitespaceToken();\n    } else if (code === 34) {\n      return consumeAStringToken();\n    } else if (code === 35) {\n      if (namechar(next()) || areAValidEscape(next(1), next(2))) {\n        const token = new HashToken("");\n        if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n          token.type = "id";\n        token.value = consumeAName();\n        return token;\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 36) {\n      if (next() === 61) {\n        consume();\n        return new SuffixMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 39) {\n      return consumeAStringToken();\n    } else if (code === 40) {\n      return new OpenParenToken();\n    } else if (code === 41) {\n      return new CloseParenToken();\n    } else if (code === 42) {\n      if (next() === 61) {\n        consume();\n        return new SubstringMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 43) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 44) {\n      return new CommaToken();\n    } else if (code === 45) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else if (next(1) === 45 && next(2) === 62) {\n        consume(2);\n        return new CDCToken();\n      } else if (startsWithAnIdentifier()) {\n        reconsume();\n        return consumeAnIdentlikeToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 46) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 58) {\n      return new ColonToken();\n    } else if (code === 59) {\n      return new SemicolonToken();\n    } else if (code === 60) {\n      if (next(1) === 33 && next(2) === 45 && next(3) === 45) {\n        consume(3);\n        return new CDOToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 64) {\n      if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n        return new AtKeywordToken(consumeAName());\n      else\n        return new DelimToken(code);\n    } else if (code === 91) {\n      return new OpenSquareToken();\n    } else if (code === 92) {\n      if (startsWithAValidEscape()) {\n        reconsume();\n        return consumeAnIdentlikeToken();\n      } else {\n        parseerror();\n        return new DelimToken(code);\n      }\n    } else if (code === 93) {\n      return new CloseSquareToken();\n    } else if (code === 94) {\n      if (next() === 61) {\n        consume();\n        return new PrefixMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 123) {\n      return new OpenCurlyToken();\n    } else if (code === 124) {\n      if (next() === 61) {\n        consume();\n        return new DashMatchToken();\n      } else if (next() === 124) {\n        consume();\n        return new ColumnToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 125) {\n      return new CloseCurlyToken();\n    } else if (code === 126) {\n      if (next() === 61) {\n        consume();\n        return new IncludeMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (digit(code)) {\n      reconsume();\n      return consumeANumericToken();\n    } else if (namestartchar(code)) {\n      reconsume();\n      return consumeAnIdentlikeToken();\n    } else if (eof()) {\n      return new EOFToken();\n    } else {\n      return new DelimToken(code);\n    }\n  };\n  const consumeComments = function() {\n    while (next(1) === 47 && next(2) === 42) {\n      consume(2);\n      while (true) {\n        consume();\n        if (code === 42 && next() === 47) {\n          consume();\n          break;\n        } else if (eof()) {\n          parseerror();\n          return;\n        }\n      }\n    }\n  };\n  const consumeANumericToken = function() {\n    const num = consumeANumber();\n    if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n      const token = new DimensionToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      token.type = num.type;\n      token.unit = consumeAName();\n      return token;\n    } else if (next() === 37) {\n      consume();\n      const token = new PercentageToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      return token;\n    } else {\n      const token = new NumberToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      token.type = num.type;\n      return token;\n    }\n  };\n  const consumeAnIdentlikeToken = function() {\n    const str2 = consumeAName();\n    if (str2.toLowerCase() === "url" && next() === 40) {\n      consume();\n      while (whitespace(next(1)) && whitespace(next(2)))\n        consume();\n      if (next() === 34 || next() === 39)\n        return new FunctionToken(str2);\n      else if (whitespace(next()) && (next(2) === 34 || next(2) === 39))\n        return new FunctionToken(str2);\n      else\n        return consumeAURLToken();\n    } else if (next() === 40) {\n      consume();\n      return new FunctionToken(str2);\n    } else {\n      return new IdentToken(str2);\n    }\n  };\n  const consumeAStringToken = function(endingCodePoint) {\n    if (endingCodePoint === void 0)\n      endingCodePoint = code;\n    let string = "";\n    while (consume()) {\n      if (code === endingCodePoint || eof()) {\n        return new StringToken(string);\n      } else if (newline(code)) {\n        parseerror();\n        reconsume();\n        return new BadStringToken();\n      } else if (code === 92) {\n        if (eof(next()))\n          donothing();\n        else if (newline(next()))\n          consume();\n        else\n          string += stringFromCode(consumeEscape());\n      } else {\n        string += stringFromCode(code);\n      }\n    }\n    throw new Error("Internal error");\n  };\n  const consumeAURLToken = function() {\n    const token = new URLToken("");\n    while (whitespace(next()))\n      consume();\n    if (eof(next()))\n      return token;\n    while (consume()) {\n      if (code === 41 || eof()) {\n        return token;\n      } else if (whitespace(code)) {\n        while (whitespace(next()))\n          consume();\n        if (next() === 41 || eof(next())) {\n          consume();\n          return token;\n        } else {\n          consumeTheRemnantsOfABadURL();\n          return new BadURLToken();\n        }\n      } else if (code === 34 || code === 39 || code === 40 || nonprintable(code)) {\n        parseerror();\n        consumeTheRemnantsOfABadURL();\n        return new BadURLToken();\n      } else if (code === 92) {\n        if (startsWithAValidEscape()) {\n          token.value += stringFromCode(consumeEscape());\n        } else {\n          parseerror();\n          consumeTheRemnantsOfABadURL();\n          return new BadURLToken();\n        }\n      } else {\n        token.value += stringFromCode(code);\n      }\n    }\n    throw new Error("Internal error");\n  };\n  const consumeEscape = function() {\n    consume();\n    if (hexdigit(code)) {\n      const digits = [code];\n      for (let total = 0; total < 5; total++) {\n        if (hexdigit(next())) {\n          consume();\n          digits.push(code);\n        } else {\n          break;\n        }\n      }\n      if (whitespace(next()))\n        consume();\n      let value = parseInt(digits.map(function(x) {\n        return String.fromCharCode(x);\n      }).join(""), 16);\n      if (value > maximumallowedcodepoint)\n        value = 65533;\n      return value;\n    } else if (eof()) {\n      return 65533;\n    } else {\n      return code;\n    }\n  };\n  const areAValidEscape = function(c1, c2) {\n    if (c1 !== 92)\n      return false;\n    if (newline(c2))\n      return false;\n    return true;\n  };\n  const startsWithAValidEscape = function() {\n    return areAValidEscape(code, next());\n  };\n  const wouldStartAnIdentifier = function(c1, c2, c3) {\n    if (c1 === 45)\n      return namestartchar(c2) || c2 === 45 || areAValidEscape(c2, c3);\n    else if (namestartchar(c1))\n      return true;\n    else if (c1 === 92)\n      return areAValidEscape(c1, c2);\n    else\n      return false;\n  };\n  const startsWithAnIdentifier = function() {\n    return wouldStartAnIdentifier(code, next(1), next(2));\n  };\n  const wouldStartANumber = function(c1, c2, c3) {\n    if (c1 === 43 || c1 === 45) {\n      if (digit(c2))\n        return true;\n      if (c2 === 46 && digit(c3))\n        return true;\n      return false;\n    } else if (c1 === 46) {\n      if (digit(c2))\n        return true;\n      return false;\n    } else if (digit(c1)) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  const startsWithANumber = function() {\n    return wouldStartANumber(code, next(1), next(2));\n  };\n  const consumeAName = function() {\n    let result = "";\n    while (consume()) {\n      if (namechar(code)) {\n        result += stringFromCode(code);\n      } else if (startsWithAValidEscape()) {\n        result += stringFromCode(consumeEscape());\n      } else {\n        reconsume();\n        return result;\n      }\n    }\n    throw new Error("Internal parse error");\n  };\n  const consumeANumber = function() {\n    let repr = "";\n    let type = "integer";\n    if (next() === 43 || next() === 45) {\n      consume();\n      repr += stringFromCode(code);\n    }\n    while (digit(next())) {\n      consume();\n      repr += stringFromCode(code);\n    }\n    if (next(1) === 46 && digit(next(2))) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = "number";\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    }\n    const c1 = next(1), c2 = next(2), c3 = next(3);\n    if ((c1 === 69 || c1 === 101) && digit(c2)) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = "number";\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    } else if ((c1 === 69 || c1 === 101) && (c2 === 43 || c2 === 45) && digit(c3)) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = "number";\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    }\n    const value = convertAStringToANumber(repr);\n    return { type, value, repr };\n  };\n  const convertAStringToANumber = function(string) {\n    return +string;\n  };\n  const consumeTheRemnantsOfABadURL = function() {\n    while (consume()) {\n      if (code === 41 || eof()) {\n        return;\n      } else if (startsWithAValidEscape()) {\n        consumeEscape();\n        donothing();\n      } else {\n        donothing();\n      }\n    }\n  };\n  let iterationCount = 0;\n  while (!eof(next())) {\n    tokens.push(consumeAToken());\n    iterationCount++;\n    if (iterationCount > str.length * 2)\n      throw new Error("I\'m infinite-looping!");\n  }\n  return tokens;\n}\nvar CSSParserToken = class {\n  constructor() {\n    this.tokenType = "";\n  }\n  toJSON() {\n    return { token: this.tokenType };\n  }\n  toString() {\n    return this.tokenType;\n  }\n  toSource() {\n    return "" + this;\n  }\n};\nvar BadStringToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "BADSTRING";\n  }\n};\nvar BadURLToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "BADURL";\n  }\n};\nvar WhitespaceToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "WHITESPACE";\n  }\n  toString() {\n    return "WS";\n  }\n  toSource() {\n    return " ";\n  }\n};\nvar CDOToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "CDO";\n  }\n  toSource() {\n    return "<!--";\n  }\n};\nvar CDCToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "CDC";\n  }\n  toSource() {\n    return "-->";\n  }\n};\nvar ColonToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = ":";\n  }\n};\nvar SemicolonToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = ";";\n  }\n};\nvar CommaToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = ",";\n  }\n};\nvar GroupingToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.value = "";\n    this.mirror = "";\n  }\n};\nvar OpenCurlyToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "{";\n    this.value = "{";\n    this.mirror = "}";\n  }\n};\nvar CloseCurlyToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "}";\n    this.value = "}";\n    this.mirror = "{";\n  }\n};\nvar OpenSquareToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "[";\n    this.value = "[";\n    this.mirror = "]";\n  }\n};\nvar CloseSquareToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "]";\n    this.value = "]";\n    this.mirror = "[";\n  }\n};\nvar OpenParenToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "(";\n    this.value = "(";\n    this.mirror = ")";\n  }\n};\nvar CloseParenToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = ")";\n    this.value = ")";\n    this.mirror = "(";\n  }\n};\nvar IncludeMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "~=";\n  }\n};\nvar DashMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "|=";\n  }\n};\nvar PrefixMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "^=";\n  }\n};\nvar SuffixMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "$=";\n  }\n};\nvar SubstringMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "*=";\n  }\n};\nvar ColumnToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "||";\n  }\n};\nvar EOFToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "EOF";\n  }\n  toSource() {\n    return "";\n  }\n};\nvar DelimToken = class extends CSSParserToken {\n  constructor(code) {\n    super();\n    this.tokenType = "DELIM";\n    this.value = "";\n    this.value = stringFromCode(code);\n  }\n  toString() {\n    return "DELIM(" + this.value + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    return json;\n  }\n  toSource() {\n    if (this.value === "\\\\")\n      return "\\\\\\n";\n    else\n      return this.value;\n  }\n};\nvar StringValuedToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.value = "";\n  }\n  ASCIIMatch(str) {\n    return this.value.toLowerCase() === str.toLowerCase();\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    return json;\n  }\n};\nvar IdentToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "IDENT";\n    this.value = val;\n  }\n  toString() {\n    return "IDENT(" + this.value + ")";\n  }\n  toSource() {\n    return escapeIdent(this.value);\n  }\n};\nvar FunctionToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "FUNCTION";\n    this.value = val;\n    this.mirror = ")";\n  }\n  toString() {\n    return "FUNCTION(" + this.value + ")";\n  }\n  toSource() {\n    return escapeIdent(this.value) + "(";\n  }\n};\nvar AtKeywordToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "AT-KEYWORD";\n    this.value = val;\n  }\n  toString() {\n    return "AT(" + this.value + ")";\n  }\n  toSource() {\n    return "@" + escapeIdent(this.value);\n  }\n};\nvar HashToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "HASH";\n    this.value = val;\n    this.type = "unrestricted";\n  }\n  toString() {\n    return "HASH(" + this.value + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.type = this.type;\n    return json;\n  }\n  toSource() {\n    if (this.type === "id")\n      return "#" + escapeIdent(this.value);\n    else\n      return "#" + escapeHash(this.value);\n  }\n};\nvar StringToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "STRING";\n    this.value = val;\n  }\n  toString() {\n    return \'"\' + escapeString(this.value) + \'"\';\n  }\n};\nvar URLToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "URL";\n    this.value = val;\n  }\n  toString() {\n    return "URL(" + this.value + ")";\n  }\n  toSource() {\n    return \'url("\' + escapeString(this.value) + \'")\';\n  }\n};\nvar NumberToken = class extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = "NUMBER";\n    this.type = "integer";\n    this.repr = "";\n  }\n  toString() {\n    if (this.type === "integer")\n      return "INT(" + this.value + ")";\n    return "NUMBER(" + this.value + ")";\n  }\n  toJSON() {\n    const json = super.toJSON();\n    json.value = this.value;\n    json.type = this.type;\n    json.repr = this.repr;\n    return json;\n  }\n  toSource() {\n    return this.repr;\n  }\n};\nvar PercentageToken = class extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = "PERCENTAGE";\n    this.repr = "";\n  }\n  toString() {\n    return "PERCENTAGE(" + this.value + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.repr = this.repr;\n    return json;\n  }\n  toSource() {\n    return this.repr + "%";\n  }\n};\nvar DimensionToken = class extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = "DIMENSION";\n    this.type = "integer";\n    this.repr = "";\n    this.unit = "";\n  }\n  toString() {\n    return "DIM(" + this.value + "," + this.unit + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.type = this.type;\n    json.repr = this.repr;\n    json.unit = this.unit;\n    return json;\n  }\n  toSource() {\n    const source = this.repr;\n    let unit = escapeIdent(this.unit);\n    if (unit[0].toLowerCase() === "e" && (unit[1] === "-" || between(unit.charCodeAt(1), 48, 57))) {\n      unit = "\\\\65 " + unit.slice(1, unit.length);\n    }\n    return source + unit;\n  }\n};\nfunction escapeIdent(string) {\n  string = "" + string;\n  let result = "";\n  const firstcode = string.charCodeAt(0);\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0)\n      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n    if (between(code, 1, 31) || code === 127 || i === 0 && between(code, 48, 57) || i === 1 && between(code, 48, 57) && firstcode === 45)\n      result += "\\\\" + code.toString(16) + " ";\n    else if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\n      result += string[i];\n    else\n      result += "\\\\" + string[i];\n  }\n  return result;\n}\nfunction escapeHash(string) {\n  string = "" + string;\n  let result = "";\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0)\n      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n    if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\n      result += string[i];\n    else\n      result += "\\\\" + code.toString(16) + " ";\n  }\n  return result;\n}\nfunction escapeString(string) {\n  string = "" + string;\n  let result = "";\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0)\n      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n    if (between(code, 1, 31) || code === 127)\n      result += "\\\\" + code.toString(16) + " ";\n    else if (code === 34 || code === 92)\n      result += "\\\\" + string[i];\n    else\n      result += string[i];\n  }\n  return result;\n}\n\n// packages/playwright-core/src/utils/isomorphic/cssParser.ts\nvar InvalidSelectorError = class extends Error {\n};\nfunction parseCSS(selector, customNames) {\n  let tokens;\n  try {\n    tokens = tokenize(selector);\n    if (!(tokens[tokens.length - 1] instanceof EOFToken))\n      tokens.push(new EOFToken());\n  } catch (e) {\n    const newMessage = e.message + ` while parsing css selector "${selector}". Did you mean to CSS.escape it?`;\n    const index = (e.stack || "").indexOf(e.message);\n    if (index !== -1)\n      e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);\n    e.message = newMessage;\n    throw e;\n  }\n  const unsupportedToken = tokens.find((token) => {\n    return token instanceof AtKeywordToken || token instanceof BadStringToken || token instanceof BadURLToken || token instanceof ColumnToken || token instanceof CDOToken || token instanceof CDCToken || token instanceof SemicolonToken || // TODO: Consider using these for something, e.g. to escape complex strings.\n    // For example :xpath{ (//div/bar[@attr="foo"])[2]/baz }\n    // Or this way :xpath( {complex-xpath-goes-here("hello")} )\n    token instanceof OpenCurlyToken || token instanceof CloseCurlyToken || // TODO: Consider treating these as strings?\n    token instanceof URLToken || token instanceof PercentageToken;\n  });\n  if (unsupportedToken)\n    throw new InvalidSelectorError(`Unsupported token "${unsupportedToken.toSource()}" while parsing css selector "${selector}". Did you mean to CSS.escape it?`);\n  let pos = 0;\n  const names = /* @__PURE__ */ new Set();\n  function unexpected() {\n    return new InvalidSelectorError(`Unexpected token "${tokens[pos].toSource()}" while parsing css selector "${selector}". Did you mean to CSS.escape it?`);\n  }\n  function skipWhitespace() {\n    while (tokens[pos] instanceof WhitespaceToken)\n      pos++;\n  }\n  function isIdent(p = pos) {\n    return tokens[p] instanceof IdentToken;\n  }\n  function isString(p = pos) {\n    return tokens[p] instanceof StringToken;\n  }\n  function isNumber(p = pos) {\n    return tokens[p] instanceof NumberToken;\n  }\n  function isComma(p = pos) {\n    return tokens[p] instanceof CommaToken;\n  }\n  function isOpenParen(p = pos) {\n    return tokens[p] instanceof OpenParenToken;\n  }\n  function isCloseParen(p = pos) {\n    return tokens[p] instanceof CloseParenToken;\n  }\n  function isFunction(p = pos) {\n    return tokens[p] instanceof FunctionToken;\n  }\n  function isStar(p = pos) {\n    return tokens[p] instanceof DelimToken && tokens[p].value === "*";\n  }\n  function isEOF(p = pos) {\n    return tokens[p] instanceof EOFToken;\n  }\n  function isClauseCombinator(p = pos) {\n    return tokens[p] instanceof DelimToken && [">", "+", "~"].includes(tokens[p].value);\n  }\n  function isSelectorClauseEnd(p = pos) {\n    return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof WhitespaceToken;\n  }\n  function consumeFunctionArguments() {\n    const result2 = [consumeArgument()];\n    while (true) {\n      skipWhitespace();\n      if (!isComma())\n        break;\n      pos++;\n      result2.push(consumeArgument());\n    }\n    return result2;\n  }\n  function consumeArgument() {\n    skipWhitespace();\n    if (isNumber())\n      return tokens[pos++].value;\n    if (isString())\n      return tokens[pos++].value;\n    return consumeComplexSelector();\n  }\n  function consumeComplexSelector() {\n    const result2 = { simples: [] };\n    skipWhitespace();\n    if (isClauseCombinator()) {\n      result2.simples.push({ selector: { functions: [{ name: "scope", args: [] }] }, combinator: "" });\n    } else {\n      result2.simples.push({ selector: consumeSimpleSelector(), combinator: "" });\n    }\n    while (true) {\n      skipWhitespace();\n      if (isClauseCombinator()) {\n        result2.simples[result2.simples.length - 1].combinator = tokens[pos++].value;\n        skipWhitespace();\n      } else if (isSelectorClauseEnd()) {\n        break;\n      }\n      result2.simples.push({ combinator: "", selector: consumeSimpleSelector() });\n    }\n    return result2;\n  }\n  function consumeSimpleSelector() {\n    let rawCSSString = "";\n    const functions = [];\n    while (!isSelectorClauseEnd()) {\n      if (isIdent() || isStar()) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof HashToken) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof DelimToken && tokens[pos].value === ".") {\n        pos++;\n        if (isIdent())\n          rawCSSString += "." + tokens[pos++].toSource();\n        else\n          throw unexpected();\n      } else if (tokens[pos] instanceof ColonToken) {\n        pos++;\n        if (isIdent()) {\n          if (!customNames.has(tokens[pos].value.toLowerCase())) {\n            rawCSSString += ":" + tokens[pos++].toSource();\n          } else {\n            const name = tokens[pos++].value.toLowerCase();\n            functions.push({ name, args: [] });\n            names.add(name);\n          }\n        } else if (isFunction()) {\n          const name = tokens[pos++].value.toLowerCase();\n          if (!customNames.has(name)) {\n            rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;\n          } else {\n            functions.push({ name, args: consumeFunctionArguments() });\n            names.add(name);\n          }\n          skipWhitespace();\n          if (!isCloseParen())\n            throw unexpected();\n          pos++;\n        } else {\n          throw unexpected();\n        }\n      } else if (tokens[pos] instanceof OpenSquareToken) {\n        rawCSSString += "[";\n        pos++;\n        while (!(tokens[pos] instanceof CloseSquareToken) && !isEOF())\n          rawCSSString += tokens[pos++].toSource();\n        if (!(tokens[pos] instanceof CloseSquareToken))\n          throw unexpected();\n        rawCSSString += "]";\n        pos++;\n      } else {\n        throw unexpected();\n      }\n    }\n    if (!rawCSSString && !functions.length)\n      throw unexpected();\n    return { css: rawCSSString || void 0, functions };\n  }\n  function consumeBuiltinFunctionArguments() {\n    let s = "";\n    let balance = 1;\n    while (!isEOF()) {\n      if (isOpenParen() || isFunction())\n        balance++;\n      if (isCloseParen())\n        balance--;\n      if (!balance)\n        break;\n      s += tokens[pos++].toSource();\n    }\n    return s;\n  }\n  const result = consumeFunctionArguments();\n  if (!isEOF())\n    throw unexpected();\n  if (result.some((arg) => typeof arg !== "object" || !("simples" in arg)))\n    throw new InvalidSelectorError(`Error while parsing css selector "${selector}". Did you mean to CSS.escape it?`);\n  return { selector: result, names: Array.from(names) };\n}\n\n// packages/playwright-core/src/utils/isomorphic/selectorParser.ts\nvar kNestedSelectorNames = /* @__PURE__ */ new Set(["internal:has", "internal:has-not", "internal:and", "internal:or", "internal:chain", "left-of", "right-of", "above", "below", "near"]);\nvar kNestedSelectorNamesWithDistance = /* @__PURE__ */ new Set(["left-of", "right-of", "above", "below", "near"]);\nvar customCSSNames = /* @__PURE__ */ new Set(["not", "is", "where", "has", "scope", "light", "visible", "text", "text-matches", "text-is", "has-text", "above", "below", "right-of", "left-of", "near", "nth-match"]);\nfunction parseSelector(selector) {\n  const parsedStrings = parseSelectorString(selector);\n  const parts = [];\n  for (const part of parsedStrings.parts) {\n    if (part.name === "css" || part.name === "css:light") {\n      if (part.name === "css:light")\n        part.body = ":light(" + part.body + ")";\n      const parsedCSS = parseCSS(part.body, customCSSNames);\n      parts.push({\n        name: "css",\n        body: parsedCSS.selector,\n        source: part.body\n      });\n      continue;\n    }\n    if (kNestedSelectorNames.has(part.name)) {\n      let innerSelector;\n      let distance;\n      try {\n        const unescaped = JSON.parse("[" + part.body + "]");\n        if (!Array.isArray(unescaped) || unescaped.length < 1 || unescaped.length > 2 || typeof unescaped[0] !== "string")\n          throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n        innerSelector = unescaped[0];\n        if (unescaped.length === 2) {\n          if (typeof unescaped[1] !== "number" || !kNestedSelectorNamesWithDistance.has(part.name))\n            throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n          distance = unescaped[1];\n        }\n      } catch (e) {\n        throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n      }\n      const nested = { name: part.name, source: part.body, body: { parsed: parseSelector(innerSelector), distance } };\n      const lastFrame = [...nested.body.parsed.parts].reverse().find((part2) => part2.name === "internal:control" && part2.body === "enter-frame");\n      const lastFrameIndex = lastFrame ? nested.body.parsed.parts.indexOf(lastFrame) : -1;\n      if (lastFrameIndex !== -1 && selectorPartsEqual(nested.body.parsed.parts.slice(0, lastFrameIndex + 1), parts.slice(0, lastFrameIndex + 1)))\n        nested.body.parsed.parts.splice(0, lastFrameIndex + 1);\n      parts.push(nested);\n      continue;\n    }\n    parts.push({ ...part, source: part.body });\n  }\n  if (kNestedSelectorNames.has(parts[0].name))\n    throw new InvalidSelectorError(`"${parts[0].name}" selector cannot be first`);\n  return {\n    capture: parsedStrings.capture,\n    parts\n  };\n}\nfunction selectorPartsEqual(list1, list2) {\n  return stringifySelector({ parts: list1 }) === stringifySelector({ parts: list2 });\n}\nfunction stringifySelector(selector, forceEngineName) {\n  if (typeof selector === "string")\n    return selector;\n  return selector.parts.map((p, i) => {\n    let includeEngine = true;\n    if (!forceEngineName && i !== selector.capture) {\n      if (p.name === "css")\n        includeEngine = false;\n      else if (p.name === "xpath" && p.source.startsWith("//") || p.source.startsWith(".."))\n        includeEngine = false;\n    }\n    const prefix = includeEngine ? p.name + "=" : "";\n    return `${i === selector.capture ? "*" : ""}${prefix}${p.source}`;\n  }).join(" >> ");\n}\nfunction visitAllSelectorParts(selector, visitor) {\n  const visit = (selector2, nested) => {\n    for (const part of selector2.parts) {\n      visitor(part, nested);\n      if (kNestedSelectorNames.has(part.name))\n        visit(part.body.parsed, true);\n    }\n  };\n  visit(selector, false);\n}\nfunction parseSelectorString(selector) {\n  let index = 0;\n  let quote;\n  let start = 0;\n  const result = { parts: [] };\n  const append = () => {\n    const part = selector.substring(start, index).trim();\n    const eqIndex = part.indexOf("=");\n    let name;\n    let body;\n    if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {\n      name = part.substring(0, eqIndex).trim();\n      body = part.substring(eqIndex + 1);\n    } else if (part.length > 1 && part[0] === \'"\' && part[part.length - 1] === \'"\') {\n      name = "text";\n      body = part;\n    } else if (part.length > 1 && part[0] === "\'" && part[part.length - 1] === "\'") {\n      name = "text";\n      body = part;\n    } else if (/^\\(*\\/\\//.test(part) || part.startsWith("..")) {\n      name = "xpath";\n      body = part;\n    } else {\n      name = "css";\n      body = part;\n    }\n    let capture = false;\n    if (name[0] === "*") {\n      capture = true;\n      name = name.substring(1);\n    }\n    result.parts.push({ name, body });\n    if (capture) {\n      if (result.capture !== void 0)\n        throw new InvalidSelectorError(`Only one of the selectors can capture using * modifier`);\n      result.capture = result.parts.length - 1;\n    }\n  };\n  if (!selector.includes(">>")) {\n    index = selector.length;\n    append();\n    return result;\n  }\n  const shouldIgnoreTextSelectorQuote = () => {\n    const prefix = selector.substring(start, index);\n    const match = prefix.match(/^\\s*text\\s*=(.*)$/);\n    return !!match && !!match[1];\n  };\n  while (index < selector.length) {\n    const c = selector[index];\n    if (c === "\\\\" && index + 1 < selector.length) {\n      index += 2;\n    } else if (c === quote) {\n      quote = void 0;\n      index++;\n    } else if (!quote && (c === \'"\' || c === "\'" || c === "`") && !shouldIgnoreTextSelectorQuote()) {\n      quote = c;\n      index++;\n    } else if (!quote && c === ">" && selector[index + 1] === ">") {\n      append();\n      index += 2;\n      start = index;\n    } else {\n      index++;\n    }\n  }\n  append();\n  return result;\n}\nfunction parseAttributeSelector(selector, allowUnquotedStrings) {\n  let wp = 0;\n  let EOL = selector.length === 0;\n  const next = () => selector[wp] || "";\n  const eat1 = () => {\n    const result2 = next();\n    ++wp;\n    EOL = wp >= selector.length;\n    return result2;\n  };\n  const syntaxError = (stage) => {\n    if (EOL)\n      throw new InvalidSelectorError(`Unexpected end of selector while parsing selector \\`${selector}\\``);\n    throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - unexpected symbol "${next()}" at position ${wp}` + (stage ? " during " + stage : ""));\n  };\n  function skipSpaces() {\n    while (!EOL && /\\s/.test(next()))\n      eat1();\n  }\n  function isCSSNameChar(char) {\n    return char >= "\\x80" || char >= "0" && char <= "9" || char >= "A" && char <= "Z" || char >= "a" && char <= "z" || char >= "0" && char <= "9" || char === "_" || char === "-";\n  }\n  function readIdentifier() {\n    let result2 = "";\n    skipSpaces();\n    while (!EOL && isCSSNameChar(next()))\n      result2 += eat1();\n    return result2;\n  }\n  function readQuotedString(quote) {\n    let result2 = eat1();\n    if (result2 !== quote)\n      syntaxError("parsing quoted string");\n    while (!EOL && next() !== quote) {\n      if (next() === "\\\\")\n        eat1();\n      result2 += eat1();\n    }\n    if (next() !== quote)\n      syntaxError("parsing quoted string");\n    result2 += eat1();\n    return result2;\n  }\n  function readRegularExpression() {\n    if (eat1() !== "/")\n      syntaxError("parsing regular expression");\n    let source = "";\n    let inClass = false;\n    while (!EOL) {\n      if (next() === "\\\\") {\n        source += eat1();\n        if (EOL)\n          syntaxError("parsing regular expression");\n      } else if (inClass && next() === "]") {\n        inClass = false;\n      } else if (!inClass && next() === "[") {\n        inClass = true;\n      } else if (!inClass && next() === "/") {\n        break;\n      }\n      source += eat1();\n    }\n    if (eat1() !== "/")\n      syntaxError("parsing regular expression");\n    let flags = "";\n    while (!EOL && next().match(/[dgimsuy]/))\n      flags += eat1();\n    try {\n      return new RegExp(source, flags);\n    } catch (e) {\n      throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\`: ${e.message}`);\n    }\n  }\n  function readAttributeToken() {\n    let token = "";\n    skipSpaces();\n    if (next() === `\'` || next() === `"`)\n      token = readQuotedString(next()).slice(1, -1);\n    else\n      token = readIdentifier();\n    if (!token)\n      syntaxError("parsing property path");\n    return token;\n  }\n  function readOperator() {\n    skipSpaces();\n    let op = "";\n    if (!EOL)\n      op += eat1();\n    if (!EOL && op !== "=")\n      op += eat1();\n    if (!["=", "*=", "^=", "$=", "|=", "~="].includes(op))\n      syntaxError("parsing operator");\n    return op;\n  }\n  function readAttribute() {\n    eat1();\n    const jsonPath = [];\n    jsonPath.push(readAttributeToken());\n    skipSpaces();\n    while (next() === ".") {\n      eat1();\n      jsonPath.push(readAttributeToken());\n      skipSpaces();\n    }\n    if (next() === "]") {\n      eat1();\n      return { name: jsonPath.join("."), jsonPath, op: "<truthy>", value: null, caseSensitive: false };\n    }\n    const operator = readOperator();\n    let value = void 0;\n    let caseSensitive = true;\n    skipSpaces();\n    if (next() === "/") {\n      if (operator !== "=")\n        throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - cannot use ${operator} in attribute with regular expression`);\n      value = readRegularExpression();\n    } else if (next() === `\'` || next() === `"`) {\n      value = readQuotedString(next()).slice(1, -1);\n      skipSpaces();\n      if (next() === "i" || next() === "I") {\n        caseSensitive = false;\n        eat1();\n      } else if (next() === "s" || next() === "S") {\n        caseSensitive = true;\n        eat1();\n      }\n    } else {\n      value = "";\n      while (!EOL && (isCSSNameChar(next()) || next() === "+" || next() === "."))\n        value += eat1();\n      if (value === "true") {\n        value = true;\n      } else if (value === "false") {\n        value = false;\n      } else {\n        if (!allowUnquotedStrings) {\n          value = +value;\n          if (Number.isNaN(value))\n            syntaxError("parsing attribute value");\n        }\n      }\n    }\n    skipSpaces();\n    if (next() !== "]")\n      syntaxError("parsing attribute value");\n    eat1();\n    if (operator !== "=" && typeof value !== "string")\n      throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - cannot use ${operator} in attribute with non-string matching value - ${value}`);\n    return { name: jsonPath.join("."), jsonPath, op: operator, value, caseSensitive };\n  }\n  const result = {\n    name: "",\n    attributes: []\n  };\n  result.name = readIdentifier();\n  skipSpaces();\n  while (next() === "[") {\n    result.attributes.push(readAttribute());\n    skipSpaces();\n  }\n  if (!EOL)\n    syntaxError(void 0);\n  if (!result.name && !result.attributes.length)\n    throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - selector cannot be empty`);\n  return result;\n}\n\n// packages/playwright-core/src/utils/isomorphic/stringUtils.ts\nfunction escapeWithQuotes(text, char = "\'") {\n  const stringified = JSON.stringify(text);\n  const escapedText = stringified.substring(1, stringified.length - 1).replace(/\\\\"/g, \'"\');\n  if (char === "\'")\n    return char + escapedText.replace(/[\']/g, "\\\\\'") + char;\n  if (char === \'"\')\n    return char + escapedText.replace(/["]/g, \'\\\\"\') + char;\n  if (char === "`")\n    return char + escapedText.replace(/[`]/g, "\\\\`") + char;\n  throw new Error("Invalid escape char");\n}\nfunction toTitleCase(name) {\n  return name.charAt(0).toUpperCase() + name.substring(1);\n}\nfunction toSnakeCase(name) {\n  return name.replace(/([a-z0-9])([A-Z])/g, "$1_$2").replace(/([A-Z])([A-Z][a-z])/g, "$1_$2").toLowerCase();\n}\nfunction quoteCSSAttributeValue(text) {\n  return `"${text.replace(/["\\\\]/g, (char) => "\\\\" + char)}"`;\n}\nvar normalizedWhitespaceCache;\nfunction cacheNormalizedWhitespaces() {\n  normalizedWhitespaceCache = /* @__PURE__ */ new Map();\n}\nfunction normalizeWhiteSpace(text) {\n  let result = normalizedWhitespaceCache == null ? void 0 : normalizedWhitespaceCache.get(text);\n  if (result === void 0) {\n    result = text.replace(/[\\u200b\\u00ad]/g, "").trim().replace(/\\s+/g, " ");\n    normalizedWhitespaceCache == null ? void 0 : normalizedWhitespaceCache.set(text, result);\n  }\n  return result;\n}\nfunction normalizeEscapedRegexQuotes(source) {\n  return source.replace(/(^|[^\\\\])(\\\\\\\\)*\\\\([\'"`])/g, "$1$2$3");\n}\nfunction escapeRegexForSelector(re) {\n  if (re.unicode || re.unicodeSets)\n    return String(re);\n  return String(re).replace(/(^|[^\\\\])(\\\\\\\\)*(["\'`])/g, "$1$2\\\\$3").replace(/>>/g, "\\\\>\\\\>");\n}\nfunction escapeForTextSelector(text, exact) {\n  if (typeof text !== "string")\n    return escapeRegexForSelector(text);\n  return `${JSON.stringify(text)}${exact ? "s" : "i"}`;\n}\nfunction escapeForAttributeSelector(value, exact) {\n  if (typeof value !== "string")\n    return escapeRegexForSelector(value);\n  return `"${value.replace(/\\\\/g, "\\\\\\\\").replace(/["]/g, \'\\\\"\')}"${exact ? "s" : "i"}`;\n}\nfunction trimString(input, cap, suffix = "") {\n  if (input.length <= cap)\n    return input;\n  const chars = [...input];\n  if (chars.length > cap)\n    return chars.slice(0, cap - suffix.length).join("") + suffix;\n  return chars.join("");\n}\nfunction trimStringWithEllipsis(input, cap) {\n  return trimString(input, cap, "\\u2026");\n}\nfunction escapeRegExp(s) {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&");\n}\nfunction longestCommonSubstring(s1, s2) {\n  const n = s1.length;\n  const m = s2.length;\n  let maxLen = 0;\n  let endingIndex = 0;\n  const dp = Array(n + 1).fill(null).map(() => Array(m + 1).fill(0));\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= m; j++) {\n      if (s1[i - 1] === s2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1] + 1;\n        if (dp[i][j] > maxLen) {\n          maxLen = dp[i][j];\n          endingIndex = i;\n        }\n      }\n    }\n  }\n  return s1.slice(endingIndex - maxLen, endingIndex);\n}\nvar ansiRegex = new RegExp("([\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:[a-zA-Z\\\\d]*(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)|(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~])))", "g");\n\n// packages/playwright-core/src/utils/isomorphic/locatorGenerators.ts\nfunction asLocator(lang, selector, isFrameLocator = false) {\n  return asLocators(lang, selector, isFrameLocator, 1)[0];\n}\nfunction asLocators(lang, selector, isFrameLocator = false, maxOutputSize = 20, preferredQuote) {\n  try {\n    return innerAsLocators(new generators[lang](preferredQuote), parseSelector(selector), isFrameLocator, maxOutputSize);\n  } catch (e) {\n    return [selector];\n  }\n}\nfunction innerAsLocators(factory, parsed, isFrameLocator = false, maxOutputSize = 20) {\n  const parts = [...parsed.parts];\n  const tokens = [];\n  let nextBase = isFrameLocator ? "frame-locator" : "page";\n  for (let index = 0; index < parts.length; index++) {\n    const part = parts[index];\n    const base = nextBase;\n    nextBase = "locator";\n    if (part.name === "internal:describe")\n      continue;\n    if (part.name === "nth") {\n      if (part.body === "0")\n        tokens.push([factory.generateLocator(base, "first", ""), factory.generateLocator(base, "nth", "0")]);\n      else if (part.body === "-1")\n        tokens.push([factory.generateLocator(base, "last", ""), factory.generateLocator(base, "nth", "-1")]);\n      else\n        tokens.push([factory.generateLocator(base, "nth", part.body)]);\n      continue;\n    }\n    if (part.name === "visible") {\n      tokens.push([factory.generateLocator(base, "visible", part.body), factory.generateLocator(base, "default", `visible=${part.body}`)]);\n      continue;\n    }\n    if (part.name === "internal:text") {\n      const { exact, text } = detectExact(part.body);\n      tokens.push([factory.generateLocator(base, "text", text, { exact })]);\n      continue;\n    }\n    if (part.name === "internal:has-text") {\n      const { exact, text } = detectExact(part.body);\n      if (!exact) {\n        tokens.push([factory.generateLocator(base, "has-text", text, { exact })]);\n        continue;\n      }\n    }\n    if (part.name === "internal:has-not-text") {\n      const { exact, text } = detectExact(part.body);\n      if (!exact) {\n        tokens.push([factory.generateLocator(base, "has-not-text", text, { exact })]);\n        continue;\n      }\n    }\n    if (part.name === "internal:has") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "has", inner)));\n      continue;\n    }\n    if (part.name === "internal:has-not") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "hasNot", inner)));\n      continue;\n    }\n    if (part.name === "internal:and") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "and", inner)));\n      continue;\n    }\n    if (part.name === "internal:or") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "or", inner)));\n      continue;\n    }\n    if (part.name === "internal:chain") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "chain", inner)));\n      continue;\n    }\n    if (part.name === "internal:label") {\n      const { exact, text } = detectExact(part.body);\n      tokens.push([factory.generateLocator(base, "label", text, { exact })]);\n      continue;\n    }\n    if (part.name === "internal:role") {\n      const attrSelector = parseAttributeSelector(part.body, true);\n      const options = { attrs: [] };\n      for (const attr of attrSelector.attributes) {\n        if (attr.name === "name") {\n          options.exact = attr.caseSensitive;\n          options.name = attr.value;\n        } else {\n          if (attr.name === "level" && typeof attr.value === "string")\n            attr.value = +attr.value;\n          options.attrs.push({ name: attr.name === "include-hidden" ? "includeHidden" : attr.name, value: attr.value });\n        }\n      }\n      tokens.push([factory.generateLocator(base, "role", attrSelector.name, options)]);\n      continue;\n    }\n    if (part.name === "internal:testid") {\n      const attrSelector = parseAttributeSelector(part.body, true);\n      const { value } = attrSelector.attributes[0];\n      tokens.push([factory.generateLocator(base, "test-id", value)]);\n      continue;\n    }\n    if (part.name === "internal:attr") {\n      const attrSelector = parseAttributeSelector(part.body, true);\n      const { name, value, caseSensitive } = attrSelector.attributes[0];\n      const text = value;\n      const exact = !!caseSensitive;\n      if (name === "placeholder") {\n        tokens.push([factory.generateLocator(base, "placeholder", text, { exact })]);\n        continue;\n      }\n      if (name === "alt") {\n        tokens.push([factory.generateLocator(base, "alt", text, { exact })]);\n        continue;\n      }\n      if (name === "title") {\n        tokens.push([factory.generateLocator(base, "title", text, { exact })]);\n        continue;\n      }\n    }\n    if (part.name === "internal:control" && part.body === "enter-frame") {\n      const lastTokens = tokens[tokens.length - 1];\n      const lastPart = parts[index - 1];\n      const transformed = lastTokens.map((token) => factory.chainLocators([token, factory.generateLocator(base, "frame", "")]));\n      if (["xpath", "css"].includes(lastPart.name)) {\n        transformed.push(\n          factory.generateLocator(base, "frame-locator", stringifySelector({ parts: [lastPart] })),\n          factory.generateLocator(base, "frame-locator", stringifySelector({ parts: [lastPart] }, true))\n        );\n      }\n      lastTokens.splice(0, lastTokens.length, ...transformed);\n      nextBase = "frame-locator";\n      continue;\n    }\n    const nextPart = parts[index + 1];\n    const selectorPart = stringifySelector({ parts: [part] });\n    const locatorPart = factory.generateLocator(base, "default", selectorPart);\n    if (nextPart && ["internal:has-text", "internal:has-not-text"].includes(nextPart.name)) {\n      const { exact, text } = detectExact(nextPart.body);\n      if (!exact) {\n        const nextLocatorPart = factory.generateLocator("locator", nextPart.name === "internal:has-text" ? "has-text" : "has-not-text", text, { exact });\n        const options = {};\n        if (nextPart.name === "internal:has-text")\n          options.hasText = text;\n        else\n          options.hasNotText = text;\n        const combinedPart = factory.generateLocator(base, "default", selectorPart, options);\n        tokens.push([factory.chainLocators([locatorPart, nextLocatorPart]), combinedPart]);\n        index++;\n        continue;\n      }\n    }\n    let locatorPartWithEngine;\n    if (["xpath", "css"].includes(part.name)) {\n      const selectorPart2 = stringifySelector(\n        { parts: [part] },\n        /* forceEngineName */\n        true\n      );\n      locatorPartWithEngine = factory.generateLocator(base, "default", selectorPart2);\n    }\n    tokens.push([locatorPart, locatorPartWithEngine].filter(Boolean));\n  }\n  return combineTokens(factory, tokens, maxOutputSize);\n}\nfunction combineTokens(factory, tokens, maxOutputSize) {\n  const currentTokens = tokens.map(() => "");\n  const result = [];\n  const visit = (index) => {\n    if (index === tokens.length) {\n      result.push(factory.chainLocators(currentTokens));\n      return result.length < maxOutputSize;\n    }\n    for (const taken of tokens[index]) {\n      currentTokens[index] = taken;\n      if (!visit(index + 1))\n        return false;\n    }\n    return true;\n  };\n  visit(0);\n  return result;\n}\nfunction detectExact(text) {\n  let exact = false;\n  const match = text.match(/^\\/(.*)\\/([igm]*)$/);\n  if (match)\n    return { text: new RegExp(match[1], match[2]) };\n  if (text.endsWith(\'"\')) {\n    text = JSON.parse(text);\n    exact = true;\n  } else if (text.endsWith(\'"s\')) {\n    text = JSON.parse(text.substring(0, text.length - 1));\n    exact = true;\n  } else if (text.endsWith(\'"i\')) {\n    text = JSON.parse(text.substring(0, text.length - 1));\n    exact = false;\n  }\n  return { exact, text };\n}\nvar JavaScriptLocatorFactory = class {\n  constructor(preferredQuote) {\n    this.preferredQuote = preferredQuote;\n  }\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `locator(${this.quote(body)}, { hasText: ${this.toHasText(options.hasText)} })`;\n        if (options.hasNotText !== void 0)\n          return `locator(${this.quote(body)}, { hasNotText: ${this.toHasText(options.hasNotText)} })`;\n        return `locator(${this.quote(body)})`;\n      case "frame-locator":\n        return `frameLocator(${this.quote(body)})`;\n      case "frame":\n        return `contentFrame()`;\n      case "nth":\n        return `nth(${body})`;\n      case "first":\n        return `first()`;\n      case "last":\n        return `last()`;\n      case "visible":\n        return `filter({ visible: ${body === "true" ? "true" : "false"} })`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`name: ${this.regexToSourceString(options.name)}`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`name: ${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`exact: true`);\n        }\n        for (const { name, value } of options.attrs)\n          attrs.push(`${name}: ${typeof value === "string" ? this.quote(value) : value}`);\n        const attrString = attrs.length ? `, { ${attrs.join(", ")} }` : "";\n        return `getByRole(${this.quote(body)}${attrString})`;\n      case "has-text":\n        return `filter({ hasText: ${this.toHasText(body)} })`;\n      case "has-not-text":\n        return `filter({ hasNotText: ${this.toHasText(body)} })`;\n      case "has":\n        return `filter({ has: ${body} })`;\n      case "hasNot":\n        return `filter({ hasNot: ${body} })`;\n      case "and":\n        return `and(${body})`;\n      case "or":\n        return `or(${body})`;\n      case "chain":\n        return `locator(${body})`;\n      case "test-id":\n        return `getByTestId(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact("getByText", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact("getByAltText", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact("getByPlaceholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact("getByLabel", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact("getByTitle", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  regexToSourceString(re) {\n    return normalizeEscapedRegexQuotes(String(re));\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToSourceString(body)})`;\n    return exact ? `${method}(${this.quote(body)}, { exact: true })` : `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return this.regexToSourceString(body);\n    return this.quote(body);\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToSourceString(value);\n    return this.quote(value);\n  }\n  quote(text) {\n    var _a;\n    return escapeWithQuotes(text, (_a = this.preferredQuote) != null ? _a : "\'");\n  }\n};\nvar PythonLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `locator(${this.quote(body)}, has_text=${this.toHasText(options.hasText)})`;\n        if (options.hasNotText !== void 0)\n          return `locator(${this.quote(body)}, has_not_text=${this.toHasText(options.hasNotText)})`;\n        return `locator(${this.quote(body)})`;\n      case "frame-locator":\n        return `frame_locator(${this.quote(body)})`;\n      case "frame":\n        return `content_frame`;\n      case "nth":\n        return `nth(${body})`;\n      case "first":\n        return `first`;\n      case "last":\n        return `last`;\n      case "visible":\n        return `filter(visible=${body === "true" ? "True" : "False"})`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`name=${this.regexToString(options.name)}`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`name=${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`exact=True`);\n        }\n        for (const { name, value } of options.attrs) {\n          let valueString = typeof value === "string" ? this.quote(value) : value;\n          if (typeof value === "boolean")\n            valueString = value ? "True" : "False";\n          attrs.push(`${toSnakeCase(name)}=${valueString}`);\n        }\n        const attrString = attrs.length ? `, ${attrs.join(", ")}` : "";\n        return `get_by_role(${this.quote(body)}${attrString})`;\n      case "has-text":\n        return `filter(has_text=${this.toHasText(body)})`;\n      case "has-not-text":\n        return `filter(has_not_text=${this.toHasText(body)})`;\n      case "has":\n        return `filter(has=${body})`;\n      case "hasNot":\n        return `filter(has_not=${body})`;\n      case "and":\n        return `and_(${body})`;\n      case "or":\n        return `or_(${body})`;\n      case "chain":\n        return `locator(${body})`;\n      case "test-id":\n        return `get_by_test_id(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact("get_by_text", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact("get_by_alt_text", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact("get_by_placeholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact("get_by_label", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact("get_by_title", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes("i") ? ", re.IGNORECASE" : "";\n    return `re.compile(r"${normalizeEscapedRegexQuotes(body.source).replace(/\\\\\\//, "/").replace(/"/g, \'\\\\"\')}"${suffix})`;\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, exact=True)`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return this.regexToString(body);\n    return `${this.quote(body)}`;\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n  quote(text) {\n    return escapeWithQuotes(text, \'"\');\n  }\n};\nvar JavaLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    let clazz;\n    switch (base) {\n      case "page":\n        clazz = "Page";\n        break;\n      case "frame-locator":\n        clazz = "FrameLocator";\n        break;\n      case "locator":\n        clazz = "Locator";\n        break;\n    }\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `locator(${this.quote(body)}, new ${clazz}.LocatorOptions().setHasText(${this.toHasText(options.hasText)}))`;\n        if (options.hasNotText !== void 0)\n          return `locator(${this.quote(body)}, new ${clazz}.LocatorOptions().setHasNotText(${this.toHasText(options.hasNotText)}))`;\n        return `locator(${this.quote(body)})`;\n      case "frame-locator":\n        return `frameLocator(${this.quote(body)})`;\n      case "frame":\n        return `contentFrame()`;\n      case "nth":\n        return `nth(${body})`;\n      case "first":\n        return `first()`;\n      case "last":\n        return `last()`;\n      case "visible":\n        return `filter(new ${clazz}.FilterOptions().setVisible(${body === "true" ? "true" : "false"}))`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`.setName(${this.regexToString(options.name)})`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`.setName(${this.quote(options.name)})`);\n          if (options.exact)\n            attrs.push(`.setExact(true)`);\n        }\n        for (const { name, value } of options.attrs)\n          attrs.push(`.set${toTitleCase(name)}(${typeof value === "string" ? this.quote(value) : value})`);\n        const attrString = attrs.length ? `, new ${clazz}.GetByRoleOptions()${attrs.join("")}` : "";\n        return `getByRole(AriaRole.${toSnakeCase(body).toUpperCase()}${attrString})`;\n      case "has-text":\n        return `filter(new ${clazz}.FilterOptions().setHasText(${this.toHasText(body)}))`;\n      case "has-not-text":\n        return `filter(new ${clazz}.FilterOptions().setHasNotText(${this.toHasText(body)}))`;\n      case "has":\n        return `filter(new ${clazz}.FilterOptions().setHas(${body}))`;\n      case "hasNot":\n        return `filter(new ${clazz}.FilterOptions().setHasNot(${body}))`;\n      case "and":\n        return `and(${body})`;\n      case "or":\n        return `or(${body})`;\n      case "chain":\n        return `locator(${body})`;\n      case "test-id":\n        return `getByTestId(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact(clazz, "getByText", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact(clazz, "getByAltText", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact(clazz, "getByPlaceholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact(clazz, "getByLabel", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact(clazz, "getByTitle", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes("i") ? ", Pattern.CASE_INSENSITIVE" : "";\n    return `Pattern.compile(${this.quote(normalizeEscapedRegexQuotes(body.source))}${suffix})`;\n  }\n  toCallWithExact(clazz, method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, new ${clazz}.${toTitleCase(method)}Options().setExact(true))`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return this.regexToString(body);\n    return this.quote(body);\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n  quote(text) {\n    return escapeWithQuotes(text, \'"\');\n  }\n};\nvar CSharpLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `Locator(${this.quote(body)}, new() { ${this.toHasText(options.hasText)} })`;\n        if (options.hasNotText !== void 0)\n          return `Locator(${this.quote(body)}, new() { ${this.toHasNotText(options.hasNotText)} })`;\n        return `Locator(${this.quote(body)})`;\n      case "frame-locator":\n        return `FrameLocator(${this.quote(body)})`;\n      case "frame":\n        return `ContentFrame`;\n      case "nth":\n        return `Nth(${body})`;\n      case "first":\n        return `First`;\n      case "last":\n        return `Last`;\n      case "visible":\n        return `Filter(new() { Visible = ${body === "true" ? "true" : "false"} })`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`NameRegex = ${this.regexToString(options.name)}`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`Name = ${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`Exact = true`);\n        }\n        for (const { name, value } of options.attrs)\n          attrs.push(`${toTitleCase(name)} = ${typeof value === "string" ? this.quote(value) : value}`);\n        const attrString = attrs.length ? `, new() { ${attrs.join(", ")} }` : "";\n        return `GetByRole(AriaRole.${toTitleCase(body)}${attrString})`;\n      case "has-text":\n        return `Filter(new() { ${this.toHasText(body)} })`;\n      case "has-not-text":\n        return `Filter(new() { ${this.toHasNotText(body)} })`;\n      case "has":\n        return `Filter(new() { Has = ${body} })`;\n      case "hasNot":\n        return `Filter(new() { HasNot = ${body} })`;\n      case "and":\n        return `And(${body})`;\n      case "or":\n        return `Or(${body})`;\n      case "chain":\n        return `Locator(${body})`;\n      case "test-id":\n        return `GetByTestId(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact("GetByText", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact("GetByAltText", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact("GetByPlaceholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact("GetByLabel", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact("GetByTitle", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes("i") ? ", RegexOptions.IgnoreCase" : "";\n    return `new Regex(${this.quote(normalizeEscapedRegexQuotes(body.source))}${suffix})`;\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, new() { Exact = true })`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return `HasTextRegex = ${this.regexToString(body)}`;\n    return `HasText = ${this.quote(body)}`;\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n  toHasNotText(body) {\n    if (isRegExp(body))\n      return `HasNotTextRegex = ${this.regexToString(body)}`;\n    return `HasNotText = ${this.quote(body)}`;\n  }\n  quote(text) {\n    return escapeWithQuotes(text, \'"\');\n  }\n};\nvar JsonlLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    return JSON.stringify({\n      kind,\n      body,\n      options\n    });\n  }\n  chainLocators(locators) {\n    const objects = locators.map((l) => JSON.parse(l));\n    for (let i = 0; i < objects.length - 1; ++i)\n      objects[i].next = objects[i + 1];\n    return JSON.stringify(objects[0]);\n  }\n};\nvar generators = {\n  javascript: JavaScriptLocatorFactory,\n  python: PythonLocatorFactory,\n  java: JavaLocatorFactory,\n  csharp: CSharpLocatorFactory,\n  jsonl: JsonlLocatorFactory\n};\nfunction isRegExp(obj) {\n  return obj instanceof RegExp;\n}\n\n// packages/playwright-core/src/utils/isomorphic/yaml.ts\nfunction yamlEscapeKeyIfNeeded(str) {\n  if (!yamlStringNeedsQuotes(str))\n    return str;\n  return `\'` + str.replace(/\'/g, `\'\'`) + `\'`;\n}\nfunction yamlEscapeValueIfNeeded(str) {\n  if (!yamlStringNeedsQuotes(str))\n    return str;\n  return \'"\' + str.replace(/[\\\\"\\x00-\\x1f\\x7f-\\x9f]/g, (c) => {\n    switch (c) {\n      case "\\\\":\n        return "\\\\\\\\";\n      case \'"\':\n        return \'\\\\"\';\n      case "\\b":\n        return "\\\\b";\n      case "\\f":\n        return "\\\\f";\n      case "\\n":\n        return "\\\\n";\n      case "\\r":\n        return "\\\\r";\n      case "	":\n        return "\\\\t";\n      default:\n        const code = c.charCodeAt(0);\n        return "\\\\x" + code.toString(16).padStart(2, "0");\n    }\n  }) + \'"\';\n}\nfunction yamlStringNeedsQuotes(str) {\n  if (str.length === 0)\n    return true;\n  if (/^\\s|\\s$/.test(str))\n    return true;\n  if (/[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f-\\x9f]/.test(str))\n    return true;\n  if (/^-/.test(str))\n    return true;\n  if (/[\\n:](\\s|$)/.test(str))\n    return true;\n  if (/\\s#/.test(str))\n    return true;\n  if (/[\\n\\r]/.test(str))\n    return true;\n  if (/^[&*\\],?!>|@"\'#%]/.test(str))\n    return true;\n  if (/[{}`]/.test(str))\n    return true;\n  if (/^\\[/.test(str))\n    return true;\n  if (!isNaN(Number(str)) || ["y", "n", "yes", "no", "true", "false", "on", "off", "null"].includes(str.toLowerCase()))\n    return true;\n  return false;\n}\n\n// packages/injected/src/domUtils.ts\nvar globalOptions = {};\nfunction setGlobalOptions(options) {\n  globalOptions = options;\n}\nfunction isInsideScope(scope, element) {\n  while (element) {\n    if (scope.contains(element))\n      return true;\n    element = enclosingShadowHost(element);\n  }\n  return false;\n}\nfunction parentElementOrShadowHost(element) {\n  if (element.parentElement)\n    return element.parentElement;\n  if (!element.parentNode)\n    return;\n  if (element.parentNode.nodeType === 11 && element.parentNode.host)\n    return element.parentNode.host;\n}\nfunction enclosingShadowRootOrDocument(element) {\n  let node = element;\n  while (node.parentNode)\n    node = node.parentNode;\n  if (node.nodeType === 11 || node.nodeType === 9)\n    return node;\n}\nfunction enclosingShadowHost(element) {\n  while (element.parentElement)\n    element = element.parentElement;\n  return parentElementOrShadowHost(element);\n}\nfunction closestCrossShadow(element, css, scope) {\n  while (element) {\n    const closest = element.closest(css);\n    if (scope && closest !== scope && (closest == null ? void 0 : closest.contains(scope)))\n      return;\n    if (closest)\n      return closest;\n    element = enclosingShadowHost(element);\n  }\n}\nfunction getElementComputedStyle(element, pseudo) {\n  const cache = pseudo === "::before" ? cacheStyleBefore : pseudo === "::after" ? cacheStyleAfter : cacheStyle;\n  if (cache && cache.has(element))\n    return cache.get(element);\n  const style = element.ownerDocument && element.ownerDocument.defaultView ? element.ownerDocument.defaultView.getComputedStyle(element, pseudo) : void 0;\n  cache == null ? void 0 : cache.set(element, style);\n  return style;\n}\nfunction isElementStyleVisibilityVisible(element, style) {\n  style = style != null ? style : getElementComputedStyle(element);\n  if (!style)\n    return true;\n  if (Element.prototype.checkVisibility && globalOptions.browserNameForWorkarounds !== "webkit") {\n    if (!element.checkVisibility())\n      return false;\n  } else {\n    const detailsOrSummary = element.closest("details,summary");\n    if (detailsOrSummary !== element && (detailsOrSummary == null ? void 0 : detailsOrSummary.nodeName) === "DETAILS" && !detailsOrSummary.open)\n      return false;\n  }\n  if (style.visibility !== "visible")\n    return false;\n  return true;\n}\nfunction computeBox(element) {\n  const style = getElementComputedStyle(element);\n  if (!style)\n    return { visible: true, inline: false };\n  const cursor = style.cursor;\n  if (style.display === "contents") {\n    for (let child = element.firstChild; child; child = child.nextSibling) {\n      if (child.nodeType === 1 && isElementVisible(child))\n        return { visible: true, inline: false, cursor };\n      if (child.nodeType === 3 && isVisibleTextNode(child))\n        return { visible: true, inline: true, cursor };\n    }\n    return { visible: false, inline: false, cursor };\n  }\n  if (!isElementStyleVisibilityVisible(element, style))\n    return { cursor, visible: false, inline: false };\n  const rect = element.getBoundingClientRect();\n  return { cursor, visible: rect.width > 0 && rect.height > 0, inline: style.display === "inline" };\n}\nfunction isElementVisible(element) {\n  return computeBox(element).visible;\n}\nfunction isVisibleTextNode(node) {\n  const range = node.ownerDocument.createRange();\n  range.selectNode(node);\n  const rect = range.getBoundingClientRect();\n  return rect.width > 0 && rect.height > 0;\n}\nfunction elementSafeTagName(element) {\n  const tagName = element.tagName;\n  if (typeof tagName === "string")\n    return tagName.toUpperCase();\n  if (element instanceof HTMLFormElement)\n    return "FORM";\n  return element.tagName.toUpperCase();\n}\nvar cacheStyle;\nvar cacheStyleBefore;\nvar cacheStyleAfter;\nvar cachesCounter = 0;\nfunction beginDOMCaches() {\n  ++cachesCounter;\n  cacheStyle != null ? cacheStyle : cacheStyle = /* @__PURE__ */ new Map();\n  cacheStyleBefore != null ? cacheStyleBefore : cacheStyleBefore = /* @__PURE__ */ new Map();\n  cacheStyleAfter != null ? cacheStyleAfter : cacheStyleAfter = /* @__PURE__ */ new Map();\n}\nfunction endDOMCaches() {\n  if (!--cachesCounter) {\n    cacheStyle = void 0;\n    cacheStyleBefore = void 0;\n    cacheStyleAfter = void 0;\n  }\n}\n\n// packages/injected/src/roleUtils.ts\nfunction hasExplicitAccessibleName(e) {\n  return e.hasAttribute("aria-label") || e.hasAttribute("aria-labelledby");\n}\nvar kAncestorPreventingLandmark = "article:not([role]), aside:not([role]), main:not([role]), nav:not([role]), section:not([role]), [role=article], [role=complementary], [role=main], [role=navigation], [role=region]";\nvar kGlobalAriaAttributes = [\n  ["aria-atomic", void 0],\n  ["aria-busy", void 0],\n  ["aria-controls", void 0],\n  ["aria-current", void 0],\n  ["aria-describedby", void 0],\n  ["aria-details", void 0],\n  // Global use deprecated in ARIA 1.2\n  // [\'aria-disabled\', undefined],\n  ["aria-dropeffect", void 0],\n  // Global use deprecated in ARIA 1.2\n  // [\'aria-errormessage\', undefined],\n  ["aria-flowto", void 0],\n  ["aria-grabbed", void 0],\n  // Global use deprecated in ARIA 1.2\n  // [\'aria-haspopup\', undefined],\n  ["aria-hidden", void 0],\n  // Global use deprecated in ARIA 1.2\n  // [\'aria-invalid\', undefined],\n  ["aria-keyshortcuts", void 0],\n  ["aria-label", ["caption", "code", "deletion", "emphasis", "generic", "insertion", "paragraph", "presentation", "strong", "subscript", "superscript"]],\n  ["aria-labelledby", ["caption", "code", "deletion", "emphasis", "generic", "insertion", "paragraph", "presentation", "strong", "subscript", "superscript"]],\n  ["aria-live", void 0],\n  ["aria-owns", void 0],\n  ["aria-relevant", void 0],\n  ["aria-roledescription", ["generic"]]\n];\nfunction hasGlobalAriaAttribute(element, forRole) {\n  return kGlobalAriaAttributes.some(([attr, prohibited]) => {\n    return !(prohibited == null ? void 0 : prohibited.includes(forRole || "")) && element.hasAttribute(attr);\n  });\n}\nfunction hasTabIndex(element) {\n  return !Number.isNaN(Number(String(element.getAttribute("tabindex"))));\n}\nfunction isFocusable(element) {\n  return !isNativelyDisabled(element) && (isNativelyFocusable(element) || hasTabIndex(element));\n}\nfunction isNativelyFocusable(element) {\n  const tagName = elementSafeTagName(element);\n  if (["BUTTON", "DETAILS", "SELECT", "TEXTAREA"].includes(tagName))\n    return true;\n  if (tagName === "A" || tagName === "AREA")\n    return element.hasAttribute("href");\n  if (tagName === "INPUT")\n    return !element.hidden;\n  return false;\n}\nvar kImplicitRoleByTagName = {\n  "A": (e) => {\n    return e.hasAttribute("href") ? "link" : null;\n  },\n  "AREA": (e) => {\n    return e.hasAttribute("href") ? "link" : null;\n  },\n  "ARTICLE": () => "article",\n  "ASIDE": () => "complementary",\n  "BLOCKQUOTE": () => "blockquote",\n  "BUTTON": () => "button",\n  "CAPTION": () => "caption",\n  "CODE": () => "code",\n  "DATALIST": () => "listbox",\n  "DD": () => "definition",\n  "DEL": () => "deletion",\n  "DETAILS": () => "group",\n  "DFN": () => "term",\n  "DIALOG": () => "dialog",\n  "DT": () => "term",\n  "EM": () => "emphasis",\n  "FIELDSET": () => "group",\n  "FIGURE": () => "figure",\n  "FOOTER": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : "contentinfo",\n  "FORM": (e) => hasExplicitAccessibleName(e) ? "form" : null,\n  "H1": () => "heading",\n  "H2": () => "heading",\n  "H3": () => "heading",\n  "H4": () => "heading",\n  "H5": () => "heading",\n  "H6": () => "heading",\n  "HEADER": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : "banner",\n  "HR": () => "separator",\n  "HTML": () => "document",\n  "IMG": (e) => e.getAttribute("alt") === "" && !e.getAttribute("title") && !hasGlobalAriaAttribute(e) && !hasTabIndex(e) ? "presentation" : "img",\n  "INPUT": (e) => {\n    const type = e.type.toLowerCase();\n    if (type === "search")\n      return e.hasAttribute("list") ? "combobox" : "searchbox";\n    if (["email", "tel", "text", "url", ""].includes(type)) {\n      const list = getIdRefs(e, e.getAttribute("list"))[0];\n      return list && elementSafeTagName(list) === "DATALIST" ? "combobox" : "textbox";\n    }\n    if (type === "hidden")\n      return null;\n    if (type === "file")\n      return "button";\n    return inputTypeToRole[type] || "textbox";\n  },\n  "INS": () => "insertion",\n  "LI": () => "listitem",\n  "MAIN": () => "main",\n  "MARK": () => "mark",\n  "MATH": () => "math",\n  "MENU": () => "list",\n  "METER": () => "meter",\n  "NAV": () => "navigation",\n  "OL": () => "list",\n  "OPTGROUP": () => "group",\n  "OPTION": () => "option",\n  "OUTPUT": () => "status",\n  "P": () => "paragraph",\n  "PROGRESS": () => "progressbar",\n  "SEARCH": () => "search",\n  "SECTION": (e) => hasExplicitAccessibleName(e) ? "region" : null,\n  "SELECT": (e) => e.hasAttribute("multiple") || e.size > 1 ? "listbox" : "combobox",\n  "STRONG": () => "strong",\n  "SUB": () => "subscript",\n  "SUP": () => "superscript",\n  // For <svg> we default to Chrome behavior:\n  // - Chrome reports \'img\'.\n  // - Firefox reports \'diagram\' that is not in official ARIA spec yet.\n  // - Safari reports \'no role\', but still computes accessible name.\n  "SVG": () => "img",\n  "TABLE": () => "table",\n  "TBODY": () => "rowgroup",\n  "TD": (e) => {\n    const table = closestCrossShadow(e, "table");\n    const role = table ? getExplicitAriaRole(table) : "";\n    return role === "grid" || role === "treegrid" ? "gridcell" : "cell";\n  },\n  "TEXTAREA": () => "textbox",\n  "TFOOT": () => "rowgroup",\n  "TH": (e) => {\n    const scope = e.getAttribute("scope");\n    if (scope === "col" || scope === "colgroup")\n      return "columnheader";\n    if (scope === "row" || scope === "rowgroup")\n      return "rowheader";\n    const nextSibling = e.nextElementSibling;\n    const prevSibling = e.previousElementSibling;\n    const row = !!e.parentElement && elementSafeTagName(e.parentElement) === "TR" ? e.parentElement : void 0;\n    if (!nextSibling && !prevSibling) {\n      if (row) {\n        const table = closestCrossShadow(row, "table");\n        if (table && table.rows.length <= 1)\n          return null;\n      }\n      return "columnheader";\n    }\n    if (isHeaderCell(nextSibling) && isHeaderCell(prevSibling))\n      return "columnheader";\n    if (isNonEmptyDataCell(nextSibling) || isNonEmptyDataCell(prevSibling))\n      return "rowheader";\n    return "columnheader";\n  },\n  "THEAD": () => "rowgroup",\n  "TIME": () => "time",\n  "TR": () => "row",\n  "UL": () => "list"\n};\nfunction isHeaderCell(element) {\n  return !!element && elementSafeTagName(element) === "TH";\n}\nfunction isNonEmptyDataCell(element) {\n  var _a;\n  if (!element || elementSafeTagName(element) !== "TD")\n    return false;\n  return !!(((_a = element.textContent) == null ? void 0 : _a.trim()) || element.children.length > 0);\n}\nvar kPresentationInheritanceParents = {\n  "DD": ["DL", "DIV"],\n  "DIV": ["DL"],\n  "DT": ["DL", "DIV"],\n  "LI": ["OL", "UL"],\n  "TBODY": ["TABLE"],\n  "TD": ["TR"],\n  "TFOOT": ["TABLE"],\n  "TH": ["TR"],\n  "THEAD": ["TABLE"],\n  "TR": ["THEAD", "TBODY", "TFOOT", "TABLE"]\n};\nfunction getImplicitAriaRole(element) {\n  var _a;\n  const implicitRole = ((_a = kImplicitRoleByTagName[elementSafeTagName(element)]) == null ? void 0 : _a.call(kImplicitRoleByTagName, element)) || "";\n  if (!implicitRole)\n    return null;\n  let ancestor = element;\n  while (ancestor) {\n    const parent = parentElementOrShadowHost(ancestor);\n    const parents = kPresentationInheritanceParents[elementSafeTagName(ancestor)];\n    if (!parents || !parent || !parents.includes(elementSafeTagName(parent)))\n      break;\n    const parentExplicitRole = getExplicitAriaRole(parent);\n    if ((parentExplicitRole === "none" || parentExplicitRole === "presentation") && !hasPresentationConflictResolution(parent, parentExplicitRole))\n      return parentExplicitRole;\n    ancestor = parent;\n  }\n  return implicitRole;\n}\nvar validRoles = [\n  "alert",\n  "alertdialog",\n  "application",\n  "article",\n  "banner",\n  "blockquote",\n  "button",\n  "caption",\n  "cell",\n  "checkbox",\n  "code",\n  "columnheader",\n  "combobox",\n  "complementary",\n  "contentinfo",\n  "definition",\n  "deletion",\n  "dialog",\n  "directory",\n  "document",\n  "emphasis",\n  "feed",\n  "figure",\n  "form",\n  "generic",\n  "grid",\n  "gridcell",\n  "group",\n  "heading",\n  "img",\n  "insertion",\n  "link",\n  "list",\n  "listbox",\n  "listitem",\n  "log",\n  "main",\n  "mark",\n  "marquee",\n  "math",\n  "meter",\n  "menu",\n  "menubar",\n  "menuitem",\n  "menuitemcheckbox",\n  "menuitemradio",\n  "navigation",\n  "none",\n  "note",\n  "option",\n  "paragraph",\n  "presentation",\n  "progressbar",\n  "radio",\n  "radiogroup",\n  "region",\n  "row",\n  "rowgroup",\n  "rowheader",\n  "scrollbar",\n  "search",\n  "searchbox",\n  "separator",\n  "slider",\n  "spinbutton",\n  "status",\n  "strong",\n  "subscript",\n  "superscript",\n  "switch",\n  "tab",\n  "table",\n  "tablist",\n  "tabpanel",\n  "term",\n  "textbox",\n  "time",\n  "timer",\n  "toolbar",\n  "tooltip",\n  "tree",\n  "treegrid",\n  "treeitem"\n];\nfunction getExplicitAriaRole(element) {\n  const roles = (element.getAttribute("role") || "").split(" ").map((role) => role.trim());\n  return roles.find((role) => validRoles.includes(role)) || null;\n}\nfunction hasPresentationConflictResolution(element, role) {\n  return hasGlobalAriaAttribute(element, role) || isFocusable(element);\n}\nfunction getAriaRole(element) {\n  const explicitRole = getExplicitAriaRole(element);\n  if (!explicitRole)\n    return getImplicitAriaRole(element);\n  if (explicitRole === "none" || explicitRole === "presentation") {\n    const implicitRole = getImplicitAriaRole(element);\n    if (hasPresentationConflictResolution(element, implicitRole))\n      return implicitRole;\n  }\n  return explicitRole;\n}\nfunction getAriaBoolean(attr) {\n  return attr === null ? void 0 : attr.toLowerCase() === "true";\n}\nfunction isElementIgnoredForAria(element) {\n  return ["STYLE", "SCRIPT", "NOSCRIPT", "TEMPLATE"].includes(elementSafeTagName(element));\n}\nfunction isElementHiddenForAria(element) {\n  if (isElementIgnoredForAria(element))\n    return true;\n  const style = getElementComputedStyle(element);\n  const isSlot = element.nodeName === "SLOT";\n  if ((style == null ? void 0 : style.display) === "contents" && !isSlot) {\n    for (let child = element.firstChild; child; child = child.nextSibling) {\n      if (child.nodeType === 1 && !isElementHiddenForAria(child))\n        return false;\n      if (child.nodeType === 3 && isVisibleTextNode(child))\n        return false;\n    }\n    return true;\n  }\n  const isOptionInsideSelect = element.nodeName === "OPTION" && !!element.closest("select");\n  if (!isOptionInsideSelect && !isSlot && !isElementStyleVisibilityVisible(element, style))\n    return true;\n  return belongsToDisplayNoneOrAriaHiddenOrNonSlotted(element);\n}\nfunction belongsToDisplayNoneOrAriaHiddenOrNonSlotted(element) {\n  let hidden = cacheIsHidden == null ? void 0 : cacheIsHidden.get(element);\n  if (hidden === void 0) {\n    hidden = false;\n    if (element.parentElement && element.parentElement.shadowRoot && !element.assignedSlot)\n      hidden = true;\n    if (!hidden) {\n      const style = getElementComputedStyle(element);\n      hidden = !style || style.display === "none" || getAriaBoolean(element.getAttribute("aria-hidden")) === true;\n    }\n    if (!hidden) {\n      const parent = parentElementOrShadowHost(element);\n      if (parent)\n        hidden = belongsToDisplayNoneOrAriaHiddenOrNonSlotted(parent);\n    }\n    cacheIsHidden == null ? void 0 : cacheIsHidden.set(element, hidden);\n  }\n  return hidden;\n}\nfunction getIdRefs(element, ref) {\n  if (!ref)\n    return [];\n  const root = enclosingShadowRootOrDocument(element);\n  if (!root)\n    return [];\n  try {\n    const ids = ref.split(" ").filter((id) => !!id);\n    const result = [];\n    for (const id of ids) {\n      const firstElement = root.querySelector("#" + CSS.escape(id));\n      if (firstElement && !result.includes(firstElement))\n        result.push(firstElement);\n    }\n    return result;\n  } catch (e) {\n    return [];\n  }\n}\nfunction trimFlatString(s) {\n  return s.trim();\n}\nfunction asFlatString(s) {\n  return s.split("\\xA0").map((chunk) => chunk.replace(/\\r\\n/g, "\\n").replace(/[\\u200b\\u00ad]/g, "").replace(/\\s\\s*/g, " ")).join("\\xA0").trim();\n}\nfunction queryInAriaOwned(element, selector) {\n  const result = [...element.querySelectorAll(selector)];\n  for (const owned of getIdRefs(element, element.getAttribute("aria-owns"))) {\n    if (owned.matches(selector))\n      result.push(owned);\n    result.push(...owned.querySelectorAll(selector));\n  }\n  return result;\n}\nfunction getCSSContent(element, pseudo) {\n  const cache = pseudo === "::before" ? cachePseudoContentBefore : pseudo === "::after" ? cachePseudoContentAfter : cachePseudoContent;\n  if (cache == null ? void 0 : cache.has(element))\n    return cache == null ? void 0 : cache.get(element);\n  const style = getElementComputedStyle(element, pseudo);\n  let content;\n  if (style) {\n    const contentValue = style.content;\n    if (contentValue && contentValue !== "none" && contentValue !== "normal") {\n      if (style.display !== "none" && style.visibility !== "hidden") {\n        content = parseCSSContentPropertyAsString(element, contentValue, !!pseudo);\n      }\n    }\n  }\n  if (pseudo && content !== void 0) {\n    const display = (style == null ? void 0 : style.display) || "inline";\n    if (display !== "inline")\n      content = " " + content + " ";\n  }\n  if (cache)\n    cache.set(element, content);\n  return content;\n}\nfunction parseCSSContentPropertyAsString(element, content, isPseudo) {\n  if (!content || content === "none" || content === "normal") {\n    return;\n  }\n  try {\n    let tokens = tokenize(content).filter((token) => !(token instanceof WhitespaceToken));\n    const delimIndex = tokens.findIndex((token) => token instanceof DelimToken && token.value === "/");\n    if (delimIndex !== -1) {\n      tokens = tokens.slice(delimIndex + 1);\n    } else if (!isPseudo) {\n      return;\n    }\n    const accumulated = [];\n    let index = 0;\n    while (index < tokens.length) {\n      if (tokens[index] instanceof StringToken) {\n        accumulated.push(tokens[index].value);\n        index++;\n      } else if (index + 2 < tokens.length && tokens[index] instanceof FunctionToken && tokens[index].value === "attr" && tokens[index + 1] instanceof IdentToken && tokens[index + 2] instanceof CloseParenToken) {\n        const attrName = tokens[index + 1].value;\n        accumulated.push(element.getAttribute(attrName) || "");\n        index += 3;\n      } else {\n        return;\n      }\n    }\n    return accumulated.join("");\n  } catch {\n  }\n}\nfunction getAriaLabelledByElements(element) {\n  const ref = element.getAttribute("aria-labelledby");\n  if (ref === null)\n    return null;\n  const refs = getIdRefs(element, ref);\n  return refs.length ? refs : null;\n}\nfunction allowsNameFromContent(role, targetDescendant) {\n  const alwaysAllowsNameFromContent = ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"].includes(role);\n  const descendantAllowsNameFromContent = targetDescendant && ["", "caption", "code", "contentinfo", "definition", "deletion", "emphasis", "insertion", "list", "listitem", "mark", "none", "paragraph", "presentation", "region", "row", "rowgroup", "section", "strong", "subscript", "superscript", "table", "term", "time"].includes(role);\n  return alwaysAllowsNameFromContent || descendantAllowsNameFromContent;\n}\nfunction getElementAccessibleName(element, includeHidden) {\n  const cache = includeHidden ? cacheAccessibleNameHidden : cacheAccessibleName;\n  let accessibleName = cache == null ? void 0 : cache.get(element);\n  if (accessibleName === void 0) {\n    accessibleName = "";\n    const elementProhibitsNaming = ["caption", "code", "definition", "deletion", "emphasis", "generic", "insertion", "mark", "paragraph", "presentation", "strong", "subscript", "suggestion", "superscript", "term", "time"].includes(getAriaRole(element) || "");\n    if (!elementProhibitsNaming) {\n      accessibleName = asFlatString(getTextAlternativeInternal(element, {\n        includeHidden,\n        visitedElements: /* @__PURE__ */ new Set(),\n        embeddedInTargetElement: "self"\n      }));\n    }\n    cache == null ? void 0 : cache.set(element, accessibleName);\n  }\n  return accessibleName;\n}\nfunction getElementAccessibleDescription(element, includeHidden) {\n  const cache = includeHidden ? cacheAccessibleDescriptionHidden : cacheAccessibleDescription;\n  let accessibleDescription = cache == null ? void 0 : cache.get(element);\n  if (accessibleDescription === void 0) {\n    accessibleDescription = "";\n    if (element.hasAttribute("aria-describedby")) {\n      const describedBy = getIdRefs(element, element.getAttribute("aria-describedby"));\n      accessibleDescription = asFlatString(describedBy.map((ref) => getTextAlternativeInternal(ref, {\n        includeHidden,\n        visitedElements: /* @__PURE__ */ new Set(),\n        embeddedInDescribedBy: { element: ref, hidden: isElementHiddenForAria(ref) }\n      })).join(" "));\n    } else if (element.hasAttribute("aria-description")) {\n      accessibleDescription = asFlatString(element.getAttribute("aria-description") || "");\n    } else {\n      accessibleDescription = asFlatString(element.getAttribute("title") || "");\n    }\n    cache == null ? void 0 : cache.set(element, accessibleDescription);\n  }\n  return accessibleDescription;\n}\nfunction getAriaInvalid(element) {\n  const ariaInvalid = element.getAttribute("aria-invalid");\n  if (!ariaInvalid || ariaInvalid.trim() === "" || ariaInvalid.toLocaleLowerCase() === "false")\n    return "false";\n  if (ariaInvalid === "true" || ariaInvalid === "grammar" || ariaInvalid === "spelling")\n    return ariaInvalid;\n  return "true";\n}\nfunction getValidityInvalid(element) {\n  if ("validity" in element) {\n    const validity = element.validity;\n    return (validity == null ? void 0 : validity.valid) === false;\n  }\n  return false;\n}\nfunction getElementAccessibleErrorMessage(element) {\n  const cache = cacheAccessibleErrorMessage;\n  let accessibleErrorMessage = cacheAccessibleErrorMessage == null ? void 0 : cacheAccessibleErrorMessage.get(element);\n  if (accessibleErrorMessage === void 0) {\n    accessibleErrorMessage = "";\n    const isAriaInvalid = getAriaInvalid(element) !== "false";\n    const isValidityInvalid = getValidityInvalid(element);\n    if (isAriaInvalid || isValidityInvalid) {\n      const errorMessageId = element.getAttribute("aria-errormessage");\n      const errorMessages = getIdRefs(element, errorMessageId);\n      const parts = errorMessages.map((errorMessage) => asFlatString(\n        getTextAlternativeInternal(errorMessage, {\n          visitedElements: /* @__PURE__ */ new Set(),\n          embeddedInDescribedBy: { element: errorMessage, hidden: isElementHiddenForAria(errorMessage) }\n        })\n      ));\n      accessibleErrorMessage = parts.join(" ").trim();\n    }\n    cache == null ? void 0 : cache.set(element, accessibleErrorMessage);\n  }\n  return accessibleErrorMessage;\n}\nfunction getTextAlternativeInternal(element, options) {\n  var _a, _b, _c, _d;\n  if (options.visitedElements.has(element))\n    return "";\n  const childOptions = {\n    ...options,\n    embeddedInTargetElement: options.embeddedInTargetElement === "self" ? "descendant" : options.embeddedInTargetElement\n  };\n  if (!options.includeHidden) {\n    const isEmbeddedInHiddenReferenceTraversal = !!((_a = options.embeddedInLabelledBy) == null ? void 0 : _a.hidden) || !!((_b = options.embeddedInDescribedBy) == null ? void 0 : _b.hidden) || !!((_c = options.embeddedInNativeTextAlternative) == null ? void 0 : _c.hidden) || !!((_d = options.embeddedInLabel) == null ? void 0 : _d.hidden);\n    if (isElementIgnoredForAria(element) || !isEmbeddedInHiddenReferenceTraversal && isElementHiddenForAria(element)) {\n      options.visitedElements.add(element);\n      return "";\n    }\n  }\n  const labelledBy = getAriaLabelledByElements(element);\n  if (!options.embeddedInLabelledBy) {\n    const accessibleName = (labelledBy || []).map((ref) => getTextAlternativeInternal(ref, {\n      ...options,\n      embeddedInLabelledBy: { element: ref, hidden: isElementHiddenForAria(ref) },\n      embeddedInDescribedBy: void 0,\n      embeddedInTargetElement: void 0,\n      embeddedInLabel: void 0,\n      embeddedInNativeTextAlternative: void 0\n    })).join(" ");\n    if (accessibleName)\n      return accessibleName;\n  }\n  const role = getAriaRole(element) || "";\n  const tagName = elementSafeTagName(element);\n  if (!!options.embeddedInLabel || !!options.embeddedInLabelledBy || options.embeddedInTargetElement === "descendant") {\n    const isOwnLabel = [...element.labels || []].includes(element);\n    const isOwnLabelledBy = (labelledBy || []).includes(element);\n    if (!isOwnLabel && !isOwnLabelledBy) {\n      if (role === "textbox") {\n        options.visitedElements.add(element);\n        if (tagName === "INPUT" || tagName === "TEXTAREA")\n          return element.value;\n        return element.textContent || "";\n      }\n      if (["combobox", "listbox"].includes(role)) {\n        options.visitedElements.add(element);\n        let selectedOptions;\n        if (tagName === "SELECT") {\n          selectedOptions = [...element.selectedOptions];\n          if (!selectedOptions.length && element.options.length)\n            selectedOptions.push(element.options[0]);\n        } else {\n          const listbox = role === "combobox" ? queryInAriaOwned(element, "*").find((e) => getAriaRole(e) === "listbox") : element;\n          selectedOptions = listbox ? queryInAriaOwned(listbox, \'[aria-selected="true"]\').filter((e) => getAriaRole(e) === "option") : [];\n        }\n        if (!selectedOptions.length && tagName === "INPUT") {\n          return element.value;\n        }\n        return selectedOptions.map((option) => getTextAlternativeInternal(option, childOptions)).join(" ");\n      }\n      if (["progressbar", "scrollbar", "slider", "spinbutton", "meter"].includes(role)) {\n        options.visitedElements.add(element);\n        if (element.hasAttribute("aria-valuetext"))\n          return element.getAttribute("aria-valuetext") || "";\n        if (element.hasAttribute("aria-valuenow"))\n          return element.getAttribute("aria-valuenow") || "";\n        return element.getAttribute("value") || "";\n      }\n      if (["menu"].includes(role)) {\n        options.visitedElements.add(element);\n        return "";\n      }\n    }\n  }\n  const ariaLabel = element.getAttribute("aria-label") || "";\n  if (trimFlatString(ariaLabel)) {\n    options.visitedElements.add(element);\n    return ariaLabel;\n  }\n  if (!["presentation", "none"].includes(role)) {\n    if (tagName === "INPUT" && ["button", "submit", "reset"].includes(element.type)) {\n      options.visitedElements.add(element);\n      const value = element.value || "";\n      if (trimFlatString(value))\n        return value;\n      if (element.type === "submit")\n        return "Submit";\n      if (element.type === "reset")\n        return "Reset";\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (tagName === "INPUT" && element.type === "file") {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length && !options.embeddedInLabelledBy)\n        return getAccessibleNameFromAssociatedLabels(labels, options);\n      return "Choose File";\n    }\n    if (tagName === "INPUT" && element.type === "image") {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length && !options.embeddedInLabelledBy)\n        return getAccessibleNameFromAssociatedLabels(labels, options);\n      const alt = element.getAttribute("alt") || "";\n      if (trimFlatString(alt))\n        return alt;\n      const title = element.getAttribute("title") || "";\n      if (trimFlatString(title))\n        return title;\n      return "Submit";\n    }\n    if (!labelledBy && tagName === "BUTTON") {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length)\n        return getAccessibleNameFromAssociatedLabels(labels, options);\n    }\n    if (!labelledBy && tagName === "OUTPUT") {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length)\n        return getAccessibleNameFromAssociatedLabels(labels, options);\n      return element.getAttribute("title") || "";\n    }\n    if (!labelledBy && (tagName === "TEXTAREA" || tagName === "SELECT" || tagName === "INPUT")) {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length)\n        return getAccessibleNameFromAssociatedLabels(labels, options);\n      const usePlaceholder = tagName === "INPUT" && ["text", "password", "search", "tel", "email", "url"].includes(element.type) || tagName === "TEXTAREA";\n      const placeholder = element.getAttribute("placeholder") || "";\n      const title = element.getAttribute("title") || "";\n      if (!usePlaceholder || title)\n        return title;\n      return placeholder;\n    }\n    if (!labelledBy && tagName === "FIELDSET") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (elementSafeTagName(child) === "LEGEND") {\n          return getTextAlternativeInternal(child, {\n            ...childOptions,\n            embeddedInNativeTextAlternative: { element: child, hidden: isElementHiddenForAria(child) }\n          });\n        }\n      }\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (!labelledBy && tagName === "FIGURE") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (elementSafeTagName(child) === "FIGCAPTION") {\n          return getTextAlternativeInternal(child, {\n            ...childOptions,\n            embeddedInNativeTextAlternative: { element: child, hidden: isElementHiddenForAria(child) }\n          });\n        }\n      }\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (tagName === "IMG") {\n      options.visitedElements.add(element);\n      const alt = element.getAttribute("alt") || "";\n      if (trimFlatString(alt))\n        return alt;\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (tagName === "TABLE") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (elementSafeTagName(child) === "CAPTION") {\n          return getTextAlternativeInternal(child, {\n            ...childOptions,\n            embeddedInNativeTextAlternative: { element: child, hidden: isElementHiddenForAria(child) }\n          });\n        }\n      }\n      const summary = element.getAttribute("summary") || "";\n      if (summary)\n        return summary;\n    }\n    if (tagName === "AREA") {\n      options.visitedElements.add(element);\n      const alt = element.getAttribute("alt") || "";\n      if (trimFlatString(alt))\n        return alt;\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (tagName === "SVG" || element.ownerSVGElement) {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (elementSafeTagName(child) === "TITLE" && child.ownerSVGElement) {\n          return getTextAlternativeInternal(child, {\n            ...childOptions,\n            embeddedInLabelledBy: { element: child, hidden: isElementHiddenForAria(child) }\n          });\n        }\n      }\n    }\n    if (element.ownerSVGElement && tagName === "A") {\n      const title = element.getAttribute("xlink:title") || "";\n      if (trimFlatString(title)) {\n        options.visitedElements.add(element);\n        return title;\n      }\n    }\n  }\n  const shouldNameFromContentForSummary = tagName === "SUMMARY" && !["presentation", "none"].includes(role);\n  if (allowsNameFromContent(role, options.embeddedInTargetElement === "descendant") || shouldNameFromContentForSummary || !!options.embeddedInLabelledBy || !!options.embeddedInDescribedBy || !!options.embeddedInLabel || !!options.embeddedInNativeTextAlternative) {\n    options.visitedElements.add(element);\n    const accessibleName = innerAccumulatedElementText(element, childOptions);\n    const maybeTrimmedAccessibleName = options.embeddedInTargetElement === "self" ? trimFlatString(accessibleName) : accessibleName;\n    if (maybeTrimmedAccessibleName)\n      return accessibleName;\n  }\n  if (!["presentation", "none"].includes(role) || tagName === "IFRAME") {\n    options.visitedElements.add(element);\n    const title = element.getAttribute("title") || "";\n    if (trimFlatString(title))\n      return title;\n  }\n  options.visitedElements.add(element);\n  return "";\n}\nfunction innerAccumulatedElementText(element, options) {\n  const tokens = [];\n  const visit = (node, skipSlotted) => {\n    var _a;\n    if (skipSlotted && node.assignedSlot)\n      return;\n    if (node.nodeType === 1) {\n      const display = ((_a = getElementComputedStyle(node)) == null ? void 0 : _a.display) || "inline";\n      let token = getTextAlternativeInternal(node, options);\n      if (display !== "inline" || node.nodeName === "BR")\n        token = " " + token + " ";\n      tokens.push(token);\n    } else if (node.nodeType === 3) {\n      tokens.push(node.textContent || "");\n    }\n  };\n  tokens.push(getCSSContent(element, "::before") || "");\n  const content = getCSSContent(element);\n  if (content !== void 0) {\n    tokens.push(content);\n  } else {\n    const assignedNodes = element.nodeName === "SLOT" ? element.assignedNodes() : [];\n    if (assignedNodes.length) {\n      for (const child of assignedNodes)\n        visit(child, false);\n    } else {\n      for (let child = element.firstChild; child; child = child.nextSibling)\n        visit(child, true);\n      if (element.shadowRoot) {\n        for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling)\n          visit(child, true);\n      }\n      for (const owned of getIdRefs(element, element.getAttribute("aria-owns")))\n        visit(owned, true);\n    }\n  }\n  tokens.push(getCSSContent(element, "::after") || "");\n  return tokens.join("");\n}\nvar kAriaSelectedRoles = ["gridcell", "option", "row", "tab", "rowheader", "columnheader", "treeitem"];\nfunction getAriaSelected(element) {\n  if (elementSafeTagName(element) === "OPTION")\n    return element.selected;\n  if (kAriaSelectedRoles.includes(getAriaRole(element) || ""))\n    return getAriaBoolean(element.getAttribute("aria-selected")) === true;\n  return false;\n}\nvar kAriaCheckedRoles = ["checkbox", "menuitemcheckbox", "option", "radio", "switch", "menuitemradio", "treeitem"];\nfunction getAriaChecked(element) {\n  const result = getChecked(element, true);\n  return result === "error" ? false : result;\n}\nfunction getCheckedAllowMixed(element) {\n  return getChecked(element, true);\n}\nfunction getCheckedWithoutMixed(element) {\n  const result = getChecked(element, false);\n  return result;\n}\nfunction getChecked(element, allowMixed) {\n  const tagName = elementSafeTagName(element);\n  if (allowMixed && tagName === "INPUT" && element.indeterminate)\n    return "mixed";\n  if (tagName === "INPUT" && ["checkbox", "radio"].includes(element.type))\n    return element.checked;\n  if (kAriaCheckedRoles.includes(getAriaRole(element) || "")) {\n    const checked = element.getAttribute("aria-checked");\n    if (checked === "true")\n      return true;\n    if (allowMixed && checked === "mixed")\n      return "mixed";\n    return false;\n  }\n  return "error";\n}\nvar kAriaReadonlyRoles = ["checkbox", "combobox", "grid", "gridcell", "listbox", "radiogroup", "slider", "spinbutton", "textbox", "columnheader", "rowheader", "searchbox", "switch", "treegrid"];\nfunction getReadonly(element) {\n  const tagName = elementSafeTagName(element);\n  if (["INPUT", "TEXTAREA", "SELECT"].includes(tagName))\n    return element.hasAttribute("readonly");\n  if (kAriaReadonlyRoles.includes(getAriaRole(element) || ""))\n    return element.getAttribute("aria-readonly") === "true";\n  if (element.isContentEditable)\n    return false;\n  return "error";\n}\nvar kAriaPressedRoles = ["button"];\nfunction getAriaPressed(element) {\n  if (kAriaPressedRoles.includes(getAriaRole(element) || "")) {\n    const pressed = element.getAttribute("aria-pressed");\n    if (pressed === "true")\n      return true;\n    if (pressed === "mixed")\n      return "mixed";\n  }\n  return false;\n}\nvar kAriaExpandedRoles = ["application", "button", "checkbox", "combobox", "gridcell", "link", "listbox", "menuitem", "row", "rowheader", "tab", "treeitem", "columnheader", "menuitemcheckbox", "menuitemradio", "rowheader", "switch"];\nfunction getAriaExpanded(element) {\n  if (elementSafeTagName(element) === "DETAILS")\n    return element.open;\n  if (kAriaExpandedRoles.includes(getAriaRole(element) || "")) {\n    const expanded = element.getAttribute("aria-expanded");\n    if (expanded === null)\n      return void 0;\n    if (expanded === "true")\n      return true;\n    return false;\n  }\n  return void 0;\n}\nvar kAriaLevelRoles = ["heading", "listitem", "row", "treeitem"];\nfunction getAriaLevel(element) {\n  const native = { "H1": 1, "H2": 2, "H3": 3, "H4": 4, "H5": 5, "H6": 6 }[elementSafeTagName(element)];\n  if (native)\n    return native;\n  if (kAriaLevelRoles.includes(getAriaRole(element) || "")) {\n    const attr = element.getAttribute("aria-level");\n    const value = attr === null ? Number.NaN : Number(attr);\n    if (Number.isInteger(value) && value >= 1)\n      return value;\n  }\n  return 0;\n}\nvar kAriaDisabledRoles = ["application", "button", "composite", "gridcell", "group", "input", "link", "menuitem", "scrollbar", "separator", "tab", "checkbox", "columnheader", "combobox", "grid", "listbox", "menu", "menubar", "menuitemcheckbox", "menuitemradio", "option", "radio", "radiogroup", "row", "rowheader", "searchbox", "select", "slider", "spinbutton", "switch", "tablist", "textbox", "toolbar", "tree", "treegrid", "treeitem"];\nfunction getAriaDisabled(element) {\n  return isNativelyDisabled(element) || hasExplicitAriaDisabled(element);\n}\nfunction isNativelyDisabled(element) {\n  const isNativeFormControl = ["BUTTON", "INPUT", "SELECT", "TEXTAREA", "OPTION", "OPTGROUP"].includes(elementSafeTagName(element));\n  return isNativeFormControl && (element.hasAttribute("disabled") || belongsToDisabledOptGroup(element) || belongsToDisabledFieldSet(element));\n}\nfunction belongsToDisabledOptGroup(element) {\n  return elementSafeTagName(element) === "OPTION" && !!element.closest("OPTGROUP[DISABLED]");\n}\nfunction belongsToDisabledFieldSet(element) {\n  const fieldSetElement = element == null ? void 0 : element.closest("FIELDSET[DISABLED]");\n  if (!fieldSetElement)\n    return false;\n  const legendElement = fieldSetElement.querySelector(":scope > LEGEND");\n  return !legendElement || !legendElement.contains(element);\n}\nfunction hasExplicitAriaDisabled(element, isAncestor = false) {\n  if (!element)\n    return false;\n  if (isAncestor || kAriaDisabledRoles.includes(getAriaRole(element) || "")) {\n    const attribute = (element.getAttribute("aria-disabled") || "").toLowerCase();\n    if (attribute === "true")\n      return true;\n    if (attribute === "false")\n      return false;\n    return hasExplicitAriaDisabled(parentElementOrShadowHost(element), true);\n  }\n  return false;\n}\nfunction getAccessibleNameFromAssociatedLabels(labels, options) {\n  return [...labels].map((label) => getTextAlternativeInternal(label, {\n    ...options,\n    embeddedInLabel: { element: label, hidden: isElementHiddenForAria(label) },\n    embeddedInNativeTextAlternative: void 0,\n    embeddedInLabelledBy: void 0,\n    embeddedInDescribedBy: void 0,\n    embeddedInTargetElement: void 0\n  })).filter((accessibleName) => !!accessibleName).join(" ");\n}\nfunction receivesPointerEvents(element) {\n  const cache = cachePointerEvents;\n  let e = element;\n  let result;\n  const parents = [];\n  for (; e; e = parentElementOrShadowHost(e)) {\n    const cached = cache.get(e);\n    if (cached !== void 0) {\n      result = cached;\n      break;\n    }\n    parents.push(e);\n    const style = getElementComputedStyle(e);\n    if (!style) {\n      result = true;\n      break;\n    }\n    const value = style.pointerEvents;\n    if (value) {\n      result = value !== "none";\n      break;\n    }\n  }\n  if (result === void 0)\n    result = true;\n  for (const parent of parents)\n    cache.set(parent, result);\n  return result;\n}\nvar cacheAccessibleName;\nvar cacheAccessibleNameHidden;\nvar cacheAccessibleDescription;\nvar cacheAccessibleDescriptionHidden;\nvar cacheAccessibleErrorMessage;\nvar cacheIsHidden;\nvar cachePseudoContent;\nvar cachePseudoContentBefore;\nvar cachePseudoContentAfter;\nvar cachePointerEvents;\nvar cachesCounter2 = 0;\nfunction beginAriaCaches() {\n  beginDOMCaches();\n  ++cachesCounter2;\n  cacheAccessibleName != null ? cacheAccessibleName : cacheAccessibleName = /* @__PURE__ */ new Map();\n  cacheAccessibleNameHidden != null ? cacheAccessibleNameHidden : cacheAccessibleNameHidden = /* @__PURE__ */ new Map();\n  cacheAccessibleDescription != null ? cacheAccessibleDescription : cacheAccessibleDescription = /* @__PURE__ */ new Map();\n  cacheAccessibleDescriptionHidden != null ? cacheAccessibleDescriptionHidden : cacheAccessibleDescriptionHidden = /* @__PURE__ */ new Map();\n  cacheAccessibleErrorMessage != null ? cacheAccessibleErrorMessage : cacheAccessibleErrorMessage = /* @__PURE__ */ new Map();\n  cacheIsHidden != null ? cacheIsHidden : cacheIsHidden = /* @__PURE__ */ new Map();\n  cachePseudoContent != null ? cachePseudoContent : cachePseudoContent = /* @__PURE__ */ new Map();\n  cachePseudoContentBefore != null ? cachePseudoContentBefore : cachePseudoContentBefore = /* @__PURE__ */ new Map();\n  cachePseudoContentAfter != null ? cachePseudoContentAfter : cachePseudoContentAfter = /* @__PURE__ */ new Map();\n  cachePointerEvents != null ? cachePointerEvents : cachePointerEvents = /* @__PURE__ */ new Map();\n}\nfunction endAriaCaches() {\n  if (!--cachesCounter2) {\n    cacheAccessibleName = void 0;\n    cacheAccessibleNameHidden = void 0;\n    cacheAccessibleDescription = void 0;\n    cacheAccessibleDescriptionHidden = void 0;\n    cacheAccessibleErrorMessage = void 0;\n    cacheIsHidden = void 0;\n    cachePseudoContent = void 0;\n    cachePseudoContentBefore = void 0;\n    cachePseudoContentAfter = void 0;\n    cachePointerEvents = void 0;\n  }\n  endDOMCaches();\n}\nvar inputTypeToRole = {\n  "button": "button",\n  "checkbox": "checkbox",\n  "image": "button",\n  "number": "spinbutton",\n  "radio": "radio",\n  "range": "slider",\n  "reset": "button",\n  "submit": "button"\n};\n\n// packages/injected/src/ariaSnapshot.ts\nvar lastRef = 0;\nfunction toInternalOptions(options) {\n  if (options.mode === "ai") {\n    return {\n      visibility: "ariaOrVisible",\n      refs: "interactable",\n      refPrefix: options.refPrefix,\n      includeGenericRole: true,\n      renderActive: !options.doNotRenderActive,\n      renderCursorPointer: true\n    };\n  }\n  if (options.mode === "autoexpect") {\n    return { visibility: "ariaAndVisible", refs: "none" };\n  }\n  if (options.mode === "codegen") {\n    return { visibility: "aria", refs: "none", renderStringsAsRegex: true };\n  }\n  return { visibility: "aria", refs: "none" };\n}\nfunction generateAriaTree(rootElement, publicOptions) {\n  const options = toInternalOptions(publicOptions);\n  const visited = /* @__PURE__ */ new Set();\n  const snapshot = {\n    root: { role: "fragment", name: "", children: [], props: {}, box: computeBox(rootElement), receivesPointerEvents: true },\n    elements: /* @__PURE__ */ new Map(),\n    refs: /* @__PURE__ */ new Map(),\n    iframeRefs: []\n  };\n  setAriaNodeElement(snapshot.root, rootElement);\n  const visit = (ariaNode, node, parentElementVisible) => {\n    if (visited.has(node))\n      return;\n    visited.add(node);\n    if (node.nodeType === Node.TEXT_NODE && node.nodeValue) {\n      if (!parentElementVisible)\n        return;\n      const text = node.nodeValue;\n      if (ariaNode.role !== "textbox" && text)\n        ariaNode.children.push(node.nodeValue || "");\n      return;\n    }\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      return;\n    const element = node;\n    const isElementVisibleForAria = !isElementHiddenForAria(element);\n    let visible = isElementVisibleForAria;\n    if (options.visibility === "ariaOrVisible")\n      visible = isElementVisibleForAria || isElementVisible(element);\n    if (options.visibility === "ariaAndVisible")\n      visible = isElementVisibleForAria && isElementVisible(element);\n    if (options.visibility === "aria" && !visible)\n      return;\n    const ariaChildren = [];\n    if (element.hasAttribute("aria-owns")) {\n      const ids = element.getAttribute("aria-owns").split(/\\s+/);\n      for (const id of ids) {\n        const ownedElement = rootElement.ownerDocument.getElementById(id);\n        if (ownedElement)\n          ariaChildren.push(ownedElement);\n      }\n    }\n    const childAriaNode = visible ? toAriaNode(element, options) : null;\n    if (childAriaNode) {\n      if (childAriaNode.ref) {\n        snapshot.elements.set(childAriaNode.ref, element);\n        snapshot.refs.set(element, childAriaNode.ref);\n        if (childAriaNode.role === "iframe")\n          snapshot.iframeRefs.push(childAriaNode.ref);\n      }\n      ariaNode.children.push(childAriaNode);\n    }\n    processElement(childAriaNode || ariaNode, element, ariaChildren, visible);\n  };\n  function processElement(ariaNode, element, ariaChildren, parentElementVisible) {\n    var _a;\n    const display = ((_a = getElementComputedStyle(element)) == null ? void 0 : _a.display) || "inline";\n    const treatAsBlock = display !== "inline" || element.nodeName === "BR" ? " " : "";\n    if (treatAsBlock)\n      ariaNode.children.push(treatAsBlock);\n    ariaNode.children.push(getCSSContent(element, "::before") || "");\n    const assignedNodes = element.nodeName === "SLOT" ? element.assignedNodes() : [];\n    if (assignedNodes.length) {\n      for (const child of assignedNodes)\n        visit(ariaNode, child, parentElementVisible);\n    } else {\n      for (let child = element.firstChild; child; child = child.nextSibling) {\n        if (!child.assignedSlot)\n          visit(ariaNode, child, parentElementVisible);\n      }\n      if (element.shadowRoot) {\n        for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling)\n          visit(ariaNode, child, parentElementVisible);\n      }\n    }\n    for (const child of ariaChildren)\n      visit(ariaNode, child, parentElementVisible);\n    ariaNode.children.push(getCSSContent(element, "::after") || "");\n    if (treatAsBlock)\n      ariaNode.children.push(treatAsBlock);\n    if (ariaNode.children.length === 1 && ariaNode.name === ariaNode.children[0])\n      ariaNode.children = [];\n    if (ariaNode.role === "link" && element.hasAttribute("href")) {\n      const href = element.getAttribute("href");\n      ariaNode.props["url"] = href;\n    }\n    if (ariaNode.role === "textbox" && element.hasAttribute("placeholder") && element.getAttribute("placeholder") !== ariaNode.name) {\n      const placeholder = element.getAttribute("placeholder");\n      ariaNode.props["placeholder"] = placeholder;\n    }\n  }\n  beginAriaCaches();\n  try {\n    visit(snapshot.root, rootElement, true);\n  } finally {\n    endAriaCaches();\n  }\n  normalizeStringChildren(snapshot.root);\n  normalizeGenericRoles(snapshot.root);\n  return snapshot;\n}\nfunction computeAriaRef(ariaNode, options) {\n  var _a;\n  if (options.refs === "none")\n    return;\n  if (options.refs === "interactable" && (!ariaNode.box.visible || !ariaNode.receivesPointerEvents))\n    return;\n  const element = ariaNodeElement(ariaNode);\n  let ariaRef = element._ariaRef;\n  if (!ariaRef || ariaRef.role !== ariaNode.role || ariaRef.name !== ariaNode.name) {\n    ariaRef = { role: ariaNode.role, name: ariaNode.name, ref: ((_a = options.refPrefix) != null ? _a : "") + "e" + ++lastRef };\n    element._ariaRef = ariaRef;\n  }\n  ariaNode.ref = ariaRef.ref;\n}\nfunction toAriaNode(element, options) {\n  var _a;\n  const active = element.ownerDocument.activeElement === element;\n  if (element.nodeName === "IFRAME") {\n    const ariaNode = {\n      role: "iframe",\n      name: "",\n      children: [],\n      props: {},\n      box: computeBox(element),\n      receivesPointerEvents: true,\n      active\n    };\n    setAriaNodeElement(ariaNode, element);\n    computeAriaRef(ariaNode, options);\n    return ariaNode;\n  }\n  const defaultRole = options.includeGenericRole ? "generic" : null;\n  const role = (_a = getAriaRole(element)) != null ? _a : defaultRole;\n  if (!role || role === "presentation" || role === "none")\n    return null;\n  const name = normalizeWhiteSpace(getElementAccessibleName(element, false) || "");\n  const receivesPointerEvents2 = receivesPointerEvents(element);\n  const box = computeBox(element);\n  if (role === "generic" && box.inline && element.childNodes.length === 1 && element.childNodes[0].nodeType === Node.TEXT_NODE)\n    return null;\n  const result = {\n    role,\n    name,\n    children: [],\n    props: {},\n    box,\n    receivesPointerEvents: receivesPointerEvents2,\n    active\n  };\n  setAriaNodeElement(result, element);\n  computeAriaRef(result, options);\n  if (kAriaCheckedRoles.includes(role))\n    result.checked = getAriaChecked(element);\n  if (kAriaDisabledRoles.includes(role))\n    result.disabled = getAriaDisabled(element);\n  if (kAriaExpandedRoles.includes(role))\n    result.expanded = getAriaExpanded(element);\n  if (kAriaLevelRoles.includes(role))\n    result.level = getAriaLevel(element);\n  if (kAriaPressedRoles.includes(role))\n    result.pressed = getAriaPressed(element);\n  if (kAriaSelectedRoles.includes(role))\n    result.selected = getAriaSelected(element);\n  if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n    if (element.type !== "checkbox" && element.type !== "radio" && element.type !== "file")\n      result.children = [element.value];\n  }\n  return result;\n}\nfunction normalizeGenericRoles(node) {\n  const normalizeChildren = (node2) => {\n    const result = [];\n    for (const child of node2.children || []) {\n      if (typeof child === "string") {\n        result.push(child);\n        continue;\n      }\n      const normalized = normalizeChildren(child);\n      result.push(...normalized);\n    }\n    const removeSelf = node2.role === "generic" && !node2.name && result.length <= 1 && result.every((c) => typeof c !== "string" && !!c.ref);\n    if (removeSelf)\n      return result;\n    node2.children = result;\n    return [node2];\n  };\n  normalizeChildren(node);\n}\nfunction normalizeStringChildren(rootA11yNode) {\n  const flushChildren = (buffer, normalizedChildren) => {\n    if (!buffer.length)\n      return;\n    const text = normalizeWhiteSpace(buffer.join(""));\n    if (text)\n      normalizedChildren.push(text);\n    buffer.length = 0;\n  };\n  const visit = (ariaNode) => {\n    const normalizedChildren = [];\n    const buffer = [];\n    for (const child of ariaNode.children || []) {\n      if (typeof child === "string") {\n        buffer.push(child);\n      } else {\n        flushChildren(buffer, normalizedChildren);\n        visit(child);\n        normalizedChildren.push(child);\n      }\n    }\n    flushChildren(buffer, normalizedChildren);\n    ariaNode.children = normalizedChildren.length ? normalizedChildren : [];\n    if (ariaNode.children.length === 1 && ariaNode.children[0] === ariaNode.name)\n      ariaNode.children = [];\n  };\n  visit(rootA11yNode);\n}\nfunction matchesStringOrRegex(text, template) {\n  if (!template)\n    return true;\n  if (!text)\n    return false;\n  if (typeof template === "string")\n    return text === template;\n  return !!text.match(new RegExp(template.pattern));\n}\nfunction matchesTextValue(text, template) {\n  if (!(template == null ? void 0 : template.normalized))\n    return true;\n  if (!text)\n    return false;\n  if (text === template.normalized)\n    return true;\n  if (text === template.raw)\n    return true;\n  const regex = cachedRegex(template);\n  if (regex)\n    return !!text.match(regex);\n  return false;\n}\nvar cachedRegexSymbol = Symbol("cachedRegex");\nfunction cachedRegex(template) {\n  if (template[cachedRegexSymbol] !== void 0)\n    return template[cachedRegexSymbol];\n  const { raw } = template;\n  const canBeRegex = raw.startsWith("/") && raw.endsWith("/") && raw.length > 1;\n  let regex;\n  try {\n    regex = canBeRegex ? new RegExp(raw.slice(1, -1)) : null;\n  } catch (e) {\n    regex = null;\n  }\n  template[cachedRegexSymbol] = regex;\n  return regex;\n}\nfunction matchesExpectAriaTemplate(rootElement, template) {\n  const snapshot = generateAriaTree(rootElement, { mode: "expect" });\n  const matches = matchesNodeDeep(snapshot.root, template, false, false);\n  return {\n    matches,\n    received: {\n      raw: renderAriaTree(snapshot, { mode: "expect" }),\n      regex: renderAriaTree(snapshot, { mode: "codegen" })\n    }\n  };\n}\nfunction getAllElementsMatchingExpectAriaTemplate(rootElement, template) {\n  const root = generateAriaTree(rootElement, { mode: "expect" }).root;\n  const matches = matchesNodeDeep(root, template, true, false);\n  return matches.map((n) => ariaNodeElement(n));\n}\nfunction matchesNode(node, template, isDeepEqual) {\n  var _a;\n  if (typeof node === "string" && template.kind === "text")\n    return matchesTextValue(node, template.text);\n  if (node === null || typeof node !== "object" || template.kind !== "role")\n    return false;\n  if (template.role !== "fragment" && template.role !== node.role)\n    return false;\n  if (template.checked !== void 0 && template.checked !== node.checked)\n    return false;\n  if (template.disabled !== void 0 && template.disabled !== node.disabled)\n    return false;\n  if (template.expanded !== void 0 && template.expanded !== node.expanded)\n    return false;\n  if (template.level !== void 0 && template.level !== node.level)\n    return false;\n  if (template.pressed !== void 0 && template.pressed !== node.pressed)\n    return false;\n  if (template.selected !== void 0 && template.selected !== node.selected)\n    return false;\n  if (!matchesStringOrRegex(node.name, template.name))\n    return false;\n  if (!matchesTextValue(node.props.url, (_a = template.props) == null ? void 0 : _a.url))\n    return false;\n  if (template.containerMode === "contain")\n    return containsList(node.children || [], template.children || []);\n  if (template.containerMode === "equal")\n    return listEqual(node.children || [], template.children || [], false);\n  if (template.containerMode === "deep-equal" || isDeepEqual)\n    return listEqual(node.children || [], template.children || [], true);\n  return containsList(node.children || [], template.children || []);\n}\nfunction listEqual(children, template, isDeepEqual) {\n  if (template.length !== children.length)\n    return false;\n  for (let i = 0; i < template.length; ++i) {\n    if (!matchesNode(children[i], template[i], isDeepEqual))\n      return false;\n  }\n  return true;\n}\nfunction containsList(children, template) {\n  if (template.length > children.length)\n    return false;\n  const cc = children.slice();\n  const tt = template.slice();\n  for (const t of tt) {\n    let c = cc.shift();\n    while (c) {\n      if (matchesNode(c, t, false))\n        break;\n      c = cc.shift();\n    }\n    if (!c)\n      return false;\n  }\n  return true;\n}\nfunction matchesNodeDeep(root, template, collectAll, isDeepEqual) {\n  const results = [];\n  const visit = (node, parent) => {\n    if (matchesNode(node, template, isDeepEqual)) {\n      const result = typeof node === "string" ? parent : node;\n      if (result)\n        results.push(result);\n      return !collectAll;\n    }\n    if (typeof node === "string")\n      return false;\n    for (const child of node.children || []) {\n      if (visit(child, node))\n        return true;\n    }\n    return false;\n  };\n  visit(root, null);\n  return results;\n}\nfunction buildByRefMap(root, map = /* @__PURE__ */ new Map()) {\n  if (root == null ? void 0 : root.ref)\n    map.set(root.ref, root);\n  for (const child of (root == null ? void 0 : root.children) || []) {\n    if (typeof child !== "string")\n      buildByRefMap(child, map);\n  }\n  return map;\n}\nfunction compareSnapshots(ariaSnapshot, previousSnapshot) {\n  var _a;\n  const previousByRef = buildByRefMap(previousSnapshot == null ? void 0 : previousSnapshot.root);\n  const result = /* @__PURE__ */ new Map();\n  const visit = (ariaNode, previousNode) => {\n    let same = ariaNode.children.length === (previousNode == null ? void 0 : previousNode.children.length) && ariaNodesEqual(ariaNode, previousNode);\n    let canBeSkipped = same;\n    for (let childIndex = 0; childIndex < ariaNode.children.length; childIndex++) {\n      const child = ariaNode.children[childIndex];\n      const previousChild = previousNode == null ? void 0 : previousNode.children[childIndex];\n      if (typeof child === "string") {\n        same && (same = child === previousChild);\n        canBeSkipped && (canBeSkipped = child === previousChild);\n      } else {\n        let previous = typeof previousChild !== "string" ? previousChild : void 0;\n        if (child.ref)\n          previous = previousByRef.get(child.ref);\n        const sameChild = visit(child, previous);\n        if (!previous || !sameChild && !child.ref || previous !== previousChild)\n          canBeSkipped = false;\n        same && (same = sameChild && previous === previousChild);\n      }\n    }\n    result.set(ariaNode, same ? "same" : canBeSkipped ? "skip" : "changed");\n    return same;\n  };\n  visit(ariaSnapshot.root, previousByRef.get((_a = previousSnapshot == null ? void 0 : previousSnapshot.root) == null ? void 0 : _a.ref));\n  return result;\n}\nfunction filterSnapshotDiff(nodes, statusMap) {\n  const result = [];\n  const visit = (ariaNode) => {\n    const status = statusMap.get(ariaNode);\n    if (status === "same") {\n    } else if (status === "skip") {\n      for (const child of ariaNode.children) {\n        if (typeof child !== "string")\n          visit(child);\n      }\n    } else {\n      result.push(ariaNode);\n    }\n  };\n  for (const node of nodes) {\n    if (typeof node === "string")\n      result.push(node);\n    else\n      visit(node);\n  }\n  return result;\n}\nfunction renderAriaTree(ariaSnapshot, publicOptions, previousSnapshot) {\n  const options = toInternalOptions(publicOptions);\n  const lines = [];\n  const includeText = options.renderStringsAsRegex ? textContributesInfo : () => true;\n  const renderString = options.renderStringsAsRegex ? convertToBestGuessRegex : (str) => str;\n  let nodesToRender = ariaSnapshot.root.role === "fragment" ? ariaSnapshot.root.children : [ariaSnapshot.root];\n  const statusMap = compareSnapshots(ariaSnapshot, previousSnapshot);\n  if (previousSnapshot)\n    nodesToRender = filterSnapshotDiff(nodesToRender, statusMap);\n  const visitText = (text, indent) => {\n    const escaped = yamlEscapeValueIfNeeded(renderString(text));\n    if (escaped)\n      lines.push(indent + "- text: " + escaped);\n  };\n  const createKey = (ariaNode, renderCursorPointer) => {\n    let key = ariaNode.role;\n    if (ariaNode.name && ariaNode.name.length <= 900) {\n      const name = renderString(ariaNode.name);\n      if (name) {\n        const stringifiedName = name.startsWith("/") && name.endsWith("/") ? name : JSON.stringify(name);\n        key += " " + stringifiedName;\n      }\n    }\n    if (ariaNode.checked === "mixed")\n      key += ` [checked=mixed]`;\n    if (ariaNode.checked === true)\n      key += ` [checked]`;\n    if (ariaNode.disabled)\n      key += ` [disabled]`;\n    if (ariaNode.expanded)\n      key += ` [expanded]`;\n    if (ariaNode.active && options.renderActive)\n      key += ` [active]`;\n    if (ariaNode.level)\n      key += ` [level=${ariaNode.level}]`;\n    if (ariaNode.pressed === "mixed")\n      key += ` [pressed=mixed]`;\n    if (ariaNode.pressed === true)\n      key += ` [pressed]`;\n    if (ariaNode.selected === true)\n      key += ` [selected]`;\n    if (ariaNode.ref) {\n      key += ` [ref=${ariaNode.ref}]`;\n      if (renderCursorPointer && hasPointerCursor(ariaNode))\n        key += " [cursor=pointer]";\n    }\n    return key;\n  };\n  const getSingleInlinedTextChild = (ariaNode) => {\n    return (ariaNode == null ? void 0 : ariaNode.children.length) === 1 && typeof ariaNode.children[0] === "string" && !Object.keys(ariaNode.props).length ? ariaNode.children[0] : void 0;\n  };\n  const visit = (ariaNode, indent, renderCursorPointer) => {\n    if (statusMap.get(ariaNode) === "same" && ariaNode.ref) {\n      lines.push(indent + `- ref=${ariaNode.ref} [unchanged]`);\n      return;\n    }\n    const isDiffRoot = !!previousSnapshot && !indent;\n    const escapedKey = indent + "- " + (isDiffRoot ? "<changed> " : "") + yamlEscapeKeyIfNeeded(createKey(ariaNode, renderCursorPointer));\n    const singleInlinedTextChild = getSingleInlinedTextChild(ariaNode);\n    if (!ariaNode.children.length && !Object.keys(ariaNode.props).length) {\n      lines.push(escapedKey);\n    } else if (singleInlinedTextChild !== void 0) {\n      const shouldInclude = includeText(ariaNode, singleInlinedTextChild);\n      if (shouldInclude)\n        lines.push(escapedKey + ": " + yamlEscapeValueIfNeeded(renderString(singleInlinedTextChild)));\n      else\n        lines.push(escapedKey);\n    } else {\n      lines.push(escapedKey + ":");\n      for (const [name, value] of Object.entries(ariaNode.props))\n        lines.push(indent + "  - /" + name + ": " + yamlEscapeValueIfNeeded(value));\n      const childIndent = indent + "  ";\n      const inCursorPointer = !!ariaNode.ref && renderCursorPointer && hasPointerCursor(ariaNode);\n      for (const child of ariaNode.children) {\n        if (typeof child === "string")\n          visitText(includeText(ariaNode, child) ? child : "", childIndent);\n        else\n          visit(child, childIndent, renderCursorPointer && !inCursorPointer);\n      }\n    }\n  };\n  for (const nodeToRender of nodesToRender) {\n    if (typeof nodeToRender === "string")\n      visitText(nodeToRender, "");\n    else\n      visit(nodeToRender, "", !!options.renderCursorPointer);\n  }\n  return lines.join("\\n");\n}\nfunction convertToBestGuessRegex(text) {\n  const dynamicContent = [\n    // 2mb\n    { regex: /\\b[\\d,.]+[bkmBKM]+\\b/, replacement: "[\\\\d,.]+[bkmBKM]+" },\n    // 2ms, 20s\n    { regex: /\\b\\d+[hmsp]+\\b/, replacement: "\\\\d+[hmsp]+" },\n    { regex: /\\b[\\d,.]+[hmsp]+\\b/, replacement: "[\\\\d,.]+[hmsp]+" },\n    // Do not replace single digits with regex by default.\n    // 2+ digits: [Issue 22, 22.3, 2.33, 2,333]\n    { regex: /\\b\\d+,\\d+\\b/, replacement: "\\\\d+,\\\\d+" },\n    { regex: /\\b\\d+\\.\\d{2,}\\b/, replacement: "\\\\d+\\\\.\\\\d+" },\n    { regex: /\\b\\d{2,}\\.\\d+\\b/, replacement: "\\\\d+\\\\.\\\\d+" },\n    { regex: /\\b\\d{2,}\\b/, replacement: "\\\\d+" }\n  ];\n  let pattern = "";\n  let lastIndex = 0;\n  const combinedRegex = new RegExp(dynamicContent.map((r) => "(" + r.regex.source + ")").join("|"), "g");\n  text.replace(combinedRegex, (match, ...args) => {\n    const offset = args[args.length - 2];\n    const groups = args.slice(0, -2);\n    pattern += escapeRegExp(text.slice(lastIndex, offset));\n    for (let i = 0; i < groups.length; i++) {\n      if (groups[i]) {\n        const { replacement } = dynamicContent[i];\n        pattern += replacement;\n        break;\n      }\n    }\n    lastIndex = offset + match.length;\n    return match;\n  });\n  if (!pattern)\n    return text;\n  pattern += escapeRegExp(text.slice(lastIndex));\n  return String(new RegExp(pattern));\n}\nfunction textContributesInfo(node, text) {\n  if (!text.length)\n    return false;\n  if (!node.name)\n    return true;\n  if (node.name.length > text.length)\n    return false;\n  const substr = text.length <= 200 && node.name.length <= 200 ? longestCommonSubstring(text, node.name) : "";\n  let filtered = text;\n  while (substr && filtered.includes(substr))\n    filtered = filtered.replace(substr, "");\n  return filtered.trim().length / text.length > 0.1;\n}\nvar elementSymbol = Symbol("element");\nfunction ariaNodeElement(ariaNode) {\n  return ariaNode[elementSymbol];\n}\nfunction setAriaNodeElement(ariaNode, element) {\n  ariaNode[elementSymbol] = element;\n}\nfunction findNewElement(from, to) {\n  const node = findNewNode(from, to);\n  return node ? ariaNodeElement(node) : void 0;\n}\n\n// packages/injected/src/highlight.css?inline\nvar highlight_default = ":host{font-size:13px;font-family:system-ui,Ubuntu,Droid Sans,sans-serif;color:#333}svg{position:absolute;height:0}x-pw-tooltip{backdrop-filter:blur(5px);background-color:#fff;border-radius:6px;box-shadow:0 .5rem 1.2rem #0000004d;display:none;font-size:12.8px;font-weight:400;left:0;line-height:1.5;max-width:600px;position:absolute;top:0;padding:0;flex-direction:column;overflow:hidden}x-pw-tooltip-line{display:flex;max-width:600px;padding:6px;user-select:none;cursor:pointer}x-pw-tooltip-footer{display:flex;max-width:600px;padding:6px;user-select:none;color:#777}x-pw-dialog{background-color:#fff;pointer-events:auto;border-radius:6px;box-shadow:0 .5rem 1.2rem #0000004d;display:flex;flex-direction:column;position:absolute;z-index:10;font-size:13px}x-pw-dialog:not(.autosize){width:400px;height:150px}x-pw-dialog-body{display:flex;flex-direction:column;flex:auto}x-pw-dialog-body label{margin:5px 8px;display:flex;flex-direction:row;align-items:center}x-pw-highlight{position:absolute;top:0;left:0;width:0;height:0}x-pw-action-point{position:absolute;width:20px;height:20px;background:red;border-radius:10px;margin:-10px 0 0 -10px;z-index:2}x-pw-separator{height:1px;margin:6px 9px;background:#949494e5}x-pw-tool-gripper{height:28px;width:24px;margin:2px 0;cursor:grab}x-pw-tool-gripper:active{cursor:grabbing}x-pw-tool-gripper>x-div{width:16px;height:16px;margin:6px 4px;clip-path:url(#icon-gripper);background-color:#555}x-pw-tools-list>label{display:flex;align-items:center;margin:0 10px;user-select:none}x-pw-tools-list{display:flex;width:100%;border-bottom:1px solid #dddddd}x-pw-tool-item{pointer-events:auto;height:28px;width:28px;border-radius:3px}x-pw-tool-item:not(.disabled){cursor:pointer}x-pw-tool-item:not(.disabled):hover{background-color:#dbdbdb}x-pw-tool-item.toggled{background-color:#8acae480}x-pw-tool-item.toggled:not(.disabled):hover{background-color:#8acae4c4}x-pw-tool-item>x-div{width:16px;height:16px;margin:6px;background-color:#3a3a3a}x-pw-tool-item.disabled>x-div{background-color:#61616180;cursor:default}x-pw-tool-item.record.toggled{background-color:transparent}x-pw-tool-item.record.toggled:not(.disabled):hover{background-color:#dbdbdb}x-pw-tool-item.record.toggled>x-div{background-color:#a1260d}x-pw-tool-item.record.disabled.toggled>x-div{opacity:.8}x-pw-tool-item.accept>x-div{background-color:#388a34}x-pw-tool-item.record>x-div{clip-path:url(#icon-circle-large-filled)}x-pw-tool-item.record.toggled>x-div{clip-path:url(#icon-stop-circle)}x-pw-tool-item.pick-locator>x-div{clip-path:url(#icon-inspect)}x-pw-tool-item.text>x-div{clip-path:url(#icon-whole-word)}x-pw-tool-item.visibility>x-div{clip-path:url(#icon-eye)}x-pw-tool-item.value>x-div{clip-path:url(#icon-symbol-constant)}x-pw-tool-item.snapshot>x-div{clip-path:url(#icon-gist)}x-pw-tool-item.accept>x-div{clip-path:url(#icon-check)}x-pw-tool-item.cancel>x-div{clip-path:url(#icon-close)}x-pw-tool-item.succeeded>x-div{clip-path:url(#icon-pass);background-color:#388a34!important}x-pw-overlay{position:absolute;top:0;max-width:min-content;z-index:2147483647;background:transparent;pointer-events:auto}x-pw-overlay x-pw-tools-list{background-color:#fffd;box-shadow:#0000001a 0 5px 5px;border-radius:3px;border-bottom:none}x-pw-overlay x-pw-tool-item{margin:2px}textarea.text-editor{font-family:system-ui,Ubuntu,Droid Sans,sans-serif;flex:auto;border:none;margin:6px 10px;color:#333;outline:1px solid transparent!important;resize:none;padding:0;font-size:13px}textarea.text-editor.does-not-match{outline:1px solid red!important}x-div{display:block}x-spacer{flex:auto}*{box-sizing:border-box}*[hidden]{display:none!important}x-locator-editor{flex:none;width:100%;height:60px;padding:4px;border-bottom:1px solid #dddddd;outline:1px solid transparent}x-locator-editor.does-not-match{outline:1px solid red}.CodeMirror{width:100%!important;height:100%!important}x-pw-action-list{flex:auto;display:flex;flex-direction:column;user-select:none}x-pw-action-item{padding:6px 10px;cursor:pointer;overflow:hidden}x-pw-action-item:hover{background-color:#f2f2f2}x-pw-action-item:last-child{border-bottom-left-radius:6px;border-bottom-right-radius:6px}\\n";\n\n// packages/injected/src/highlight.ts\nvar Highlight = class {\n  constructor(injectedScript) {\n    this._renderedEntries = [];\n    this._language = "javascript";\n    this._injectedScript = injectedScript;\n    const document = injectedScript.document;\n    this._isUnderTest = injectedScript.isUnderTest;\n    this._glassPaneElement = document.createElement("x-pw-glass");\n    this._glassPaneElement.style.position = "fixed";\n    this._glassPaneElement.style.top = "0";\n    this._glassPaneElement.style.right = "0";\n    this._glassPaneElement.style.bottom = "0";\n    this._glassPaneElement.style.left = "0";\n    this._glassPaneElement.style.zIndex = "2147483647";\n    this._glassPaneElement.style.pointerEvents = "none";\n    this._glassPaneElement.style.display = "flex";\n    this._glassPaneElement.style.backgroundColor = "transparent";\n    this._actionPointElement = document.createElement("x-pw-action-point");\n    this._actionPointElement.setAttribute("hidden", "true");\n    this._glassPaneShadow = this._glassPaneElement.attachShadow({ mode: this._isUnderTest ? "open" : "closed" });\n    if (typeof this._glassPaneShadow.adoptedStyleSheets.push === "function") {\n      const sheet = new this._injectedScript.window.CSSStyleSheet();\n      sheet.replaceSync(highlight_default);\n      this._glassPaneShadow.adoptedStyleSheets.push(sheet);\n    } else {\n      const styleElement = this._injectedScript.document.createElement("style");\n      styleElement.textContent = highlight_default;\n      this._glassPaneShadow.appendChild(styleElement);\n    }\n    this._glassPaneShadow.appendChild(this._actionPointElement);\n  }\n  install() {\n    if (!this._injectedScript.document.documentElement)\n      return;\n    if (!this._injectedScript.document.documentElement.contains(this._glassPaneElement) || this._glassPaneElement.nextElementSibling)\n      this._injectedScript.document.documentElement.appendChild(this._glassPaneElement);\n  }\n  setLanguage(language) {\n    this._language = language;\n  }\n  runHighlightOnRaf(selector) {\n    if (this._rafRequest)\n      this._injectedScript.utils.builtins.cancelAnimationFrame(this._rafRequest);\n    const elements = this._injectedScript.querySelectorAll(selector, this._injectedScript.document.documentElement);\n    const locator = asLocator(this._language, stringifySelector(selector));\n    const color = elements.length > 1 ? "#f6b26b7f" : "#6fa8dc7f";\n    this.updateHighlight(elements.map((element, index) => {\n      const suffix = elements.length > 1 ? ` [${index + 1} of ${elements.length}]` : "";\n      return { element, color, tooltipText: locator + suffix };\n    }));\n    this._rafRequest = this._injectedScript.utils.builtins.requestAnimationFrame(() => this.runHighlightOnRaf(selector));\n  }\n  uninstall() {\n    if (this._rafRequest)\n      this._injectedScript.utils.builtins.cancelAnimationFrame(this._rafRequest);\n    this._glassPaneElement.remove();\n  }\n  showActionPoint(x, y) {\n    this._actionPointElement.style.top = y + "px";\n    this._actionPointElement.style.left = x + "px";\n    this._actionPointElement.hidden = false;\n  }\n  hideActionPoint() {\n    this._actionPointElement.hidden = true;\n  }\n  clearHighlight() {\n    var _a, _b;\n    for (const entry of this._renderedEntries) {\n      (_a = entry.highlightElement) == null ? void 0 : _a.remove();\n      (_b = entry.tooltipElement) == null ? void 0 : _b.remove();\n    }\n    this._renderedEntries = [];\n  }\n  maskElements(elements, color) {\n    this.updateHighlight(elements.map((element) => ({ element, color })));\n  }\n  updateHighlight(entries) {\n    if (this._highlightIsUpToDate(entries))\n      return;\n    this.clearHighlight();\n    for (const entry of entries) {\n      const highlightElement = this._createHighlightElement();\n      this._glassPaneShadow.appendChild(highlightElement);\n      let tooltipElement;\n      if (entry.tooltipText) {\n        tooltipElement = this._injectedScript.document.createElement("x-pw-tooltip");\n        this._glassPaneShadow.appendChild(tooltipElement);\n        tooltipElement.style.top = "0";\n        tooltipElement.style.left = "0";\n        tooltipElement.style.display = "flex";\n        const lineElement = this._injectedScript.document.createElement("x-pw-tooltip-line");\n        lineElement.textContent = entry.tooltipText;\n        tooltipElement.appendChild(lineElement);\n      }\n      this._renderedEntries.push({ targetElement: entry.element, color: entry.color, tooltipElement, highlightElement });\n    }\n    for (const entry of this._renderedEntries) {\n      entry.box = entry.targetElement.getBoundingClientRect();\n      if (!entry.tooltipElement)\n        continue;\n      const { anchorLeft, anchorTop } = this.tooltipPosition(entry.box, entry.tooltipElement);\n      entry.tooltipTop = anchorTop;\n      entry.tooltipLeft = anchorLeft;\n    }\n    for (const entry of this._renderedEntries) {\n      if (entry.tooltipElement) {\n        entry.tooltipElement.style.top = entry.tooltipTop + "px";\n        entry.tooltipElement.style.left = entry.tooltipLeft + "px";\n      }\n      const box = entry.box;\n      entry.highlightElement.style.backgroundColor = entry.color;\n      entry.highlightElement.style.left = box.x + "px";\n      entry.highlightElement.style.top = box.y + "px";\n      entry.highlightElement.style.width = box.width + "px";\n      entry.highlightElement.style.height = box.height + "px";\n      entry.highlightElement.style.display = "block";\n      if (this._isUnderTest)\n        console.error("Highlight box for test: " + JSON.stringify({ x: box.x, y: box.y, width: box.width, height: box.height }));\n    }\n  }\n  firstBox() {\n    var _a;\n    return (_a = this._renderedEntries[0]) == null ? void 0 : _a.box;\n  }\n  firstTooltipBox() {\n    const entry = this._renderedEntries[0];\n    if (!entry || !entry.tooltipElement || entry.tooltipLeft === void 0 || entry.tooltipTop === void 0)\n      return;\n    return {\n      x: entry.tooltipLeft,\n      y: entry.tooltipTop,\n      left: entry.tooltipLeft,\n      top: entry.tooltipTop,\n      width: entry.tooltipElement.offsetWidth,\n      height: entry.tooltipElement.offsetHeight,\n      bottom: entry.tooltipTop + entry.tooltipElement.offsetHeight,\n      right: entry.tooltipLeft + entry.tooltipElement.offsetWidth,\n      toJSON: () => {\n      }\n    };\n  }\n  // Note: there is a copy of this method in dialog.tsx. Please fix bugs in both places.\n  tooltipPosition(box, tooltipElement) {\n    const tooltipWidth = tooltipElement.offsetWidth;\n    const tooltipHeight = tooltipElement.offsetHeight;\n    const totalWidth = this._glassPaneElement.offsetWidth;\n    const totalHeight = this._glassPaneElement.offsetHeight;\n    let anchorLeft = Math.max(5, box.left);\n    if (anchorLeft + tooltipWidth > totalWidth - 5)\n      anchorLeft = totalWidth - tooltipWidth - 5;\n    let anchorTop = Math.max(0, box.bottom) + 5;\n    if (anchorTop + tooltipHeight > totalHeight - 5) {\n      if (Math.max(0, box.top) > tooltipHeight + 5) {\n        anchorTop = Math.max(0, box.top) - tooltipHeight - 5;\n      } else {\n        anchorTop = totalHeight - 5 - tooltipHeight;\n      }\n    }\n    return { anchorLeft, anchorTop };\n  }\n  _highlightIsUpToDate(entries) {\n    if (entries.length !== this._renderedEntries.length)\n      return false;\n    for (let i = 0; i < this._renderedEntries.length; ++i) {\n      if (entries[i].element !== this._renderedEntries[i].targetElement)\n        return false;\n      if (entries[i].color !== this._renderedEntries[i].color)\n        return false;\n      const oldBox = this._renderedEntries[i].box;\n      if (!oldBox)\n        return false;\n      const box = entries[i].element.getBoundingClientRect();\n      if (box.top !== oldBox.top || box.right !== oldBox.right || box.bottom !== oldBox.bottom || box.left !== oldBox.left)\n        return false;\n    }\n    return true;\n  }\n  _createHighlightElement() {\n    return this._injectedScript.document.createElement("x-pw-highlight");\n  }\n  appendChild(element) {\n    this._glassPaneShadow.appendChild(element);\n  }\n  onGlassPaneClick(handler) {\n    this._glassPaneElement.style.pointerEvents = "auto";\n    this._glassPaneElement.style.backgroundColor = "rgba(0, 0, 0, 0.3)";\n    this._glassPaneElement.addEventListener("click", handler);\n  }\n  offGlassPaneClick(handler) {\n    this._glassPaneElement.style.pointerEvents = "none";\n    this._glassPaneElement.style.backgroundColor = "transparent";\n    this._glassPaneElement.removeEventListener("click", handler);\n  }\n};\n\n// packages/injected/src/layoutSelectorUtils.ts\nfunction boxRightOf(box1, box2, maxDistance) {\n  const distance = box1.left - box2.right;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\nfunction boxLeftOf(box1, box2, maxDistance) {\n  const distance = box2.left - box1.right;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\nfunction boxAbove(box1, box2, maxDistance) {\n  const distance = box2.top - box1.bottom;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\nfunction boxBelow(box1, box2, maxDistance) {\n  const distance = box1.top - box2.bottom;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\nfunction boxNear(box1, box2, maxDistance) {\n  const kThreshold = maxDistance === void 0 ? 50 : maxDistance;\n  let score = 0;\n  if (box1.left - box2.right >= 0)\n    score += box1.left - box2.right;\n  if (box2.left - box1.right >= 0)\n    score += box2.left - box1.right;\n  if (box2.top - box1.bottom >= 0)\n    score += box2.top - box1.bottom;\n  if (box1.top - box2.bottom >= 0)\n    score += box1.top - box2.bottom;\n  return score > kThreshold ? void 0 : score;\n}\nvar kLayoutSelectorNames = ["left-of", "right-of", "above", "below", "near"];\nfunction layoutSelectorScore(name, element, inner, maxDistance) {\n  const box = element.getBoundingClientRect();\n  const scorer = { "left-of": boxLeftOf, "right-of": boxRightOf, "above": boxAbove, "below": boxBelow, "near": boxNear }[name];\n  let bestScore;\n  for (const e of inner) {\n    if (e === element)\n      continue;\n    const score = scorer(box, e.getBoundingClientRect(), maxDistance);\n    if (score === void 0)\n      continue;\n    if (bestScore === void 0 || score < bestScore)\n      bestScore = score;\n  }\n  return bestScore;\n}\n\n// packages/injected/src/selectorUtils.ts\nfunction matchesComponentAttribute(obj, attr) {\n  for (const token of attr.jsonPath) {\n    if (obj !== void 0 && obj !== null)\n      obj = obj[token];\n  }\n  return matchesAttributePart(obj, attr);\n}\nfunction matchesAttributePart(value, attr) {\n  const objValue = typeof value === "string" && !attr.caseSensitive ? value.toUpperCase() : value;\n  const attrValue = typeof attr.value === "string" && !attr.caseSensitive ? attr.value.toUpperCase() : attr.value;\n  if (attr.op === "<truthy>")\n    return !!objValue;\n  if (attr.op === "=") {\n    if (attrValue instanceof RegExp)\n      return typeof objValue === "string" && !!objValue.match(attrValue);\n    return objValue === attrValue;\n  }\n  if (typeof objValue !== "string" || typeof attrValue !== "string")\n    return false;\n  if (attr.op === "*=")\n    return objValue.includes(attrValue);\n  if (attr.op === "^=")\n    return objValue.startsWith(attrValue);\n  if (attr.op === "$=")\n    return objValue.endsWith(attrValue);\n  if (attr.op === "|=")\n    return objValue === attrValue || objValue.startsWith(attrValue + "-");\n  if (attr.op === "~=")\n    return objValue.split(" ").includes(attrValue);\n  return false;\n}\nfunction shouldSkipForTextMatching(element) {\n  const document = element.ownerDocument;\n  return element.nodeName === "SCRIPT" || element.nodeName === "NOSCRIPT" || element.nodeName === "STYLE" || document.head && document.head.contains(element);\n}\nfunction elementText(cache, root) {\n  let value = cache.get(root);\n  if (value === void 0) {\n    value = { full: "", normalized: "", immediate: [] };\n    if (!shouldSkipForTextMatching(root)) {\n      let currentImmediate = "";\n      if (root instanceof HTMLInputElement && (root.type === "submit" || root.type === "button")) {\n        value = { full: root.value, normalized: normalizeWhiteSpace(root.value), immediate: [root.value] };\n      } else {\n        for (let child = root.firstChild; child; child = child.nextSibling) {\n          if (child.nodeType === Node.TEXT_NODE) {\n            value.full += child.nodeValue || "";\n            currentImmediate += child.nodeValue || "";\n          } else if (child.nodeType === Node.COMMENT_NODE) {\n            continue;\n          } else {\n            if (currentImmediate)\n              value.immediate.push(currentImmediate);\n            currentImmediate = "";\n            if (child.nodeType === Node.ELEMENT_NODE)\n              value.full += elementText(cache, child).full;\n          }\n        }\n        if (currentImmediate)\n          value.immediate.push(currentImmediate);\n        if (root.shadowRoot)\n          value.full += elementText(cache, root.shadowRoot).full;\n        if (value.full)\n          value.normalized = normalizeWhiteSpace(value.full);\n      }\n    }\n    cache.set(root, value);\n  }\n  return value;\n}\nfunction elementMatchesText(cache, element, matcher) {\n  if (shouldSkipForTextMatching(element))\n    return "none";\n  if (!matcher(elementText(cache, element)))\n    return "none";\n  for (let child = element.firstChild; child; child = child.nextSibling) {\n    if (child.nodeType === Node.ELEMENT_NODE && matcher(elementText(cache, child)))\n      return "selfAndChildren";\n  }\n  if (element.shadowRoot && matcher(elementText(cache, element.shadowRoot)))\n    return "selfAndChildren";\n  return "self";\n}\nfunction getElementLabels(textCache, element) {\n  const labels = getAriaLabelledByElements(element);\n  if (labels)\n    return labels.map((label) => elementText(textCache, label));\n  const ariaLabel = element.getAttribute("aria-label");\n  if (ariaLabel !== null && !!ariaLabel.trim())\n    return [{ full: ariaLabel, normalized: normalizeWhiteSpace(ariaLabel), immediate: [ariaLabel] }];\n  const isNonHiddenInput = element.nodeName === "INPUT" && element.type !== "hidden";\n  if (["BUTTON", "METER", "OUTPUT", "PROGRESS", "SELECT", "TEXTAREA"].includes(element.nodeName) || isNonHiddenInput) {\n    const labels2 = element.labels;\n    if (labels2)\n      return [...labels2].map((label) => elementText(textCache, label));\n  }\n  return [];\n}\n\n// packages/injected/src/reactSelectorEngine.ts\nfunction getFunctionComponentName(component) {\n  return component.displayName || component.name || "Anonymous";\n}\nfunction getComponentName(reactElement) {\n  if (reactElement.type) {\n    switch (typeof reactElement.type) {\n      case "function":\n        return getFunctionComponentName(reactElement.type);\n      case "string":\n        return reactElement.type;\n      case "object":\n        return reactElement.type.displayName || (reactElement.type.render ? getFunctionComponentName(reactElement.type.render) : "");\n    }\n  }\n  if (reactElement._currentElement) {\n    const elementType = reactElement._currentElement.type;\n    if (typeof elementType === "string")\n      return elementType;\n    if (typeof elementType === "function")\n      return elementType.displayName || elementType.name || "Anonymous";\n  }\n  return "";\n}\nfunction getComponentKey(reactElement) {\n  var _a, _b;\n  return (_b = reactElement.key) != null ? _b : (_a = reactElement._currentElement) == null ? void 0 : _a.key;\n}\nfunction getChildren(reactElement) {\n  if (reactElement.child) {\n    const children = [];\n    for (let child = reactElement.child; child; child = child.sibling)\n      children.push(child);\n    return children;\n  }\n  if (!reactElement._currentElement)\n    return [];\n  const isKnownElement = (reactElement2) => {\n    var _a;\n    const elementType = (_a = reactElement2._currentElement) == null ? void 0 : _a.type;\n    return typeof elementType === "function" || typeof elementType === "string";\n  };\n  if (reactElement._renderedComponent) {\n    const child = reactElement._renderedComponent;\n    return isKnownElement(child) ? [child] : [];\n  }\n  if (reactElement._renderedChildren)\n    return [...Object.values(reactElement._renderedChildren)].filter(isKnownElement);\n  return [];\n}\nfunction getProps(reactElement) {\n  var _a;\n  const props = (\n    /* React 16+ */\n    reactElement.memoizedProps || /* React 15 */\n    ((_a = reactElement._currentElement) == null ? void 0 : _a.props)\n  );\n  if (!props || typeof props === "string")\n    return props;\n  const result = { ...props };\n  delete result.children;\n  return result;\n}\nfunction buildComponentsTree(reactElement) {\n  var _a;\n  const treeNode = {\n    key: getComponentKey(reactElement),\n    name: getComponentName(reactElement),\n    children: getChildren(reactElement).map(buildComponentsTree),\n    rootElements: [],\n    props: getProps(reactElement)\n  };\n  const rootElement = (\n    /* React 16+ */\n    reactElement.stateNode || /* React 15 */\n    reactElement._hostNode || /* React 15 */\n    ((_a = reactElement._renderedComponent) == null ? void 0 : _a._hostNode)\n  );\n  if (rootElement instanceof Element) {\n    treeNode.rootElements.push(rootElement);\n  } else {\n    for (const child of treeNode.children)\n      treeNode.rootElements.push(...child.rootElements);\n  }\n  return treeNode;\n}\nfunction filterComponentsTree(treeNode, searchFn, result = []) {\n  if (searchFn(treeNode))\n    result.push(treeNode);\n  for (const child of treeNode.children)\n    filterComponentsTree(child, searchFn, result);\n  return result;\n}\nfunction findReactRoots(root, roots = []) {\n  const document = root.ownerDocument || root;\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  do {\n    const node = walker.currentNode;\n    const reactNode = node;\n    const rootKey = Object.keys(reactNode).find((key) => key.startsWith("__reactContainer") && reactNode[key] !== null);\n    if (rootKey) {\n      roots.push(reactNode[rootKey].stateNode.current);\n    } else {\n      const legacyRootKey = "_reactRootContainer";\n      if (reactNode.hasOwnProperty(legacyRootKey) && reactNode[legacyRootKey] !== null) {\n        roots.push(reactNode[legacyRootKey]._internalRoot.current);\n      }\n    }\n    if (node instanceof Element && node.hasAttribute("data-reactroot")) {\n      for (const key of Object.keys(node)) {\n        if (key.startsWith("__reactInternalInstance") || key.startsWith("__reactFiber"))\n          roots.push(node[key]);\n      }\n    }\n    const shadowRoot = node instanceof Element ? node.shadowRoot : null;\n    if (shadowRoot)\n      findReactRoots(shadowRoot, roots);\n  } while (walker.nextNode());\n  return roots;\n}\nvar createReactEngine = () => ({\n  queryAll(scope, selector) {\n    const { name, attributes } = parseAttributeSelector(selector, false);\n    const reactRoots = findReactRoots(scope.ownerDocument || scope);\n    const trees = reactRoots.map((reactRoot) => buildComponentsTree(reactRoot));\n    const treeNodes = trees.map((tree) => filterComponentsTree(tree, (treeNode) => {\n      var _a;\n      const props = (_a = treeNode.props) != null ? _a : {};\n      if (treeNode.key !== void 0)\n        props.key = treeNode.key;\n      if (name && treeNode.name !== name)\n        return false;\n      if (treeNode.rootElements.some((domNode) => !isInsideScope(scope, domNode)))\n        return false;\n      for (const attr of attributes) {\n        if (!matchesComponentAttribute(props, attr))\n          return false;\n      }\n      return true;\n    })).flat();\n    const allRootElements = /* @__PURE__ */ new Set();\n    for (const treeNode of treeNodes) {\n      for (const domNode of treeNode.rootElements)\n        allRootElements.add(domNode);\n    }\n    return [...allRootElements];\n  }\n});\n\n// packages/injected/src/roleSelectorEngine.ts\nvar kSupportedAttributes = ["selected", "checked", "pressed", "expanded", "level", "disabled", "name", "include-hidden"];\nkSupportedAttributes.sort();\nfunction validateSupportedRole(attr, roles, role) {\n  if (!roles.includes(role))\n    throw new Error(`"${attr}" attribute is only supported for roles: ${roles.slice().sort().map((role2) => `"${role2}"`).join(", ")}`);\n}\nfunction validateSupportedValues(attr, values) {\n  if (attr.op !== "<truthy>" && !values.includes(attr.value))\n    throw new Error(`"${attr.name}" must be one of ${values.map((v) => JSON.stringify(v)).join(", ")}`);\n}\nfunction validateSupportedOp(attr, ops) {\n  if (!ops.includes(attr.op))\n    throw new Error(`"${attr.name}" does not support "${attr.op}" matcher`);\n}\nfunction validateAttributes(attrs, role) {\n  const options = { role };\n  for (const attr of attrs) {\n    switch (attr.name) {\n      case "checked": {\n        validateSupportedRole(attr.name, kAriaCheckedRoles, role);\n        validateSupportedValues(attr, [true, false, "mixed"]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.checked = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      case "pressed": {\n        validateSupportedRole(attr.name, kAriaPressedRoles, role);\n        validateSupportedValues(attr, [true, false, "mixed"]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.pressed = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      case "selected": {\n        validateSupportedRole(attr.name, kAriaSelectedRoles, role);\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.selected = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      case "expanded": {\n        validateSupportedRole(attr.name, kAriaExpandedRoles, role);\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.expanded = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      case "level": {\n        validateSupportedRole(attr.name, kAriaLevelRoles, role);\n        if (typeof attr.value === "string")\n          attr.value = +attr.value;\n        if (attr.op !== "=" || typeof attr.value !== "number" || Number.isNaN(attr.value))\n          throw new Error(`"level" attribute must be compared to a number`);\n        options.level = attr.value;\n        break;\n      }\n      case "disabled": {\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.disabled = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      case "name": {\n        if (attr.op === "<truthy>")\n          throw new Error(`"name" attribute must have a value`);\n        if (typeof attr.value !== "string" && !(attr.value instanceof RegExp))\n          throw new Error(`"name" attribute must be a string or a regular expression`);\n        options.name = attr.value;\n        options.nameOp = attr.op;\n        options.exact = attr.caseSensitive;\n        break;\n      }\n      case "include-hidden": {\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.includeHidden = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      default: {\n        throw new Error(`Unknown attribute "${attr.name}", must be one of ${kSupportedAttributes.map((a) => `"${a}"`).join(", ")}.`);\n      }\n    }\n  }\n  return options;\n}\nfunction queryRole(scope, options, internal) {\n  const result = [];\n  const match = (element) => {\n    if (getAriaRole(element) !== options.role)\n      return;\n    if (options.selected !== void 0 && getAriaSelected(element) !== options.selected)\n      return;\n    if (options.checked !== void 0 && getAriaChecked(element) !== options.checked)\n      return;\n    if (options.pressed !== void 0 && getAriaPressed(element) !== options.pressed)\n      return;\n    if (options.expanded !== void 0 && getAriaExpanded(element) !== options.expanded)\n      return;\n    if (options.level !== void 0 && getAriaLevel(element) !== options.level)\n      return;\n    if (options.disabled !== void 0 && getAriaDisabled(element) !== options.disabled)\n      return;\n    if (!options.includeHidden) {\n      const isHidden = isElementHiddenForAria(element);\n      if (isHidden)\n        return;\n    }\n    if (options.name !== void 0) {\n      const accessibleName = normalizeWhiteSpace(getElementAccessibleName(element, !!options.includeHidden));\n      if (typeof options.name === "string")\n        options.name = normalizeWhiteSpace(options.name);\n      if (internal && !options.exact && options.nameOp === "=")\n        options.nameOp = "*=";\n      if (!matchesAttributePart(accessibleName, { name: "", jsonPath: [], op: options.nameOp || "=", value: options.name, caseSensitive: !!options.exact }))\n        return;\n    }\n    result.push(element);\n  };\n  const query = (root) => {\n    const shadows = [];\n    if (root.shadowRoot)\n      shadows.push(root.shadowRoot);\n    for (const element of root.querySelectorAll("*")) {\n      match(element);\n      if (element.shadowRoot)\n        shadows.push(element.shadowRoot);\n    }\n    shadows.forEach(query);\n  };\n  query(scope);\n  return result;\n}\nfunction createRoleEngine(internal) {\n  return {\n    queryAll: (scope, selector) => {\n      const parsed = parseAttributeSelector(selector, true);\n      const role = parsed.name.toLowerCase();\n      if (!role)\n        throw new Error(`Role must not be empty`);\n      const options = validateAttributes(parsed.attributes, role);\n      beginAriaCaches();\n      try {\n        return queryRole(scope, options, internal);\n      } finally {\n        endAriaCaches();\n      }\n    }\n  };\n}\n\n// packages/injected/src/selectorEvaluator.ts\nvar SelectorEvaluatorImpl = class {\n  constructor() {\n    this._retainCacheCounter = 0;\n    this._cacheText = /* @__PURE__ */ new Map();\n    this._cacheQueryCSS = /* @__PURE__ */ new Map();\n    this._cacheMatches = /* @__PURE__ */ new Map();\n    this._cacheQuery = /* @__PURE__ */ new Map();\n    this._cacheMatchesSimple = /* @__PURE__ */ new Map();\n    this._cacheMatchesParents = /* @__PURE__ */ new Map();\n    this._cacheCallMatches = /* @__PURE__ */ new Map();\n    this._cacheCallQuery = /* @__PURE__ */ new Map();\n    this._cacheQuerySimple = /* @__PURE__ */ new Map();\n    this._engines = /* @__PURE__ */ new Map();\n    this._engines.set("not", notEngine);\n    this._engines.set("is", isEngine);\n    this._engines.set("where", isEngine);\n    this._engines.set("has", hasEngine);\n    this._engines.set("scope", scopeEngine);\n    this._engines.set("light", lightEngine);\n    this._engines.set("visible", visibleEngine);\n    this._engines.set("text", textEngine);\n    this._engines.set("text-is", textIsEngine);\n    this._engines.set("text-matches", textMatchesEngine);\n    this._engines.set("has-text", hasTextEngine);\n    this._engines.set("right-of", createLayoutEngine("right-of"));\n    this._engines.set("left-of", createLayoutEngine("left-of"));\n    this._engines.set("above", createLayoutEngine("above"));\n    this._engines.set("below", createLayoutEngine("below"));\n    this._engines.set("near", createLayoutEngine("near"));\n    this._engines.set("nth-match", nthMatchEngine);\n    const allNames = [...this._engines.keys()];\n    allNames.sort();\n    const parserNames = [...customCSSNames];\n    parserNames.sort();\n    if (allNames.join("|") !== parserNames.join("|"))\n      throw new Error(`Please keep customCSSNames in sync with evaluator engines: ${allNames.join("|")} vs ${parserNames.join("|")}`);\n  }\n  begin() {\n    ++this._retainCacheCounter;\n  }\n  end() {\n    --this._retainCacheCounter;\n    if (!this._retainCacheCounter) {\n      this._cacheQueryCSS.clear();\n      this._cacheMatches.clear();\n      this._cacheQuery.clear();\n      this._cacheMatchesSimple.clear();\n      this._cacheMatchesParents.clear();\n      this._cacheCallMatches.clear();\n      this._cacheCallQuery.clear();\n      this._cacheQuerySimple.clear();\n      this._cacheText.clear();\n    }\n  }\n  _cached(cache, main, rest, cb) {\n    if (!cache.has(main))\n      cache.set(main, []);\n    const entries = cache.get(main);\n    const entry = entries.find((e) => rest.every((value, index) => e.rest[index] === value));\n    if (entry)\n      return entry.result;\n    const result = cb();\n    entries.push({ rest, result });\n    return result;\n  }\n  _checkSelector(s) {\n    const wellFormed = typeof s === "object" && s && (Array.isArray(s) || "simples" in s && s.simples.length);\n    if (!wellFormed)\n      throw new Error(`Malformed selector "${s}"`);\n    return s;\n  }\n  matches(element, s, context) {\n    const selector = this._checkSelector(s);\n    this.begin();\n    try {\n      return this._cached(this._cacheMatches, element, [selector, context.scope, context.pierceShadow, context.originalScope], () => {\n        if (Array.isArray(selector))\n          return this._matchesEngine(isEngine, element, selector, context);\n        if (this._hasScopeClause(selector))\n          context = this._expandContextForScopeMatching(context);\n        if (!this._matchesSimple(element, selector.simples[selector.simples.length - 1].selector, context))\n          return false;\n        return this._matchesParents(element, selector, selector.simples.length - 2, context);\n      });\n    } finally {\n      this.end();\n    }\n  }\n  query(context, s) {\n    const selector = this._checkSelector(s);\n    this.begin();\n    try {\n      return this._cached(this._cacheQuery, selector, [context.scope, context.pierceShadow, context.originalScope], () => {\n        if (Array.isArray(selector))\n          return this._queryEngine(isEngine, context, selector);\n        if (this._hasScopeClause(selector))\n          context = this._expandContextForScopeMatching(context);\n        const previousScoreMap = this._scoreMap;\n        this._scoreMap = /* @__PURE__ */ new Map();\n        let elements = this._querySimple(context, selector.simples[selector.simples.length - 1].selector);\n        elements = elements.filter((element) => this._matchesParents(element, selector, selector.simples.length - 2, context));\n        if (this._scoreMap.size) {\n          elements.sort((a, b) => {\n            const aScore = this._scoreMap.get(a);\n            const bScore = this._scoreMap.get(b);\n            if (aScore === bScore)\n              return 0;\n            if (aScore === void 0)\n              return 1;\n            if (bScore === void 0)\n              return -1;\n            return aScore - bScore;\n          });\n        }\n        this._scoreMap = previousScoreMap;\n        return elements;\n      });\n    } finally {\n      this.end();\n    }\n  }\n  _markScore(element, score) {\n    if (this._scoreMap)\n      this._scoreMap.set(element, score);\n  }\n  _hasScopeClause(selector) {\n    return selector.simples.some((simple) => simple.selector.functions.some((f) => f.name === "scope"));\n  }\n  _expandContextForScopeMatching(context) {\n    if (context.scope.nodeType !== 1)\n      return context;\n    const scope = parentElementOrShadowHost(context.scope);\n    if (!scope)\n      return context;\n    return { ...context, scope, originalScope: context.originalScope || context.scope };\n  }\n  _matchesSimple(element, simple, context) {\n    return this._cached(this._cacheMatchesSimple, element, [simple, context.scope, context.pierceShadow, context.originalScope], () => {\n      if (element === context.scope)\n        return false;\n      if (simple.css && !this._matchesCSS(element, simple.css))\n        return false;\n      for (const func of simple.functions) {\n        if (!this._matchesEngine(this._getEngine(func.name), element, func.args, context))\n          return false;\n      }\n      return true;\n    });\n  }\n  _querySimple(context, simple) {\n    if (!simple.functions.length)\n      return this._queryCSS(context, simple.css || "*");\n    return this._cached(this._cacheQuerySimple, simple, [context.scope, context.pierceShadow, context.originalScope], () => {\n      let css = simple.css;\n      const funcs = simple.functions;\n      if (css === "*" && funcs.length)\n        css = void 0;\n      let elements;\n      let firstIndex = -1;\n      if (css !== void 0) {\n        elements = this._queryCSS(context, css);\n      } else {\n        firstIndex = funcs.findIndex((func) => this._getEngine(func.name).query !== void 0);\n        if (firstIndex === -1)\n          firstIndex = 0;\n        elements = this._queryEngine(this._getEngine(funcs[firstIndex].name), context, funcs[firstIndex].args);\n      }\n      for (let i = 0; i < funcs.length; i++) {\n        if (i === firstIndex)\n          continue;\n        const engine = this._getEngine(funcs[i].name);\n        if (engine.matches !== void 0)\n          elements = elements.filter((e) => this._matchesEngine(engine, e, funcs[i].args, context));\n      }\n      for (let i = 0; i < funcs.length; i++) {\n        if (i === firstIndex)\n          continue;\n        const engine = this._getEngine(funcs[i].name);\n        if (engine.matches === void 0)\n          elements = elements.filter((e) => this._matchesEngine(engine, e, funcs[i].args, context));\n      }\n      return elements;\n    });\n  }\n  _matchesParents(element, complex, index, context) {\n    if (index < 0)\n      return true;\n    return this._cached(this._cacheMatchesParents, element, [complex, index, context.scope, context.pierceShadow, context.originalScope], () => {\n      const { selector: simple, combinator } = complex.simples[index];\n      if (combinator === ">") {\n        const parent = parentElementOrShadowHostInContext(element, context);\n        if (!parent || !this._matchesSimple(parent, simple, context))\n          return false;\n        return this._matchesParents(parent, complex, index - 1, context);\n      }\n      if (combinator === "+") {\n        const previousSibling = previousSiblingInContext(element, context);\n        if (!previousSibling || !this._matchesSimple(previousSibling, simple, context))\n          return false;\n        return this._matchesParents(previousSibling, complex, index - 1, context);\n      }\n      if (combinator === "") {\n        let parent = parentElementOrShadowHostInContext(element, context);\n        while (parent) {\n          if (this._matchesSimple(parent, simple, context)) {\n            if (this._matchesParents(parent, complex, index - 1, context))\n              return true;\n            if (complex.simples[index - 1].combinator === "")\n              break;\n          }\n          parent = parentElementOrShadowHostInContext(parent, context);\n        }\n        return false;\n      }\n      if (combinator === "~") {\n        let previousSibling = previousSiblingInContext(element, context);\n        while (previousSibling) {\n          if (this._matchesSimple(previousSibling, simple, context)) {\n            if (this._matchesParents(previousSibling, complex, index - 1, context))\n              return true;\n            if (complex.simples[index - 1].combinator === "~")\n              break;\n          }\n          previousSibling = previousSiblingInContext(previousSibling, context);\n        }\n        return false;\n      }\n      if (combinator === ">=") {\n        let parent = element;\n        while (parent) {\n          if (this._matchesSimple(parent, simple, context)) {\n            if (this._matchesParents(parent, complex, index - 1, context))\n              return true;\n            if (complex.simples[index - 1].combinator === "")\n              break;\n          }\n          parent = parentElementOrShadowHostInContext(parent, context);\n        }\n        return false;\n      }\n      throw new Error(`Unsupported combinator "${combinator}"`);\n    });\n  }\n  _matchesEngine(engine, element, args, context) {\n    if (engine.matches)\n      return this._callMatches(engine, element, args, context);\n    if (engine.query)\n      return this._callQuery(engine, args, context).includes(element);\n    throw new Error(`Selector engine should implement "matches" or "query"`);\n  }\n  _queryEngine(engine, context, args) {\n    if (engine.query)\n      return this._callQuery(engine, args, context);\n    if (engine.matches)\n      return this._queryCSS(context, "*").filter((element) => this._callMatches(engine, element, args, context));\n    throw new Error(`Selector engine should implement "matches" or "query"`);\n  }\n  _callMatches(engine, element, args, context) {\n    return this._cached(this._cacheCallMatches, element, [engine, context.scope, context.pierceShadow, context.originalScope, ...args], () => {\n      return engine.matches(element, args, context, this);\n    });\n  }\n  _callQuery(engine, args, context) {\n    return this._cached(this._cacheCallQuery, engine, [context.scope, context.pierceShadow, context.originalScope, ...args], () => {\n      return engine.query(context, args, this);\n    });\n  }\n  _matchesCSS(element, css) {\n    return element.matches(css);\n  }\n  _queryCSS(context, css) {\n    return this._cached(this._cacheQueryCSS, css, [context.scope, context.pierceShadow, context.originalScope], () => {\n      let result = [];\n      function query(root) {\n        result = result.concat([...root.querySelectorAll(css)]);\n        if (!context.pierceShadow)\n          return;\n        if (root.shadowRoot)\n          query(root.shadowRoot);\n        for (const element of root.querySelectorAll("*")) {\n          if (element.shadowRoot)\n            query(element.shadowRoot);\n        }\n      }\n      query(context.scope);\n      return result;\n    });\n  }\n  _getEngine(name) {\n    const engine = this._engines.get(name);\n    if (!engine)\n      throw new Error(`Unknown selector engine "${name}"`);\n    return engine;\n  }\n};\nvar isEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0)\n      throw new Error(`"is" engine expects non-empty selector list`);\n    return args.some((selector) => evaluator.matches(element, selector, context));\n  },\n  query(context, args, evaluator) {\n    if (args.length === 0)\n      throw new Error(`"is" engine expects non-empty selector list`);\n    let elements = [];\n    for (const arg of args)\n      elements = elements.concat(evaluator.query(context, arg));\n    return args.length === 1 ? elements : sortInDOMOrder(elements);\n  }\n};\nvar hasEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0)\n      throw new Error(`"has" engine expects non-empty selector list`);\n    return evaluator.query({ ...context, scope: element }, args).length > 0;\n  }\n  // TODO: we can implement efficient "query" by matching "args" and returning\n  // all parents/descendants, just have to be careful with the ":scope" matching.\n};\nvar scopeEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 0)\n      throw new Error(`"scope" engine expects no arguments`);\n    const actualScope = context.originalScope || context.scope;\n    if (actualScope.nodeType === 9)\n      return element === actualScope.documentElement;\n    return element === actualScope;\n  },\n  query(context, args, evaluator) {\n    if (args.length !== 0)\n      throw new Error(`"scope" engine expects no arguments`);\n    const actualScope = context.originalScope || context.scope;\n    if (actualScope.nodeType === 9) {\n      const root = actualScope.documentElement;\n      return root ? [root] : [];\n    }\n    if (actualScope.nodeType === 1)\n      return [actualScope];\n    return [];\n  }\n};\nvar notEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0)\n      throw new Error(`"not" engine expects non-empty selector list`);\n    return !evaluator.matches(element, args, context);\n  }\n};\nvar lightEngine = {\n  query(context, args, evaluator) {\n    return evaluator.query({ ...context, pierceShadow: false }, args);\n  },\n  matches(element, args, context, evaluator) {\n    return evaluator.matches(element, args, { ...context, pierceShadow: false });\n  }\n};\nvar visibleEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length)\n      throw new Error(`"visible" engine expects no arguments`);\n    return isElementVisible(element);\n  }\n};\nvar textEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== "string")\n      throw new Error(`"text" engine expects a single string`);\n    const text = normalizeWhiteSpace(args[0]).toLowerCase();\n    const matcher = (elementText2) => elementText2.normalized.toLowerCase().includes(text);\n    return elementMatchesText(evaluator._cacheText, element, matcher) === "self";\n  }\n};\nvar textIsEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== "string")\n      throw new Error(`"text-is" engine expects a single string`);\n    const text = normalizeWhiteSpace(args[0]);\n    const matcher = (elementText2) => {\n      if (!text && !elementText2.immediate.length)\n        return true;\n      return elementText2.immediate.some((s) => normalizeWhiteSpace(s) === text);\n    };\n    return elementMatchesText(evaluator._cacheText, element, matcher) !== "none";\n  }\n};\nvar textMatchesEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0 || typeof args[0] !== "string" || args.length > 2 || args.length === 2 && typeof args[1] !== "string")\n      throw new Error(`"text-matches" engine expects a regexp body and optional regexp flags`);\n    const re = new RegExp(args[0], args.length === 2 ? args[1] : void 0);\n    const matcher = (elementText2) => re.test(elementText2.full);\n    return elementMatchesText(evaluator._cacheText, element, matcher) === "self";\n  }\n};\nvar hasTextEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== "string")\n      throw new Error(`"has-text" engine expects a single string`);\n    if (shouldSkipForTextMatching(element))\n      return false;\n    const text = normalizeWhiteSpace(args[0]).toLowerCase();\n    const matcher = (elementText2) => elementText2.normalized.toLowerCase().includes(text);\n    return matcher(elementText(evaluator._cacheText, element));\n  }\n};\nfunction createLayoutEngine(name) {\n  return {\n    matches(element, args, context, evaluator) {\n      const maxDistance = args.length && typeof args[args.length - 1] === "number" ? args[args.length - 1] : void 0;\n      const queryArgs = maxDistance === void 0 ? args : args.slice(0, args.length - 1);\n      if (args.length < 1 + (maxDistance === void 0 ? 0 : 1))\n        throw new Error(`"${name}" engine expects a selector list and optional maximum distance in pixels`);\n      const inner = evaluator.query(context, queryArgs);\n      const score = layoutSelectorScore(name, element, inner, maxDistance);\n      if (score === void 0)\n        return false;\n      evaluator._markScore(element, score);\n      return true;\n    }\n  };\n}\nvar nthMatchEngine = {\n  query(context, args, evaluator) {\n    let index = args[args.length - 1];\n    if (args.length < 2)\n      throw new Error(`"nth-match" engine expects non-empty selector list and an index argument`);\n    if (typeof index !== "number" || index < 1)\n      throw new Error(`"nth-match" engine expects a one-based index as the last argument`);\n    const elements = isEngine.query(context, args.slice(0, args.length - 1), evaluator);\n    index--;\n    return index < elements.length ? [elements[index]] : [];\n  }\n};\nfunction parentElementOrShadowHostInContext(element, context) {\n  if (element === context.scope)\n    return;\n  if (!context.pierceShadow)\n    return element.parentElement || void 0;\n  return parentElementOrShadowHost(element);\n}\nfunction previousSiblingInContext(element, context) {\n  if (element === context.scope)\n    return;\n  return element.previousElementSibling || void 0;\n}\nfunction sortInDOMOrder(elements) {\n  const elementToEntry = /* @__PURE__ */ new Map();\n  const roots = [];\n  const result = [];\n  function append(element) {\n    let entry = elementToEntry.get(element);\n    if (entry)\n      return entry;\n    const parent = parentElementOrShadowHost(element);\n    if (parent) {\n      const parentEntry = append(parent);\n      parentEntry.children.push(element);\n    } else {\n      roots.push(element);\n    }\n    entry = { children: [], taken: false };\n    elementToEntry.set(element, entry);\n    return entry;\n  }\n  for (const e of elements)\n    append(e).taken = true;\n  function visit(element) {\n    const entry = elementToEntry.get(element);\n    if (entry.taken)\n      result.push(element);\n    if (entry.children.length > 1) {\n      const set = new Set(entry.children);\n      entry.children = [];\n      let child = element.firstElementChild;\n      while (child && entry.children.length < set.size) {\n        if (set.has(child))\n          entry.children.push(child);\n        child = child.nextElementSibling;\n      }\n      child = element.shadowRoot ? element.shadowRoot.firstElementChild : null;\n      while (child && entry.children.length < set.size) {\n        if (set.has(child))\n          entry.children.push(child);\n        child = child.nextElementSibling;\n      }\n    }\n    entry.children.forEach(visit);\n  }\n  roots.forEach(visit);\n  return result;\n}\n\n// packages/injected/src/selectorGenerator.ts\nvar kTextScoreRange = 10;\nvar kExactPenalty = kTextScoreRange / 2;\nvar kTestIdScore = 1;\nvar kOtherTestIdScore = 2;\nvar kIframeByAttributeScore = 10;\nvar kBeginPenalizedScore = 50;\nvar kRoleWithNameScore = 100;\nvar kPlaceholderScore = 120;\nvar kLabelScore = 140;\nvar kAltTextScore = 160;\nvar kTextScore = 180;\nvar kTitleScore = 200;\nvar kTextScoreRegex = 250;\nvar kPlaceholderScoreExact = kPlaceholderScore + kExactPenalty;\nvar kLabelScoreExact = kLabelScore + kExactPenalty;\nvar kRoleWithNameScoreExact = kRoleWithNameScore + kExactPenalty;\nvar kAltTextScoreExact = kAltTextScore + kExactPenalty;\nvar kTextScoreExact = kTextScore + kExactPenalty;\nvar kTitleScoreExact = kTitleScore + kExactPenalty;\nvar kEndPenalizedScore = 300;\nvar kCSSIdScore = 500;\nvar kRoleWithoutNameScore = 510;\nvar kCSSInputTypeNameScore = 520;\nvar kCSSTagNameScore = 530;\nvar kNthScore = 1e4;\nvar kCSSFallbackScore = 1e7;\nvar kScoreThresholdForTextExpect = 1e3;\nfunction generateSelector(injectedScript, targetElement, options) {\n  var _a;\n  injectedScript._evaluator.begin();\n  const cache = { allowText: /* @__PURE__ */ new Map(), disallowText: /* @__PURE__ */ new Map() };\n  beginAriaCaches();\n  beginDOMCaches();\n  try {\n    let selectors = [];\n    if (options.forTextExpect) {\n      let targetTokens = cssFallback(injectedScript, targetElement.ownerDocument.documentElement, options);\n      for (let element = targetElement; element; element = parentElementOrShadowHost(element)) {\n        const tokens = generateSelectorFor(cache, injectedScript, element, { ...options, noText: true });\n        if (!tokens)\n          continue;\n        const score = combineScores(tokens);\n        if (score <= kScoreThresholdForTextExpect) {\n          targetTokens = tokens;\n          break;\n        }\n      }\n      selectors = [joinTokens(targetTokens)];\n    } else {\n      if (!targetElement.matches("input,textarea,select") && !targetElement.isContentEditable) {\n        const interactiveParent = closestCrossShadow(targetElement, "button,select,input,[role=button],[role=checkbox],[role=radio],a,[role=link]", options.root);\n        if (interactiveParent && isElementVisible(interactiveParent))\n          targetElement = interactiveParent;\n      }\n      if (options.multiple) {\n        const withText = generateSelectorFor(cache, injectedScript, targetElement, options);\n        const withoutText = generateSelectorFor(cache, injectedScript, targetElement, { ...options, noText: true });\n        let tokens = [withText, withoutText];\n        cache.allowText.clear();\n        cache.disallowText.clear();\n        if (withText && hasCSSIdToken(withText))\n          tokens.push(generateSelectorFor(cache, injectedScript, targetElement, { ...options, noCSSId: true }));\n        if (withoutText && hasCSSIdToken(withoutText))\n          tokens.push(generateSelectorFor(cache, injectedScript, targetElement, { ...options, noText: true, noCSSId: true }));\n        tokens = tokens.filter(Boolean);\n        if (!tokens.length) {\n          const css = cssFallback(injectedScript, targetElement, options);\n          tokens.push(css);\n          if (hasCSSIdToken(css))\n            tokens.push(cssFallback(injectedScript, targetElement, { ...options, noCSSId: true }));\n        }\n        selectors = [...new Set(tokens.map((t) => joinTokens(t)))];\n      } else {\n        const targetTokens = generateSelectorFor(cache, injectedScript, targetElement, options) || cssFallback(injectedScript, targetElement, options);\n        selectors = [joinTokens(targetTokens)];\n      }\n    }\n    const selector = selectors[0];\n    const parsedSelector = injectedScript.parseSelector(selector);\n    return {\n      selector,\n      selectors,\n      elements: injectedScript.querySelectorAll(parsedSelector, (_a = options.root) != null ? _a : targetElement.ownerDocument)\n    };\n  } finally {\n    endDOMCaches();\n    endAriaCaches();\n    injectedScript._evaluator.end();\n  }\n}\nfunction generateSelectorFor(cache, injectedScript, targetElement, options) {\n  var _a;\n  if (options.root && !isInsideScope(options.root, targetElement))\n    throw new Error(`Target element must belong to the root\'s subtree`);\n  if (targetElement === options.root)\n    return [{ engine: "css", selector: ":scope", score: 1 }];\n  if (targetElement.ownerDocument.documentElement === targetElement)\n    return [{ engine: "css", selector: "html", score: 1 }];\n  let result = null;\n  const updateResult = (candidate) => {\n    if (!result || combineScores(candidate) < combineScores(result))\n      result = candidate;\n  };\n  const candidates = [];\n  if (!options.noText) {\n    for (const candidate of buildTextCandidates(injectedScript, targetElement, !options.isRecursive))\n      candidates.push({ candidate, isTextCandidate: true });\n  }\n  for (const token of buildNoTextCandidates(injectedScript, targetElement, options)) {\n    if (options.omitInternalEngines && token.engine.startsWith("internal:"))\n      continue;\n    candidates.push({ candidate: [token], isTextCandidate: false });\n  }\n  candidates.sort((a, b) => combineScores(a.candidate) - combineScores(b.candidate));\n  for (const { candidate, isTextCandidate } of candidates) {\n    const elements = injectedScript.querySelectorAll(injectedScript.parseSelector(joinTokens(candidate)), (_a = options.root) != null ? _a : targetElement.ownerDocument);\n    if (!elements.includes(targetElement)) {\n      continue;\n    }\n    if (elements.length === 1) {\n      updateResult(candidate);\n      break;\n    }\n    const index = elements.indexOf(targetElement);\n    if (index > 5) {\n      continue;\n    }\n    updateResult([...candidate, { engine: "nth", selector: String(index), score: kNthScore }]);\n    if (options.isRecursive) {\n      continue;\n    }\n    for (let parent = parentElementOrShadowHost(targetElement); parent && parent !== options.root; parent = parentElementOrShadowHost(parent)) {\n      const filtered = elements.filter((e) => isInsideScope(parent, e) && e !== parent);\n      const newIndex = filtered.indexOf(targetElement);\n      if (filtered.length > 5 || newIndex === -1 || newIndex === index && filtered.length > 1) {\n        continue;\n      }\n      const inParent = filtered.length === 1 ? candidate : [...candidate, { engine: "nth", selector: String(newIndex), score: kNthScore }];\n      const idealSelectorForParent = { engine: "", selector: "", score: 1 };\n      if (result && combineScores([idealSelectorForParent, ...inParent]) >= combineScores(result)) {\n        continue;\n      }\n      const noText = !!options.noText || isTextCandidate;\n      const cacheMap = noText ? cache.disallowText : cache.allowText;\n      let parentTokens = cacheMap.get(parent);\n      if (parentTokens === void 0) {\n        parentTokens = generateSelectorFor(cache, injectedScript, parent, { ...options, isRecursive: true, noText }) || cssFallback(injectedScript, parent, options);\n        cacheMap.set(parent, parentTokens);\n      }\n      if (!parentTokens)\n        continue;\n      updateResult([...parentTokens, ...inParent]);\n    }\n  }\n  return result;\n}\nfunction buildNoTextCandidates(injectedScript, element, options) {\n  const candidates = [];\n  {\n    for (const attr of ["data-testid", "data-test-id", "data-test"]) {\n      if (attr !== options.testIdAttributeName && element.getAttribute(attr))\n        candidates.push({ engine: "css", selector: `[${attr}=${quoteCSSAttributeValue(element.getAttribute(attr))}]`, score: kOtherTestIdScore });\n    }\n    if (!options.noCSSId) {\n      const idAttr = element.getAttribute("id");\n      if (idAttr && !isGuidLike(idAttr))\n        candidates.push({ engine: "css", selector: makeSelectorForId(idAttr), score: kCSSIdScore });\n    }\n    candidates.push({ engine: "css", selector: escapeNodeName(element), score: kCSSTagNameScore });\n  }\n  if (element.nodeName === "IFRAME") {\n    for (const attribute of ["name", "title"]) {\n      if (element.getAttribute(attribute))\n        candidates.push({ engine: "css", selector: `${escapeNodeName(element)}[${attribute}=${quoteCSSAttributeValue(element.getAttribute(attribute))}]`, score: kIframeByAttributeScore });\n    }\n    if (element.getAttribute(options.testIdAttributeName))\n      candidates.push({ engine: "css", selector: `[${options.testIdAttributeName}=${quoteCSSAttributeValue(element.getAttribute(options.testIdAttributeName))}]`, score: kTestIdScore });\n    penalizeScoreForLength([candidates]);\n    return candidates;\n  }\n  if (element.getAttribute(options.testIdAttributeName))\n    candidates.push({ engine: "internal:testid", selector: `[${options.testIdAttributeName}=${escapeForAttributeSelector(element.getAttribute(options.testIdAttributeName), true)}]`, score: kTestIdScore });\n  if (element.nodeName === "INPUT" || element.nodeName === "TEXTAREA") {\n    const input = element;\n    if (input.placeholder) {\n      candidates.push({ engine: "internal:attr", selector: `[placeholder=${escapeForAttributeSelector(input.placeholder, true)}]`, score: kPlaceholderScoreExact });\n      for (const alternative of suitableTextAlternatives(input.placeholder))\n        candidates.push({ engine: "internal:attr", selector: `[placeholder=${escapeForAttributeSelector(alternative.text, false)}]`, score: kPlaceholderScore - alternative.scoreBonus });\n    }\n  }\n  const labels = getElementLabels(injectedScript._evaluator._cacheText, element);\n  for (const label of labels) {\n    const labelText = label.normalized;\n    candidates.push({ engine: "internal:label", selector: escapeForTextSelector(labelText, true), score: kLabelScoreExact });\n    for (const alternative of suitableTextAlternatives(labelText))\n      candidates.push({ engine: "internal:label", selector: escapeForTextSelector(alternative.text, false), score: kLabelScore - alternative.scoreBonus });\n  }\n  const ariaRole = getAriaRole(element);\n  if (ariaRole && !["none", "presentation"].includes(ariaRole))\n    candidates.push({ engine: "internal:role", selector: ariaRole, score: kRoleWithoutNameScore });\n  if (element.getAttribute("name") && ["BUTTON", "FORM", "FIELDSET", "FRAME", "IFRAME", "INPUT", "KEYGEN", "OBJECT", "OUTPUT", "SELECT", "TEXTAREA", "MAP", "META", "PARAM"].includes(element.nodeName))\n    candidates.push({ engine: "css", selector: `${escapeNodeName(element)}[name=${quoteCSSAttributeValue(element.getAttribute("name"))}]`, score: kCSSInputTypeNameScore });\n  if (["INPUT", "TEXTAREA"].includes(element.nodeName) && element.getAttribute("type") !== "hidden") {\n    if (element.getAttribute("type"))\n      candidates.push({ engine: "css", selector: `${escapeNodeName(element)}[type=${quoteCSSAttributeValue(element.getAttribute("type"))}]`, score: kCSSInputTypeNameScore });\n  }\n  if (["INPUT", "TEXTAREA", "SELECT"].includes(element.nodeName) && element.getAttribute("type") !== "hidden")\n    candidates.push({ engine: "css", selector: escapeNodeName(element), score: kCSSInputTypeNameScore + 1 });\n  penalizeScoreForLength([candidates]);\n  return candidates;\n}\nfunction buildTextCandidates(injectedScript, element, isTargetNode) {\n  if (element.nodeName === "SELECT")\n    return [];\n  const candidates = [];\n  const title = element.getAttribute("title");\n  if (title) {\n    candidates.push([{ engine: "internal:attr", selector: `[title=${escapeForAttributeSelector(title, true)}]`, score: kTitleScoreExact }]);\n    for (const alternative of suitableTextAlternatives(title))\n      candidates.push([{ engine: "internal:attr", selector: `[title=${escapeForAttributeSelector(alternative.text, false)}]`, score: kTitleScore - alternative.scoreBonus }]);\n  }\n  const alt = element.getAttribute("alt");\n  if (alt && ["APPLET", "AREA", "IMG", "INPUT"].includes(element.nodeName)) {\n    candidates.push([{ engine: "internal:attr", selector: `[alt=${escapeForAttributeSelector(alt, true)}]`, score: kAltTextScoreExact }]);\n    for (const alternative of suitableTextAlternatives(alt))\n      candidates.push([{ engine: "internal:attr", selector: `[alt=${escapeForAttributeSelector(alternative.text, false)}]`, score: kAltTextScore - alternative.scoreBonus }]);\n  }\n  const text = elementText(injectedScript._evaluator._cacheText, element).normalized;\n  const textAlternatives = text ? suitableTextAlternatives(text) : [];\n  if (text) {\n    if (isTargetNode) {\n      if (text.length <= 80)\n        candidates.push([{ engine: "internal:text", selector: escapeForTextSelector(text, true), score: kTextScoreExact }]);\n      for (const alternative of textAlternatives)\n        candidates.push([{ engine: "internal:text", selector: escapeForTextSelector(alternative.text, false), score: kTextScore - alternative.scoreBonus }]);\n    }\n    const cssToken = { engine: "css", selector: escapeNodeName(element), score: kCSSTagNameScore };\n    for (const alternative of textAlternatives)\n      candidates.push([cssToken, { engine: "internal:has-text", selector: escapeForTextSelector(alternative.text, false), score: kTextScore - alternative.scoreBonus }]);\n    if (isTargetNode && text.length <= 80) {\n      const re = new RegExp("^" + escapeRegExp(text) + "$");\n      candidates.push([cssToken, { engine: "internal:has-text", selector: escapeForTextSelector(re, false), score: kTextScoreRegex }]);\n    }\n  }\n  const ariaRole = getAriaRole(element);\n  if (ariaRole && !["none", "presentation"].includes(ariaRole)) {\n    const ariaName = getElementAccessibleName(element, false);\n    if (ariaName && !ariaName.match(/^\\p{Co}+$/u)) {\n      const roleToken = { engine: "internal:role", selector: `${ariaRole}[name=${escapeForAttributeSelector(ariaName, true)}]`, score: kRoleWithNameScoreExact };\n      candidates.push([roleToken]);\n      for (const alternative of suitableTextAlternatives(ariaName))\n        candidates.push([{ engine: "internal:role", selector: `${ariaRole}[name=${escapeForAttributeSelector(alternative.text, false)}]`, score: kRoleWithNameScore - alternative.scoreBonus }]);\n    } else {\n      const roleToken = { engine: "internal:role", selector: `${ariaRole}`, score: kRoleWithoutNameScore };\n      for (const alternative of textAlternatives)\n        candidates.push([roleToken, { engine: "internal:has-text", selector: escapeForTextSelector(alternative.text, false), score: kTextScore - alternative.scoreBonus }]);\n      if (isTargetNode && text.length <= 80) {\n        const re = new RegExp("^" + escapeRegExp(text) + "$");\n        candidates.push([roleToken, { engine: "internal:has-text", selector: escapeForTextSelector(re, false), score: kTextScoreRegex }]);\n      }\n    }\n  }\n  penalizeScoreForLength(candidates);\n  return candidates;\n}\nfunction makeSelectorForId(id) {\n  return /^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(id) ? "#" + id : `[id=${quoteCSSAttributeValue(id)}]`;\n}\nfunction hasCSSIdToken(tokens) {\n  return tokens.some((token) => token.engine === "css" && (token.selector.startsWith("#") || token.selector.startsWith(\'[id="\')));\n}\nfunction cssFallback(injectedScript, targetElement, options) {\n  var _a;\n  const root = (_a = options.root) != null ? _a : targetElement.ownerDocument;\n  const tokens = [];\n  function uniqueCSSSelector(prefix) {\n    const path = tokens.slice();\n    if (prefix)\n      path.unshift(prefix);\n    const selector = path.join(" > ");\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const node = injectedScript.querySelector(parsedSelector, root, false);\n    return node === targetElement ? selector : void 0;\n  }\n  function makeStrict(selector) {\n    const token = { engine: "css", selector, score: kCSSFallbackScore };\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const elements = injectedScript.querySelectorAll(parsedSelector, root);\n    if (elements.length === 1)\n      return [token];\n    const nth = { engine: "nth", selector: String(elements.indexOf(targetElement)), score: kNthScore };\n    return [token, nth];\n  }\n  for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost(element)) {\n    let bestTokenForLevel = "";\n    if (element.id && !options.noCSSId) {\n      const token = makeSelectorForId(element.id);\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      bestTokenForLevel = token;\n    }\n    const parent = element.parentNode;\n    const classes = [...element.classList].map(escapeClassName);\n    for (let i = 0; i < classes.length; ++i) {\n      const token = "." + classes.slice(0, i + 1).join(".");\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel && parent) {\n        const sameClassSiblings = parent.querySelectorAll(token);\n        if (sameClassSiblings.length === 1)\n          bestTokenForLevel = token;\n      }\n    }\n    if (parent) {\n      const siblings = [...parent.children];\n      const nodeName = element.nodeName;\n      const sameTagSiblings = siblings.filter((sibling) => sibling.nodeName === nodeName);\n      const token = sameTagSiblings.indexOf(element) === 0 ? escapeNodeName(element) : `${escapeNodeName(element)}:nth-child(${1 + siblings.indexOf(element)})`;\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel)\n        bestTokenForLevel = token;\n    } else if (!bestTokenForLevel) {\n      bestTokenForLevel = escapeNodeName(element);\n    }\n    tokens.unshift(bestTokenForLevel);\n  }\n  return makeStrict(uniqueCSSSelector());\n}\nfunction penalizeScoreForLength(groups) {\n  for (const group of groups) {\n    for (const token of group) {\n      if (token.score > kBeginPenalizedScore && token.score < kEndPenalizedScore)\n        token.score += Math.min(kTextScoreRange, token.selector.length / 10 | 0);\n    }\n  }\n}\nfunction joinTokens(tokens) {\n  const parts = [];\n  let lastEngine = "";\n  for (const { engine, selector } of tokens) {\n    if (parts.length && (lastEngine !== "css" || engine !== "css" || selector.startsWith(":nth-match(")))\n      parts.push(">>");\n    lastEngine = engine;\n    if (engine === "css")\n      parts.push(selector);\n    else\n      parts.push(`${engine}=${selector}`);\n  }\n  return parts.join(" ");\n}\nfunction combineScores(tokens) {\n  let score = 0;\n  for (let i = 0; i < tokens.length; i++)\n    score += tokens[i].score * (tokens.length - i);\n  return score;\n}\nfunction isGuidLike(id) {\n  let lastCharacterType;\n  let transitionCount = 0;\n  for (let i = 0; i < id.length; ++i) {\n    const c = id[i];\n    let characterType;\n    if (c === "-" || c === "_")\n      continue;\n    if (c >= "a" && c <= "z")\n      characterType = "lower";\n    else if (c >= "A" && c <= "Z")\n      characterType = "upper";\n    else if (c >= "0" && c <= "9")\n      characterType = "digit";\n    else\n      characterType = "other";\n    if (characterType === "lower" && lastCharacterType === "upper") {\n      lastCharacterType = characterType;\n      continue;\n    }\n    if (lastCharacterType && lastCharacterType !== characterType)\n      ++transitionCount;\n    lastCharacterType = characterType;\n  }\n  return transitionCount >= id.length / 4;\n}\nfunction trimWordBoundary(text, maxLength) {\n  if (text.length <= maxLength)\n    return text;\n  text = text.substring(0, maxLength);\n  const match = text.match(/^(.*)\\b(.+?)$/);\n  if (!match)\n    return "";\n  return match[1].trimEnd();\n}\nfunction suitableTextAlternatives(text) {\n  let result = [];\n  {\n    const match = text.match(/^([\\d.,]+)[^.,\\w]/);\n    const leadingNumberLength = match ? match[1].length : 0;\n    if (leadingNumberLength) {\n      const alt = trimWordBoundary(text.substring(leadingNumberLength).trimStart(), 80);\n      result.push({ text: alt, scoreBonus: alt.length <= 30 ? 2 : 1 });\n    }\n  }\n  {\n    const match = text.match(/[^.,\\w]([\\d.,]+)$/);\n    const trailingNumberLength = match ? match[1].length : 0;\n    if (trailingNumberLength) {\n      const alt = trimWordBoundary(text.substring(0, text.length - trailingNumberLength).trimEnd(), 80);\n      result.push({ text: alt, scoreBonus: alt.length <= 30 ? 2 : 1 });\n    }\n  }\n  if (text.length <= 30) {\n    result.push({ text, scoreBonus: 0 });\n  } else {\n    result.push({ text: trimWordBoundary(text, 80), scoreBonus: 0 });\n    result.push({ text: trimWordBoundary(text, 30), scoreBonus: 1 });\n  }\n  result = result.filter((r) => r.text);\n  if (!result.length)\n    result.push({ text: text.substring(0, 80), scoreBonus: 0 });\n  return result;\n}\nfunction escapeNodeName(node) {\n  return node.nodeName.toLocaleLowerCase().replace(/[:\\.]/g, (char) => "\\\\" + char);\n}\nfunction escapeClassName(className) {\n  let result = "";\n  for (let i = 0; i < className.length; i++)\n    result += cssEscapeCharacter(className, i);\n  return result;\n}\nfunction cssEscapeCharacter(s, i) {\n  const c = s.charCodeAt(i);\n  if (c === 0)\n    return "\\uFFFD";\n  if (c >= 1 && c <= 31 || c >= 48 && c <= 57 && (i === 0 || i === 1 && s.charCodeAt(0) === 45))\n    return "\\\\" + c.toString(16) + " ";\n  if (i === 0 && c === 45 && s.length === 1)\n    return "\\\\" + s.charAt(i);\n  if (c >= 128 || c === 45 || c === 95 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122)\n    return s.charAt(i);\n  return "\\\\" + s.charAt(i);\n}\n\n// packages/injected/src/vueSelectorEngine.ts\nfunction basename(filename, ext) {\n  const normalized = filename.replace(/^[a-zA-Z]:/, "").replace(/\\\\/g, "/");\n  let result = normalized.substring(normalized.lastIndexOf("/") + 1);\n  if (ext && result.endsWith(ext))\n    result = result.substring(0, result.length - ext.length);\n  return result;\n}\nfunction toUpper(_, c) {\n  return c ? c.toUpperCase() : "";\n}\nvar classifyRE = /(?:^|[-_/])(\\w)/g;\nvar classify = (str) => {\n  return str && str.replace(classifyRE, toUpper);\n};\nfunction buildComponentsTreeVue3(instance) {\n  function getComponentTypeName(options) {\n    const name = options.name || options._componentTag || options.__playwright_guessedName;\n    if (name)\n      return name;\n    const file = options.__file;\n    if (file)\n      return classify(basename(file, ".vue"));\n  }\n  function saveComponentName(instance2, key) {\n    instance2.type.__playwright_guessedName = key;\n    return key;\n  }\n  function getInstanceName(instance2) {\n    var _a, _b, _c, _d;\n    const name = getComponentTypeName(instance2.type || {});\n    if (name)\n      return name;\n    if (instance2.root === instance2)\n      return "Root";\n    for (const key in (_b = (_a = instance2.parent) == null ? void 0 : _a.type) == null ? void 0 : _b.components) {\n      if (((_c = instance2.parent) == null ? void 0 : _c.type.components[key]) === instance2.type)\n        return saveComponentName(instance2, key);\n    }\n    for (const key in (_d = instance2.appContext) == null ? void 0 : _d.components) {\n      if (instance2.appContext.components[key] === instance2.type)\n        return saveComponentName(instance2, key);\n    }\n    return "Anonymous Component";\n  }\n  function isBeingDestroyed(instance2) {\n    return instance2._isBeingDestroyed || instance2.isUnmounted;\n  }\n  function isFragment(instance2) {\n    return instance2.subTree.type.toString() === "Symbol(Fragment)";\n  }\n  function getInternalInstanceChildren(subTree) {\n    const list = [];\n    if (subTree.component)\n      list.push(subTree.component);\n    if (subTree.suspense)\n      list.push(...getInternalInstanceChildren(subTree.suspense.activeBranch));\n    if (Array.isArray(subTree.children)) {\n      subTree.children.forEach((childSubTree) => {\n        if (childSubTree.component)\n          list.push(childSubTree.component);\n        else\n          list.push(...getInternalInstanceChildren(childSubTree));\n      });\n    }\n    return list.filter((child) => {\n      var _a;\n      return !isBeingDestroyed(child) && !((_a = child.type.devtools) == null ? void 0 : _a.hide);\n    });\n  }\n  function getRootElementsFromComponentInstance(instance2) {\n    if (isFragment(instance2))\n      return getFragmentRootElements(instance2.subTree);\n    return [instance2.subTree.el];\n  }\n  function getFragmentRootElements(vnode) {\n    if (!vnode.children)\n      return [];\n    const list = [];\n    for (let i = 0, l = vnode.children.length; i < l; i++) {\n      const childVnode = vnode.children[i];\n      if (childVnode.component)\n        list.push(...getRootElementsFromComponentInstance(childVnode.component));\n      else if (childVnode.el)\n        list.push(childVnode.el);\n    }\n    return list;\n  }\n  function buildComponentsTree2(instance2) {\n    return {\n      name: getInstanceName(instance2),\n      children: getInternalInstanceChildren(instance2.subTree).map(buildComponentsTree2),\n      rootElements: getRootElementsFromComponentInstance(instance2),\n      props: instance2.props\n    };\n  }\n  return buildComponentsTree2(instance);\n}\nfunction buildComponentsTreeVue2(instance) {\n  function getComponentName2(options) {\n    const name = options.displayName || options.name || options._componentTag;\n    if (name)\n      return name;\n    const file = options.__file;\n    if (file)\n      return classify(basename(file, ".vue"));\n  }\n  function getInstanceName(instance2) {\n    const name = getComponentName2(instance2.$options || instance2.fnOptions || {});\n    if (name)\n      return name;\n    return instance2.$root === instance2 ? "Root" : "Anonymous Component";\n  }\n  function getInternalInstanceChildren(instance2) {\n    if (instance2.$children)\n      return instance2.$children;\n    if (Array.isArray(instance2.subTree.children))\n      return instance2.subTree.children.filter((vnode) => !!vnode.component).map((vnode) => vnode.component);\n    return [];\n  }\n  function buildComponentsTree2(instance2) {\n    return {\n      name: getInstanceName(instance2),\n      children: getInternalInstanceChildren(instance2).map(buildComponentsTree2),\n      rootElements: [instance2.$el],\n      props: instance2._props\n    };\n  }\n  return buildComponentsTree2(instance);\n}\nfunction filterComponentsTree2(treeNode, searchFn, result = []) {\n  if (searchFn(treeNode))\n    result.push(treeNode);\n  for (const child of treeNode.children)\n    filterComponentsTree2(child, searchFn, result);\n  return result;\n}\nfunction findVueRoots(root, roots = []) {\n  const document = root.ownerDocument || root;\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  const vue2Roots = /* @__PURE__ */ new Set();\n  do {\n    const node = walker.currentNode;\n    if (node.__vue__)\n      vue2Roots.add(node.__vue__.$root);\n    if (node.__vue_app__ && node._vnode && node._vnode.component)\n      roots.push({ root: node._vnode.component, version: 3 });\n    const shadowRoot = node instanceof Element ? node.shadowRoot : null;\n    if (shadowRoot)\n      findVueRoots(shadowRoot, roots);\n  } while (walker.nextNode());\n  for (const vue2root of vue2Roots) {\n    roots.push({\n      version: 2,\n      root: vue2root\n    });\n  }\n  return roots;\n}\nvar createVueEngine = () => ({\n  queryAll(scope, selector) {\n    const document = scope.ownerDocument || scope;\n    const { name, attributes } = parseAttributeSelector(selector, false);\n    const vueRoots = findVueRoots(document);\n    const trees = vueRoots.map((vueRoot) => vueRoot.version === 3 ? buildComponentsTreeVue3(vueRoot.root) : buildComponentsTreeVue2(vueRoot.root));\n    const treeNodes = trees.map((tree) => filterComponentsTree2(tree, (treeNode) => {\n      if (name && treeNode.name !== name)\n        return false;\n      if (treeNode.rootElements.some((rootElement) => !isInsideScope(scope, rootElement)))\n        return false;\n      for (const attr of attributes) {\n        if (!matchesComponentAttribute(treeNode.props, attr))\n          return false;\n      }\n      return true;\n    })).flat();\n    const allRootElements = /* @__PURE__ */ new Set();\n    for (const treeNode of treeNodes) {\n      for (const rootElement of treeNode.rootElements)\n        allRootElements.add(rootElement);\n    }\n    return [...allRootElements];\n  }\n});\n\n// packages/injected/src/xpathSelectorEngine.ts\nvar XPathEngine = {\n  queryAll(root, selector) {\n    if (selector.startsWith("/") && root.nodeType !== Node.DOCUMENT_NODE)\n      selector = "." + selector;\n    const result = [];\n    const document = root.ownerDocument || root;\n    if (!document)\n      return result;\n    const it = document.evaluate(selector, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n    for (let node = it.iterateNext(); node; node = it.iterateNext()) {\n      if (node.nodeType === Node.ELEMENT_NODE)\n        result.push(node);\n    }\n    return result;\n  }\n};\n\n// packages/playwright-core/src/utils/isomorphic/locatorUtils.ts\nfunction getByAttributeTextSelector(attrName, text, options) {\n  return `internal:attr=[${attrName}=${escapeForAttributeSelector(text, (options == null ? void 0 : options.exact) || false)}]`;\n}\nfunction getByTestIdSelector(testIdAttributeName, testId) {\n  return `internal:testid=[${testIdAttributeName}=${escapeForAttributeSelector(testId, true)}]`;\n}\nfunction getByLabelSelector(text, options) {\n  return "internal:label=" + escapeForTextSelector(text, !!(options == null ? void 0 : options.exact));\n}\nfunction getByAltTextSelector(text, options) {\n  return getByAttributeTextSelector("alt", text, options);\n}\nfunction getByTitleSelector(text, options) {\n  return getByAttributeTextSelector("title", text, options);\n}\nfunction getByPlaceholderSelector(text, options) {\n  return getByAttributeTextSelector("placeholder", text, options);\n}\nfunction getByTextSelector(text, options) {\n  return "internal:text=" + escapeForTextSelector(text, !!(options == null ? void 0 : options.exact));\n}\nfunction getByRoleSelector(role, options = {}) {\n  const props = [];\n  if (options.checked !== void 0)\n    props.push(["checked", String(options.checked)]);\n  if (options.disabled !== void 0)\n    props.push(["disabled", String(options.disabled)]);\n  if (options.selected !== void 0)\n    props.push(["selected", String(options.selected)]);\n  if (options.expanded !== void 0)\n    props.push(["expanded", String(options.expanded)]);\n  if (options.includeHidden !== void 0)\n    props.push(["include-hidden", String(options.includeHidden)]);\n  if (options.level !== void 0)\n    props.push(["level", String(options.level)]);\n  if (options.name !== void 0)\n    props.push(["name", escapeForAttributeSelector(options.name, !!options.exact)]);\n  if (options.pressed !== void 0)\n    props.push(["pressed", String(options.pressed)]);\n  return `internal:role=${role}${props.map(([n, v]) => `[${n}=${v}]`).join("")}`;\n}\n\n// packages/injected/src/consoleApi.ts\nvar selectorSymbol = Symbol("selector");\nselectorSymbol;\nvar _Locator = class _Locator {\n  constructor(injectedScript, selector, options) {\n    if (options == null ? void 0 : options.hasText)\n      selector += ` >> internal:has-text=${escapeForTextSelector(options.hasText, false)}`;\n    if (options == null ? void 0 : options.hasNotText)\n      selector += ` >> internal:has-not-text=${escapeForTextSelector(options.hasNotText, false)}`;\n    if (options == null ? void 0 : options.has)\n      selector += ` >> internal:has=` + JSON.stringify(options.has[selectorSymbol]);\n    if (options == null ? void 0 : options.hasNot)\n      selector += ` >> internal:has-not=` + JSON.stringify(options.hasNot[selectorSymbol]);\n    if ((options == null ? void 0 : options.visible) !== void 0)\n      selector += ` >> visible=${options.visible ? "true" : "false"}`;\n    this[selectorSymbol] = selector;\n    if (selector) {\n      const parsed = injectedScript.parseSelector(selector);\n      this.element = injectedScript.querySelector(parsed, injectedScript.document, false);\n      this.elements = injectedScript.querySelectorAll(parsed, injectedScript.document);\n    }\n    const selectorBase = selector;\n    const self = this;\n    self.locator = (selector2, options2) => {\n      return new _Locator(injectedScript, selectorBase ? selectorBase + " >> " + selector2 : selector2, options2);\n    };\n    self.getByTestId = (testId) => self.locator(getByTestIdSelector(injectedScript.testIdAttributeNameForStrictErrorAndConsoleCodegen(), testId));\n    self.getByAltText = (text, options2) => self.locator(getByAltTextSelector(text, options2));\n    self.getByLabel = (text, options2) => self.locator(getByLabelSelector(text, options2));\n    self.getByPlaceholder = (text, options2) => self.locator(getByPlaceholderSelector(text, options2));\n    self.getByText = (text, options2) => self.locator(getByTextSelector(text, options2));\n    self.getByTitle = (text, options2) => self.locator(getByTitleSelector(text, options2));\n    self.getByRole = (role, options2 = {}) => self.locator(getByRoleSelector(role, options2));\n    self.filter = (options2) => new _Locator(injectedScript, selector, options2);\n    self.first = () => self.locator("nth=0");\n    self.last = () => self.locator("nth=-1");\n    self.nth = (index) => self.locator(`nth=${index}`);\n    self.and = (locator) => new _Locator(injectedScript, selectorBase + ` >> internal:and=` + JSON.stringify(locator[selectorSymbol]));\n    self.or = (locator) => new _Locator(injectedScript, selectorBase + ` >> internal:or=` + JSON.stringify(locator[selectorSymbol]));\n  }\n};\nvar Locator = _Locator;\nvar ConsoleAPI = class {\n  constructor(injectedScript) {\n    this._injectedScript = injectedScript;\n  }\n  install() {\n    if (this._injectedScript.window.playwright)\n      return;\n    this._injectedScript.window.playwright = {\n      $: (selector, strict) => this._querySelector(selector, !!strict),\n      $$: (selector) => this._querySelectorAll(selector),\n      inspect: (selector) => this._inspect(selector),\n      selector: (element) => this._selector(element),\n      generateLocator: (element, language) => this._generateLocator(element, language),\n      ariaSnapshot: (element, options) => {\n        return this._injectedScript.ariaSnapshot(element || this._injectedScript.document.body, options || { mode: "expect" });\n      },\n      resume: () => this._resume(),\n      ...new Locator(this._injectedScript, "")\n    };\n    delete this._injectedScript.window.playwright.filter;\n    delete this._injectedScript.window.playwright.first;\n    delete this._injectedScript.window.playwright.last;\n    delete this._injectedScript.window.playwright.nth;\n    delete this._injectedScript.window.playwright.and;\n    delete this._injectedScript.window.playwright.or;\n  }\n  _querySelector(selector, strict) {\n    if (typeof selector !== "string")\n      throw new Error(`Usage: playwright.query(\'Playwright >> selector\').`);\n    const parsed = this._injectedScript.parseSelector(selector);\n    return this._injectedScript.querySelector(parsed, this._injectedScript.document, strict);\n  }\n  _querySelectorAll(selector) {\n    if (typeof selector !== "string")\n      throw new Error(`Usage: playwright.$$(\'Playwright >> selector\').`);\n    const parsed = this._injectedScript.parseSelector(selector);\n    return this._injectedScript.querySelectorAll(parsed, this._injectedScript.document);\n  }\n  _inspect(selector) {\n    if (typeof selector !== "string")\n      throw new Error(`Usage: playwright.inspect(\'Playwright >> selector\').`);\n    this._injectedScript.window.inspect(this._querySelector(selector, false));\n  }\n  _selector(element) {\n    if (!(element instanceof Element))\n      throw new Error(`Usage: playwright.selector(element).`);\n    return this._injectedScript.generateSelectorSimple(element);\n  }\n  _generateLocator(element, language) {\n    if (!(element instanceof Element))\n      throw new Error(`Usage: playwright.locator(element).`);\n    const selector = this._injectedScript.generateSelectorSimple(element);\n    return asLocator(language || "javascript", selector);\n  }\n  _resume() {\n    if (!this._injectedScript.window.__pw_resume)\n      return false;\n    this._injectedScript.window.__pw_resume().catch(() => {\n    });\n  }\n};\n\n// packages/playwright-core/src/utils/isomorphic/utilityScriptSerializers.ts\nfunction isRegExp2(obj) {\n  try {\n    return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isDate(obj) {\n  try {\n    return obj instanceof Date || Object.prototype.toString.call(obj) === "[object Date]";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isURL(obj) {\n  try {\n    return obj instanceof URL || Object.prototype.toString.call(obj) === "[object URL]";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isError(obj) {\n  var _a;\n  try {\n    return obj instanceof Error || obj && ((_a = Object.getPrototypeOf(obj)) == null ? void 0 : _a.name) === "Error";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isTypedArray(obj, constructor) {\n  try {\n    return obj instanceof constructor || Object.prototype.toString.call(obj) === `[object ${constructor.name}]`;\n  } catch (error) {\n    return false;\n  }\n}\nvar typedArrayConstructors = {\n  i8: Int8Array,\n  ui8: Uint8Array,\n  ui8c: Uint8ClampedArray,\n  i16: Int16Array,\n  ui16: Uint16Array,\n  i32: Int32Array,\n  ui32: Uint32Array,\n  // TODO: add Float16Array once it\'s in baseline\n  f32: Float32Array,\n  f64: Float64Array,\n  bi64: BigInt64Array,\n  bui64: BigUint64Array\n};\nfunction typedArrayToBase64(array) {\n  if ("toBase64" in array)\n    return array.toBase64();\n  const binary = Array.from(new Uint8Array(array.buffer, array.byteOffset, array.byteLength)).map((b) => String.fromCharCode(b)).join("");\n  return btoa(binary);\n}\nfunction base64ToTypedArray(base64, TypedArrayConstructor) {\n  const binary = atob(base64);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++)\n    bytes[i] = binary.charCodeAt(i);\n  return new TypedArrayConstructor(bytes.buffer);\n}\nfunction parseEvaluationResultValue(value, handles = [], refs = /* @__PURE__ */ new Map()) {\n  if (Object.is(value, void 0))\n    return void 0;\n  if (typeof value === "object" && value) {\n    if ("ref" in value)\n      return refs.get(value.ref);\n    if ("v" in value) {\n      if (value.v === "undefined")\n        return void 0;\n      if (value.v === "null")\n        return null;\n      if (value.v === "NaN")\n        return NaN;\n      if (value.v === "Infinity")\n        return Infinity;\n      if (value.v === "-Infinity")\n        return -Infinity;\n      if (value.v === "-0")\n        return -0;\n      return void 0;\n    }\n    if ("d" in value) {\n      return new Date(value.d);\n    }\n    if ("u" in value)\n      return new URL(value.u);\n    if ("bi" in value)\n      return BigInt(value.bi);\n    if ("e" in value) {\n      const error = new Error(value.e.m);\n      error.name = value.e.n;\n      error.stack = value.e.s;\n      return error;\n    }\n    if ("r" in value)\n      return new RegExp(value.r.p, value.r.f);\n    if ("a" in value) {\n      const result = [];\n      refs.set(value.id, result);\n      for (const a of value.a)\n        result.push(parseEvaluationResultValue(a, handles, refs));\n      return result;\n    }\n    if ("o" in value) {\n      const result = {};\n      refs.set(value.id, result);\n      for (const { k, v } of value.o) {\n        if (k === "__proto__")\n          continue;\n        result[k] = parseEvaluationResultValue(v, handles, refs);\n      }\n      return result;\n    }\n    if ("h" in value)\n      return handles[value.h];\n    if ("ta" in value)\n      return base64ToTypedArray(value.ta.b, typedArrayConstructors[value.ta.k]);\n  }\n  return value;\n}\nfunction serializeAsCallArgument(value, handleSerializer) {\n  return serialize(value, handleSerializer, { visited: /* @__PURE__ */ new Map(), lastId: 0 });\n}\nfunction serialize(value, handleSerializer, visitorInfo) {\n  if (value && typeof value === "object") {\n    if (typeof globalThis.Window === "function" && value instanceof globalThis.Window)\n      return "ref: <Window>";\n    if (typeof globalThis.Document === "function" && value instanceof globalThis.Document)\n      return "ref: <Document>";\n    if (typeof globalThis.Node === "function" && value instanceof globalThis.Node)\n      return "ref: <Node>";\n  }\n  return innerSerialize(value, handleSerializer, visitorInfo);\n}\nfunction innerSerialize(value, handleSerializer, visitorInfo) {\n  var _a;\n  const result = handleSerializer(value);\n  if ("fallThrough" in result)\n    value = result.fallThrough;\n  else\n    return result;\n  if (typeof value === "symbol")\n    return { v: "undefined" };\n  if (Object.is(value, void 0))\n    return { v: "undefined" };\n  if (Object.is(value, null))\n    return { v: "null" };\n  if (Object.is(value, NaN))\n    return { v: "NaN" };\n  if (Object.is(value, Infinity))\n    return { v: "Infinity" };\n  if (Object.is(value, -Infinity))\n    return { v: "-Infinity" };\n  if (Object.is(value, -0))\n    return { v: "-0" };\n  if (typeof value === "boolean")\n    return value;\n  if (typeof value === "number")\n    return value;\n  if (typeof value === "string")\n    return value;\n  if (typeof value === "bigint")\n    return { bi: value.toString() };\n  if (isError(value)) {\n    let stack;\n    if ((_a = value.stack) == null ? void 0 : _a.startsWith(value.name + ": " + value.message)) {\n      stack = value.stack;\n    } else {\n      stack = `${value.name}: ${value.message}\n${value.stack}`;\n    }\n    return { e: { n: value.name, m: value.message, s: stack } };\n  }\n  if (isDate(value))\n    return { d: value.toJSON() };\n  if (isURL(value))\n    return { u: value.toJSON() };\n  if (isRegExp2(value))\n    return { r: { p: value.source, f: value.flags } };\n  for (const [k, ctor] of Object.entries(typedArrayConstructors)) {\n    if (isTypedArray(value, ctor))\n      return { ta: { b: typedArrayToBase64(value), k } };\n  }\n  const id = visitorInfo.visited.get(value);\n  if (id)\n    return { ref: id };\n  if (Array.isArray(value)) {\n    const a = [];\n    const id2 = ++visitorInfo.lastId;\n    visitorInfo.visited.set(value, id2);\n    for (let i = 0; i < value.length; ++i)\n      a.push(serialize(value[i], handleSerializer, visitorInfo));\n    return { a, id: id2 };\n  }\n  if (typeof value === "object") {\n    const o = [];\n    const id2 = ++visitorInfo.lastId;\n    visitorInfo.visited.set(value, id2);\n    for (const name of Object.keys(value)) {\n      let item;\n      try {\n        item = value[name];\n      } catch (e) {\n        continue;\n      }\n      if (name === "toJSON" && typeof item === "function")\n        o.push({ k: name, v: { o: [], id: 0 } });\n      else\n        o.push({ k: name, v: serialize(item, handleSerializer, visitorInfo) });\n    }\n    let jsonWrapper;\n    try {\n      if (o.length === 0 && value.toJSON && typeof value.toJSON === "function")\n        jsonWrapper = { value: value.toJSON() };\n    } catch (e) {\n    }\n    if (jsonWrapper)\n      return innerSerialize(jsonWrapper.value, handleSerializer, visitorInfo);\n    return { o, id: id2 };\n  }\n}\n\n// packages/injected/src/utilityScript.ts\nvar UtilityScript = class {\n  constructor(global, isUnderTest) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    this.global = global;\n    this.isUnderTest = isUnderTest;\n    if (global.__pwClock) {\n      this.builtins = global.__pwClock.builtins;\n    } else {\n      this.builtins = {\n        setTimeout: (_a = global.setTimeout) == null ? void 0 : _a.bind(global),\n        clearTimeout: (_b = global.clearTimeout) == null ? void 0 : _b.bind(global),\n        setInterval: (_c = global.setInterval) == null ? void 0 : _c.bind(global),\n        clearInterval: (_d = global.clearInterval) == null ? void 0 : _d.bind(global),\n        requestAnimationFrame: (_e = global.requestAnimationFrame) == null ? void 0 : _e.bind(global),\n        cancelAnimationFrame: (_f = global.cancelAnimationFrame) == null ? void 0 : _f.bind(global),\n        requestIdleCallback: (_g = global.requestIdleCallback) == null ? void 0 : _g.bind(global),\n        cancelIdleCallback: (_h = global.cancelIdleCallback) == null ? void 0 : _h.bind(global),\n        performance: global.performance,\n        Intl: global.Intl,\n        Date: global.Date\n      };\n    }\n    if (this.isUnderTest)\n      global.builtins = this.builtins;\n  }\n  evaluate(isFunction, returnByValue, expression, argCount, ...argsAndHandles) {\n    const args = argsAndHandles.slice(0, argCount);\n    const handles = argsAndHandles.slice(argCount);\n    const parameters = [];\n    for (let i = 0; i < args.length; i++)\n      parameters[i] = parseEvaluationResultValue(args[i], handles);\n    let result = this.global.eval(expression);\n    if (isFunction === true) {\n      result = result(...parameters);\n    } else if (isFunction === false) {\n      result = result;\n    } else {\n      if (typeof result === "function")\n        result = result(...parameters);\n    }\n    return returnByValue ? this._promiseAwareJsonValueNoThrow(result) : result;\n  }\n  jsonValue(returnByValue, value) {\n    if (value === void 0)\n      return void 0;\n    return serializeAsCallArgument(value, (value2) => ({ fallThrough: value2 }));\n  }\n  _promiseAwareJsonValueNoThrow(value) {\n    const safeJson = (value2) => {\n      try {\n        return this.jsonValue(true, value2);\n      } catch (e) {\n        return void 0;\n      }\n    };\n    if (value && typeof value === "object" && typeof value.then === "function") {\n      return (async () => {\n        const promiseValue = await value;\n        return safeJson(promiseValue);\n      })();\n    }\n    return safeJson(value);\n  }\n};\n\n// packages/injected/src/injectedScript.ts\nvar InjectedScript = class {\n  constructor(window, options) {\n    this._testIdAttributeNameForStrictErrorAndConsoleCodegen = "data-testid";\n    this._lastAriaSnapshotForTrack = /* @__PURE__ */ new Map();\n    // Recorder must use any external dependencies through InjectedScript.\n    // Otherwise it will end up with a copy of all modules it uses, and any\n    // module-level globals will be duplicated, which leads to subtle bugs.\n    this.utils = {\n      asLocator,\n      cacheNormalizedWhitespaces,\n      elementText,\n      getAriaRole,\n      getElementAccessibleDescription,\n      getElementAccessibleName,\n      isElementVisible,\n      isInsideScope,\n      normalizeWhiteSpace,\n      parseAriaSnapshot,\n      generateAriaTree,\n      findNewElement,\n      // Builtins protect injected code from clock emulation.\n      builtins: null\n    };\n    this.window = window;\n    this.document = window.document;\n    this.isUnderTest = options.isUnderTest;\n    this.utils.builtins = new UtilityScript(window, options.isUnderTest).builtins;\n    this._sdkLanguage = options.sdkLanguage;\n    this._testIdAttributeNameForStrictErrorAndConsoleCodegen = options.testIdAttributeName;\n    this._evaluator = new SelectorEvaluatorImpl();\n    this.consoleApi = new ConsoleAPI(this);\n    this.onGlobalListenersRemoved = /* @__PURE__ */ new Set();\n    this._autoClosingTags = /* @__PURE__ */ new Set(["AREA", "BASE", "BR", "COL", "COMMAND", "EMBED", "HR", "IMG", "INPUT", "KEYGEN", "LINK", "MENUITEM", "META", "PARAM", "SOURCE", "TRACK", "WBR"]);\n    this._booleanAttributes = /* @__PURE__ */ new Set(["checked", "selected", "disabled", "readonly", "multiple"]);\n    this._eventTypes = /* @__PURE__ */ new Map([\n      ["auxclick", "mouse"],\n      ["click", "mouse"],\n      ["dblclick", "mouse"],\n      ["mousedown", "mouse"],\n      ["mouseeenter", "mouse"],\n      ["mouseleave", "mouse"],\n      ["mousemove", "mouse"],\n      ["mouseout", "mouse"],\n      ["mouseover", "mouse"],\n      ["mouseup", "mouse"],\n      ["mouseleave", "mouse"],\n      ["mousewheel", "mouse"],\n      ["keydown", "keyboard"],\n      ["keyup", "keyboard"],\n      ["keypress", "keyboard"],\n      ["textInput", "keyboard"],\n      ["touchstart", "touch"],\n      ["touchmove", "touch"],\n      ["touchend", "touch"],\n      ["touchcancel", "touch"],\n      ["pointerover", "pointer"],\n      ["pointerout", "pointer"],\n      ["pointerenter", "pointer"],\n      ["pointerleave", "pointer"],\n      ["pointerdown", "pointer"],\n      ["pointerup", "pointer"],\n      ["pointermove", "pointer"],\n      ["pointercancel", "pointer"],\n      ["gotpointercapture", "pointer"],\n      ["lostpointercapture", "pointer"],\n      ["focus", "focus"],\n      ["blur", "focus"],\n      ["drag", "drag"],\n      ["dragstart", "drag"],\n      ["dragend", "drag"],\n      ["dragover", "drag"],\n      ["dragenter", "drag"],\n      ["dragleave", "drag"],\n      ["dragexit", "drag"],\n      ["drop", "drag"],\n      ["wheel", "wheel"],\n      ["deviceorientation", "deviceorientation"],\n      ["deviceorientationabsolute", "deviceorientation"],\n      ["devicemotion", "devicemotion"]\n    ]);\n    this._hoverHitTargetInterceptorEvents = /* @__PURE__ */ new Set(["mousemove"]);\n    this._tapHitTargetInterceptorEvents = /* @__PURE__ */ new Set(["pointerdown", "pointerup", "touchstart", "touchend", "touchcancel"]);\n    this._mouseHitTargetInterceptorEvents = /* @__PURE__ */ new Set(["mousedown", "mouseup", "pointerdown", "pointerup", "click", "auxclick", "dblclick", "contextmenu"]);\n    this._allHitTargetInterceptorEvents = /* @__PURE__ */ new Set([...this._hoverHitTargetInterceptorEvents, ...this._tapHitTargetInterceptorEvents, ...this._mouseHitTargetInterceptorEvents]);\n    this._engines = /* @__PURE__ */ new Map();\n    this._engines.set("xpath", XPathEngine);\n    this._engines.set("xpath:light", XPathEngine);\n    this._engines.set("_react", createReactEngine());\n    this._engines.set("_vue", createVueEngine());\n    this._engines.set("role", createRoleEngine(false));\n    this._engines.set("text", this._createTextEngine(true, false));\n    this._engines.set("text:light", this._createTextEngine(false, false));\n    this._engines.set("id", this._createAttributeEngine("id", true));\n    this._engines.set("id:light", this._createAttributeEngine("id", false));\n    this._engines.set("data-testid", this._createAttributeEngine("data-testid", true));\n    this._engines.set("data-testid:light", this._createAttributeEngine("data-testid", false));\n    this._engines.set("data-test-id", this._createAttributeEngine("data-test-id", true));\n    this._engines.set("data-test-id:light", this._createAttributeEngine("data-test-id", false));\n    this._engines.set("data-test", this._createAttributeEngine("data-test", true));\n    this._engines.set("data-test:light", this._createAttributeEngine("data-test", false));\n    this._engines.set("css", this._createCSSEngine());\n    this._engines.set("nth", { queryAll: () => [] });\n    this._engines.set("visible", this._createVisibleEngine());\n    this._engines.set("internal:control", this._createControlEngine());\n    this._engines.set("internal:has", this._createHasEngine());\n    this._engines.set("internal:has-not", this._createHasNotEngine());\n    this._engines.set("internal:and", { queryAll: () => [] });\n    this._engines.set("internal:or", { queryAll: () => [] });\n    this._engines.set("internal:chain", this._createInternalChainEngine());\n    this._engines.set("internal:label", this._createInternalLabelEngine());\n    this._engines.set("internal:text", this._createTextEngine(true, true));\n    this._engines.set("internal:has-text", this._createInternalHasTextEngine());\n    this._engines.set("internal:has-not-text", this._createInternalHasNotTextEngine());\n    this._engines.set("internal:attr", this._createNamedAttributeEngine());\n    this._engines.set("internal:testid", this._createNamedAttributeEngine());\n    this._engines.set("internal:role", createRoleEngine(true));\n    this._engines.set("internal:describe", this._createDescribeEngine());\n    this._engines.set("aria-ref", this._createAriaRefEngine());\n    for (const { name, source } of options.customEngines)\n      this._engines.set(name, this.eval(source));\n    this._stableRafCount = options.stableRafCount;\n    this._browserName = options.browserName;\n    this._isUtilityWorld = !!options.isUtilityWorld;\n    setGlobalOptions({ browserNameForWorkarounds: options.browserName });\n    this._setupGlobalListenersRemovalDetection();\n    this._setupHitTargetInterceptors();\n    if (this.isUnderTest)\n      this.window.__injectedScript = this;\n  }\n  eval(expression) {\n    return this.window.eval(expression);\n  }\n  testIdAttributeNameForStrictErrorAndConsoleCodegen() {\n    return this._testIdAttributeNameForStrictErrorAndConsoleCodegen;\n  }\n  parseSelector(selector) {\n    const result = parseSelector(selector);\n    visitAllSelectorParts(result, (part) => {\n      if (!this._engines.has(part.name))\n        throw this.createStacklessError(`Unknown engine "${part.name}" while parsing selector ${selector}`);\n    });\n    return result;\n  }\n  generateSelector(targetElement, options) {\n    return generateSelector(this, targetElement, options);\n  }\n  generateSelectorSimple(targetElement, options) {\n    return generateSelector(this, targetElement, { ...options, testIdAttributeName: this._testIdAttributeNameForStrictErrorAndConsoleCodegen }).selector;\n  }\n  querySelector(selector, root, strict) {\n    const result = this.querySelectorAll(selector, root);\n    if (strict && result.length > 1)\n      throw this.strictModeViolationError(selector, result);\n    this.checkDeprecatedSelectorUsage(selector, result);\n    return result[0];\n  }\n  _queryNth(elements, part) {\n    const list = [...elements];\n    let nth = +part.body;\n    if (nth === -1)\n      nth = list.length - 1;\n    return new Set(list.slice(nth, nth + 1));\n  }\n  _queryLayoutSelector(elements, part, originalRoot) {\n    const name = part.name;\n    const body = part.body;\n    const result = [];\n    const inner = this.querySelectorAll(body.parsed, originalRoot);\n    for (const element of elements) {\n      const score = layoutSelectorScore(name, element, inner, body.distance);\n      if (score !== void 0)\n        result.push({ element, score });\n    }\n    result.sort((a, b) => a.score - b.score);\n    return new Set(result.map((r) => r.element));\n  }\n  ariaSnapshot(node, options) {\n    return this.incrementalAriaSnapshot(node, options).full;\n  }\n  incrementalAriaSnapshot(node, options) {\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      throw this.createStacklessError("Can only capture aria snapshot of Element nodes.");\n    const ariaSnapshot = generateAriaTree(node, options);\n    const full = renderAriaTree(ariaSnapshot, options);\n    let incremental;\n    if (options.track) {\n      const previousSnapshot = this._lastAriaSnapshotForTrack.get(options.track);\n      if (previousSnapshot)\n        incremental = renderAriaTree(ariaSnapshot, options, previousSnapshot);\n      this._lastAriaSnapshotForTrack.set(options.track, ariaSnapshot);\n    }\n    this._lastAriaSnapshotForQuery = ariaSnapshot;\n    return { full, incremental, iframeRefs: ariaSnapshot.iframeRefs };\n  }\n  ariaSnapshotForRecorder() {\n    const tree = generateAriaTree(this.document.body, { mode: "ai" });\n    const ariaSnapshot = renderAriaTree(tree, { mode: "ai" });\n    return { ariaSnapshot, refs: tree.refs };\n  }\n  getAllElementsMatchingExpectAriaTemplate(document, template) {\n    return getAllElementsMatchingExpectAriaTemplate(document.documentElement, template);\n  }\n  querySelectorAll(selector, root) {\n    if (selector.capture !== void 0) {\n      if (selector.parts.some((part) => part.name === "nth"))\n        throw this.createStacklessError(`Can\'t query n-th element in a request with the capture.`);\n      const withHas = { parts: selector.parts.slice(0, selector.capture + 1) };\n      if (selector.capture < selector.parts.length - 1) {\n        const parsed = { parts: selector.parts.slice(selector.capture + 1) };\n        const has = { name: "internal:has", body: { parsed }, source: stringifySelector(parsed) };\n        withHas.parts.push(has);\n      }\n      return this.querySelectorAll(withHas, root);\n    }\n    if (!root["querySelectorAll"])\n      throw this.createStacklessError("Node is not queryable.");\n    if (selector.capture !== void 0) {\n      throw this.createStacklessError("Internal error: there should not be a capture in the selector.");\n    }\n    if (root.nodeType === 11 && selector.parts.length === 1 && selector.parts[0].name === "css" && selector.parts[0].source === ":scope")\n      return [root];\n    this._evaluator.begin();\n    try {\n      let roots = /* @__PURE__ */ new Set([root]);\n      for (const part of selector.parts) {\n        if (part.name === "nth") {\n          roots = this._queryNth(roots, part);\n        } else if (part.name === "internal:and") {\n          const andElements = this.querySelectorAll(part.body.parsed, root);\n          roots = new Set(andElements.filter((e) => roots.has(e)));\n        } else if (part.name === "internal:or") {\n          const orElements = this.querySelectorAll(part.body.parsed, root);\n          roots = new Set(sortInDOMOrder(/* @__PURE__ */ new Set([...roots, ...orElements])));\n        } else if (kLayoutSelectorNames.includes(part.name)) {\n          roots = this._queryLayoutSelector(roots, part, root);\n        } else {\n          const next = /* @__PURE__ */ new Set();\n          for (const root2 of roots) {\n            const all = this._queryEngineAll(part, root2);\n            for (const one of all)\n              next.add(one);\n          }\n          roots = next;\n        }\n      }\n      return [...roots];\n    } finally {\n      this._evaluator.end();\n    }\n  }\n  _queryEngineAll(part, root) {\n    const result = this._engines.get(part.name).queryAll(root, part.body);\n    for (const element of result) {\n      if (!("nodeName" in element))\n        throw this.createStacklessError(`Expected a Node but got ${Object.prototype.toString.call(element)}`);\n    }\n    return result;\n  }\n  _createAttributeEngine(attribute, shadow) {\n    const toCSS = (selector) => {\n      const css = `[${attribute}=${JSON.stringify(selector)}]`;\n      return [{ simples: [{ selector: { css, functions: [] }, combinator: "" }] }];\n    };\n    return {\n      queryAll: (root, selector) => {\n        return this._evaluator.query({ scope: root, pierceShadow: shadow }, toCSS(selector));\n      }\n    };\n  }\n  _createCSSEngine() {\n    return {\n      queryAll: (root, body) => {\n        return this._evaluator.query({ scope: root, pierceShadow: true }, body);\n      }\n    };\n  }\n  _createTextEngine(shadow, internal) {\n    const queryAll = (root, selector) => {\n      const { matcher, kind } = createTextMatcher(selector, internal);\n      const result = [];\n      let lastDidNotMatchSelf = null;\n      const appendElement = (element) => {\n        if (kind === "lax" && lastDidNotMatchSelf && lastDidNotMatchSelf.contains(element))\n          return false;\n        const matches = elementMatchesText(this._evaluator._cacheText, element, matcher);\n        if (matches === "none")\n          lastDidNotMatchSelf = element;\n        if (matches === "self" || matches === "selfAndChildren" && kind === "strict" && !internal)\n          result.push(element);\n      };\n      if (root.nodeType === Node.ELEMENT_NODE)\n        appendElement(root);\n      const elements = this._evaluator._queryCSS({ scope: root, pierceShadow: shadow }, "*");\n      for (const element of elements)\n        appendElement(element);\n      return result;\n    };\n    return { queryAll };\n  }\n  _createInternalHasTextEngine() {\n    return {\n      queryAll: (root, selector) => {\n        if (root.nodeType !== 1)\n          return [];\n        const element = root;\n        const text = elementText(this._evaluator._cacheText, element);\n        const { matcher } = createTextMatcher(selector, true);\n        return matcher(text) ? [element] : [];\n      }\n    };\n  }\n  _createInternalHasNotTextEngine() {\n    return {\n      queryAll: (root, selector) => {\n        if (root.nodeType !== 1)\n          return [];\n        const element = root;\n        const text = elementText(this._evaluator._cacheText, element);\n        const { matcher } = createTextMatcher(selector, true);\n        return matcher(text) ? [] : [element];\n      }\n    };\n  }\n  _createInternalLabelEngine() {\n    return {\n      queryAll: (root, selector) => {\n        const { matcher } = createTextMatcher(selector, true);\n        const allElements = this._evaluator._queryCSS({ scope: root, pierceShadow: true }, "*");\n        return allElements.filter((element) => {\n          return getElementLabels(this._evaluator._cacheText, element).some((label) => matcher(label));\n        });\n      }\n    };\n  }\n  _createNamedAttributeEngine() {\n    const queryAll = (root, selector) => {\n      const parsed = parseAttributeSelector(selector, true);\n      if (parsed.name || parsed.attributes.length !== 1)\n        throw new Error("Malformed attribute selector: " + selector);\n      const { name, value, caseSensitive } = parsed.attributes[0];\n      const lowerCaseValue = caseSensitive ? null : value.toLowerCase();\n      let matcher;\n      if (value instanceof RegExp)\n        matcher = (s) => !!s.match(value);\n      else if (caseSensitive)\n        matcher = (s) => s === value;\n      else\n        matcher = (s) => s.toLowerCase().includes(lowerCaseValue);\n      const elements = this._evaluator._queryCSS({ scope: root, pierceShadow: true }, `[${name}]`);\n      return elements.filter((e) => matcher(e.getAttribute(name)));\n    };\n    return { queryAll };\n  }\n  _createDescribeEngine() {\n    const queryAll = (root) => {\n      if (root.nodeType !== 1)\n        return [];\n      return [root];\n    };\n    return { queryAll };\n  }\n  _createControlEngine() {\n    return {\n      queryAll(root, body) {\n        if (body === "enter-frame")\n          return [];\n        if (body === "return-empty")\n          return [];\n        if (body === "component") {\n          if (root.nodeType !== 1)\n            return [];\n          return [root.childElementCount === 1 ? root.firstElementChild : root];\n        }\n        throw new Error(`Internal error, unknown internal:control selector ${body}`);\n      }\n    };\n  }\n  _createHasEngine() {\n    const queryAll = (root, body) => {\n      if (root.nodeType !== 1)\n        return [];\n      const has = !!this.querySelector(body.parsed, root, false);\n      return has ? [root] : [];\n    };\n    return { queryAll };\n  }\n  _createHasNotEngine() {\n    const queryAll = (root, body) => {\n      if (root.nodeType !== 1)\n        return [];\n      const has = !!this.querySelector(body.parsed, root, false);\n      return has ? [] : [root];\n    };\n    return { queryAll };\n  }\n  _createVisibleEngine() {\n    const queryAll = (root, body) => {\n      if (root.nodeType !== 1)\n        return [];\n      const visible = body === "true";\n      return isElementVisible(root) === visible ? [root] : [];\n    };\n    return { queryAll };\n  }\n  _createInternalChainEngine() {\n    const queryAll = (root, body) => {\n      return this.querySelectorAll(body.parsed, root);\n    };\n    return { queryAll };\n  }\n  extend(source, params) {\n    const constrFunction = this.window.eval(`\n    (() => {\n      const module = {};\n      ${source}\n      return module.exports.default();\n    })()`);\n    return new constrFunction(this, params);\n  }\n  async viewportRatio(element) {\n    return await new Promise((resolve) => {\n      const observer = new IntersectionObserver((entries) => {\n        resolve(entries[0].intersectionRatio);\n        observer.disconnect();\n      });\n      observer.observe(element);\n      this.utils.builtins.requestAnimationFrame(() => {\n      });\n    });\n  }\n  getElementBorderWidth(node) {\n    if (node.nodeType !== Node.ELEMENT_NODE || !node.ownerDocument || !node.ownerDocument.defaultView)\n      return { left: 0, top: 0 };\n    const style = node.ownerDocument.defaultView.getComputedStyle(node);\n    return { left: parseInt(style.borderLeftWidth || "", 10), top: parseInt(style.borderTopWidth || "", 10) };\n  }\n  describeIFrameStyle(iframe) {\n    if (!iframe.ownerDocument || !iframe.ownerDocument.defaultView)\n      return "error:notconnected";\n    const defaultView = iframe.ownerDocument.defaultView;\n    for (let e = iframe; e; e = parentElementOrShadowHost(e)) {\n      if (defaultView.getComputedStyle(e).transform !== "none")\n        return "transformed";\n    }\n    const iframeStyle = defaultView.getComputedStyle(iframe);\n    return {\n      left: parseInt(iframeStyle.borderLeftWidth || "", 10) + parseInt(iframeStyle.paddingLeft || "", 10),\n      top: parseInt(iframeStyle.borderTopWidth || "", 10) + parseInt(iframeStyle.paddingTop || "", 10)\n    };\n  }\n  retarget(node, behavior) {\n    let element = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;\n    if (!element)\n      return null;\n    if (behavior === "none")\n      return element;\n    if (!element.matches("input, textarea, select") && !element.isContentEditable) {\n      if (behavior === "button-link")\n        element = element.closest("button, [role=button], a, [role=link]") || element;\n      else\n        element = element.closest("button, [role=button], [role=checkbox], [role=radio]") || element;\n    }\n    if (behavior === "follow-label") {\n      if (!element.matches("a, input, textarea, button, select, [role=link], [role=button], [role=checkbox], [role=radio]") && !element.isContentEditable) {\n        const enclosingLabel = element.closest("label");\n        if (enclosingLabel && enclosingLabel.control)\n          element = enclosingLabel.control;\n      }\n    }\n    return element;\n  }\n  async checkElementStates(node, states) {\n    if (states.includes("stable")) {\n      const stableResult = await this._checkElementIsStable(node);\n      if (stableResult === false)\n        return { missingState: "stable" };\n      if (stableResult === "error:notconnected")\n        return "error:notconnected";\n    }\n    for (const state of states) {\n      if (state !== "stable") {\n        const result = this.elementState(node, state);\n        if (result.received === "error:notconnected")\n          return "error:notconnected";\n        if (!result.matches)\n          return { missingState: state };\n      }\n    }\n  }\n  async _checkElementIsStable(node) {\n    const continuePolling = Symbol("continuePolling");\n    let lastRect;\n    let stableRafCounter = 0;\n    let lastTime = 0;\n    const check = () => {\n      const element = this.retarget(node, "no-follow-label");\n      if (!element)\n        return "error:notconnected";\n      const time = this.utils.builtins.performance.now();\n      if (this._stableRafCount > 1 && time - lastTime < 15)\n        return continuePolling;\n      lastTime = time;\n      const clientRect = element.getBoundingClientRect();\n      const rect = { x: clientRect.top, y: clientRect.left, width: clientRect.width, height: clientRect.height };\n      if (lastRect) {\n        const samePosition = rect.x === lastRect.x && rect.y === lastRect.y && rect.width === lastRect.width && rect.height === lastRect.height;\n        if (!samePosition)\n          return false;\n        if (++stableRafCounter >= this._stableRafCount)\n          return true;\n      }\n      lastRect = rect;\n      return continuePolling;\n    };\n    let fulfill;\n    let reject;\n    const result = new Promise((f, r) => {\n      fulfill = f;\n      reject = r;\n    });\n    const raf = () => {\n      try {\n        const success = check();\n        if (success !== continuePolling)\n          fulfill(success);\n        else\n          this.utils.builtins.requestAnimationFrame(raf);\n      } catch (e) {\n        reject(e);\n      }\n    };\n    this.utils.builtins.requestAnimationFrame(raf);\n    return result;\n  }\n  _createAriaRefEngine() {\n    const queryAll = (root, selector) => {\n      var _a, _b;\n      const result = (_b = (_a = this._lastAriaSnapshotForQuery) == null ? void 0 : _a.elements) == null ? void 0 : _b.get(selector);\n      return result && result.isConnected ? [result] : [];\n    };\n    return { queryAll };\n  }\n  elementState(node, state) {\n    const element = this.retarget(node, ["visible", "hidden"].includes(state) ? "none" : "follow-label");\n    if (!element || !element.isConnected) {\n      if (state === "hidden")\n        return { matches: true, received: "hidden" };\n      return { matches: false, received: "error:notconnected" };\n    }\n    if (state === "visible" || state === "hidden") {\n      const visible = isElementVisible(element);\n      return {\n        matches: state === "visible" ? visible : !visible,\n        received: visible ? "visible" : "hidden"\n      };\n    }\n    if (state === "disabled" || state === "enabled") {\n      const disabled = getAriaDisabled(element);\n      return {\n        matches: state === "disabled" ? disabled : !disabled,\n        received: disabled ? "disabled" : "enabled"\n      };\n    }\n    if (state === "editable") {\n      const disabled = getAriaDisabled(element);\n      const readonly = getReadonly(element);\n      if (readonly === "error")\n        throw this.createStacklessError("Element is not an <input>, <textarea>, <select> or [contenteditable] and does not have a role allowing [aria-readonly]");\n      return {\n        matches: !disabled && !readonly,\n        received: disabled ? "disabled" : readonly ? "readOnly" : "editable"\n      };\n    }\n    if (state === "checked" || state === "unchecked") {\n      const need = state === "checked";\n      const checked = getCheckedWithoutMixed(element);\n      if (checked === "error")\n        throw this.createStacklessError("Not a checkbox or radio button");\n      const isRadio = element.nodeName === "INPUT" && element.type === "radio";\n      return {\n        matches: need === checked,\n        received: checked ? "checked" : "unchecked",\n        isRadio\n      };\n    }\n    if (state === "indeterminate") {\n      const checked = getCheckedAllowMixed(element);\n      if (checked === "error")\n        throw this.createStacklessError("Not a checkbox or radio button");\n      return {\n        matches: checked === "mixed",\n        received: checked === true ? "checked" : checked === false ? "unchecked" : "mixed"\n      };\n    }\n    throw this.createStacklessError(`Unexpected element state "${state}"`);\n  }\n  selectOptions(node, optionsToSelect) {\n    const element = this.retarget(node, "follow-label");\n    if (!element)\n      return "error:notconnected";\n    if (element.nodeName.toLowerCase() !== "select")\n      throw this.createStacklessError("Element is not a <select> element");\n    const select = element;\n    const options = [...select.options];\n    const selectedOptions = [];\n    let remainingOptionsToSelect = optionsToSelect.slice();\n    for (let index = 0; index < options.length; index++) {\n      const option = options[index];\n      const filter = (optionToSelect) => {\n        if (optionToSelect instanceof Node)\n          return option === optionToSelect;\n        let matches = true;\n        if (optionToSelect.valueOrLabel !== void 0)\n          matches = matches && (optionToSelect.valueOrLabel === option.value || optionToSelect.valueOrLabel === option.label);\n        if (optionToSelect.value !== void 0)\n          matches = matches && optionToSelect.value === option.value;\n        if (optionToSelect.label !== void 0)\n          matches = matches && optionToSelect.label === option.label;\n        if (optionToSelect.index !== void 0)\n          matches = matches && optionToSelect.index === index;\n        return matches;\n      };\n      if (!remainingOptionsToSelect.some(filter))\n        continue;\n      if (!this.elementState(option, "enabled").matches)\n        return "error:optionnotenabled";\n      selectedOptions.push(option);\n      if (select.multiple) {\n        remainingOptionsToSelect = remainingOptionsToSelect.filter((o) => !filter(o));\n      } else {\n        remainingOptionsToSelect = [];\n        break;\n      }\n    }\n    if (remainingOptionsToSelect.length)\n      return "error:optionsnotfound";\n    select.value = void 0;\n    selectedOptions.forEach((option) => option.selected = true);\n    select.dispatchEvent(new Event("input", { bubbles: true, composed: true }));\n    select.dispatchEvent(new Event("change", { bubbles: true }));\n    return selectedOptions.map((option) => option.value);\n  }\n  fill(node, value) {\n    const element = this.retarget(node, "follow-label");\n    if (!element)\n      return "error:notconnected";\n    if (element.nodeName.toLowerCase() === "input") {\n      const input = element;\n      const type = input.type.toLowerCase();\n      const kInputTypesToSetValue = /* @__PURE__ */ new Set(["color", "date", "time", "datetime-local", "month", "range", "week"]);\n      const kInputTypesToTypeInto = /* @__PURE__ */ new Set(["", "email", "number", "password", "search", "tel", "text", "url"]);\n      if (!kInputTypesToTypeInto.has(type) && !kInputTypesToSetValue.has(type))\n        throw this.createStacklessError(`Input of type "${type}" cannot be filled`);\n      if (type === "number") {\n        value = value.trim();\n        if (isNaN(Number(value)))\n          throw this.createStacklessError("Cannot type text into input[type=number]");\n      }\n      if (type === "color")\n        value = value.toLowerCase();\n      if (kInputTypesToSetValue.has(type)) {\n        value = value.trim();\n        input.focus();\n        input.value = value;\n        if (input.value !== value)\n          throw this.createStacklessError("Malformed value");\n        element.dispatchEvent(new Event("input", { bubbles: true, composed: true }));\n        element.dispatchEvent(new Event("change", { bubbles: true }));\n        return "done";\n      }\n    } else if (element.nodeName.toLowerCase() === "textarea") {\n    } else if (!element.isContentEditable) {\n      throw this.createStacklessError("Element is not an <input>, <textarea> or [contenteditable] element");\n    }\n    this.selectText(element);\n    return "needsinput";\n  }\n  selectText(node) {\n    const element = this.retarget(node, "follow-label");\n    if (!element)\n      return "error:notconnected";\n    if (element.nodeName.toLowerCase() === "input") {\n      const input = element;\n      input.select();\n      input.focus();\n      return "done";\n    }\n    if (element.nodeName.toLowerCase() === "textarea") {\n      const textarea = element;\n      textarea.selectionStart = 0;\n      textarea.selectionEnd = textarea.value.length;\n      textarea.focus();\n      return "done";\n    }\n    const range = element.ownerDocument.createRange();\n    range.selectNodeContents(element);\n    const selection = element.ownerDocument.defaultView.getSelection();\n    if (selection) {\n      selection.removeAllRanges();\n      selection.addRange(range);\n    }\n    element.focus();\n    return "done";\n  }\n  _activelyFocused(node) {\n    const activeElement = node.getRootNode().activeElement;\n    const isFocused = activeElement === node && !!node.ownerDocument && node.ownerDocument.hasFocus();\n    return { activeElement, isFocused };\n  }\n  focusNode(node, resetSelectionIfNotFocused) {\n    if (!node.isConnected)\n      return "error:notconnected";\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      throw this.createStacklessError("Node is not an element");\n    const { activeElement, isFocused: wasFocused } = this._activelyFocused(node);\n    if (node.isContentEditable && !wasFocused && activeElement && activeElement.blur) {\n      activeElement.blur();\n    }\n    node.focus();\n    node.focus();\n    if (resetSelectionIfNotFocused && !wasFocused && node.nodeName.toLowerCase() === "input") {\n      try {\n        const input = node;\n        input.setSelectionRange(0, 0);\n      } catch (e) {\n      }\n    }\n    return "done";\n  }\n  blurNode(node) {\n    if (!node.isConnected)\n      return "error:notconnected";\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      throw this.createStacklessError("Node is not an element");\n    node.blur();\n    return "done";\n  }\n  setInputFiles(node, payloads) {\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      return "Node is not of type HTMLElement";\n    const element = node;\n    if (element.nodeName !== "INPUT")\n      return "Not an <input> element";\n    const input = element;\n    const type = (input.getAttribute("type") || "").toLowerCase();\n    if (type !== "file")\n      return "Not an input[type=file] element";\n    const files = payloads.map((file) => {\n      const bytes = Uint8Array.from(atob(file.buffer), (c) => c.charCodeAt(0));\n      return new File([bytes], file.name, { type: file.mimeType, lastModified: file.lastModifiedMs });\n    });\n    const dt = new DataTransfer();\n    for (const file of files)\n      dt.items.add(file);\n    input.files = dt.files;\n    input.dispatchEvent(new Event("input", { bubbles: true, composed: true }));\n    input.dispatchEvent(new Event("change", { bubbles: true }));\n  }\n  expectHitTarget(hitPoint, targetElement) {\n    var _a;\n    const roots = [];\n    let parentElement = targetElement;\n    while (parentElement) {\n      const root = enclosingShadowRootOrDocument(parentElement);\n      if (!root)\n        break;\n      roots.push(root);\n      if (root.nodeType === 9)\n        break;\n      parentElement = root.host;\n    }\n    let hitElement;\n    for (let index = roots.length - 1; index >= 0; index--) {\n      const root = roots[index];\n      const elements = root.elementsFromPoint(hitPoint.x, hitPoint.y);\n      const singleElement = root.elementFromPoint(hitPoint.x, hitPoint.y);\n      if (singleElement && elements[0] && parentElementOrShadowHost(singleElement) === elements[0]) {\n        const style = this.window.getComputedStyle(singleElement);\n        if ((style == null ? void 0 : style.display) === "contents") {\n          elements.unshift(singleElement);\n        }\n      }\n      if (elements[0] && elements[0].shadowRoot === root && elements[1] === singleElement) {\n        elements.shift();\n      }\n      const innerElement = elements[0];\n      if (!innerElement)\n        break;\n      hitElement = innerElement;\n      if (index && innerElement !== roots[index - 1].host)\n        break;\n    }\n    const hitParents = [];\n    while (hitElement && hitElement !== targetElement) {\n      hitParents.push(hitElement);\n      hitElement = (_a = hitElement.assignedSlot) != null ? _a : parentElementOrShadowHost(hitElement);\n    }\n    if (hitElement === targetElement)\n      return "done";\n    const hitTargetDescription = this.previewNode(hitParents[0] || this.document.documentElement);\n    let rootHitTargetDescription;\n    let element = targetElement;\n    while (element) {\n      const index = hitParents.indexOf(element);\n      if (index !== -1) {\n        if (index > 1)\n          rootHitTargetDescription = this.previewNode(hitParents[index - 1]);\n        break;\n      }\n      element = parentElementOrShadowHost(element);\n    }\n    if (rootHitTargetDescription)\n      return { hitTargetDescription: `${hitTargetDescription} from ${rootHitTargetDescription} subtree` };\n    return { hitTargetDescription };\n  }\n  // Life of a pointer action, for example click.\n  //\n  // 0. Retry items 1 and 2 while action fails due to navigation or element being detached.\n  //   1. Resolve selector to an element.\n  //   2. Retry the following steps until the element is detached or frame navigates away.\n  //     2a. Wait for the element to be stable (not moving), visible and enabled.\n  //     2b. Scroll element into view. Scrolling alternates between:\n  //         - Built-in protocol scrolling.\n  //         - Anchoring to the top/left, bottom/right and center/center.\n  //         This is to scroll elements from under sticky headers/footers.\n  //     2c. Click point is calculated, either based on explicitly specified position,\n  //         or some visible point of the element based on protocol content quads.\n  //     2d. Click point relative to page viewport is converted relative to the target iframe\n  //         for the next hit-point check.\n  //     2e. (injected) Hit target at the click point must be a descendant of the target element.\n  //         This prevents mis-clicking in edge cases like <iframe> overlaying the target.\n  //     2f. (injected) Events specific for click (or some other action type) are intercepted on\n  //         the Window with capture:true. See 2i for details.\n  //         Note: this step is skipped for drag&drop (see inline comments for the reason).\n  //     2g. Necessary keyboard modifiers are pressed.\n  //     2h. Click event is issued (mousemove + mousedown + mouseup).\n  //     2i. (injected) For each event, we check that hit target at the event point\n  //         is a descendant of the target element.\n  //         This guarantees no race between issuing the event and handling it in the page,\n  //         for example due to layout shift.\n  //         When hit target check fails, we block all future events in the page.\n  //     2j. Keyboard modifiers are restored.\n  //     2k. (injected) Event interceptor is removed.\n  //     2l. All navigations triggered between 2g-2k are awaited to be either committed or canceled.\n  //     2m. If failed, wait for increasing amount of time before the next retry.\n  setupHitTargetInterceptor(node, action, hitPoint, blockAllEvents) {\n    const element = this.retarget(node, "button-link");\n    if (!element || !element.isConnected)\n      return "error:notconnected";\n    if (hitPoint) {\n      const preliminaryResult = this.expectHitTarget(hitPoint, element);\n      if (preliminaryResult !== "done")\n        return preliminaryResult.hitTargetDescription;\n    }\n    if (action === "drag")\n      return { stop: () => "done" };\n    const events = {\n      "hover": this._hoverHitTargetInterceptorEvents,\n      "tap": this._tapHitTargetInterceptorEvents,\n      "mouse": this._mouseHitTargetInterceptorEvents\n    }[action];\n    let result;\n    const listener = (event) => {\n      if (!events.has(event.type))\n        return;\n      if (!event.isTrusted)\n        return;\n      const point = !!this.window.TouchEvent && event instanceof this.window.TouchEvent ? event.touches[0] : event;\n      if (result === void 0 && point)\n        result = this.expectHitTarget({ x: point.clientX, y: point.clientY }, element);\n      if (blockAllEvents || result !== "done" && result !== void 0) {\n        event.preventDefault();\n        event.stopPropagation();\n        event.stopImmediatePropagation();\n      }\n    };\n    const stop = () => {\n      if (this._hitTargetInterceptor === listener)\n        this._hitTargetInterceptor = void 0;\n      return result || "done";\n    };\n    this._hitTargetInterceptor = listener;\n    return { stop };\n  }\n  dispatchEvent(node, type, eventInitObj) {\n    var _a, _b, _c, _d, _e;\n    let event;\n    const eventInit = { bubbles: true, cancelable: true, composed: true, ...eventInitObj };\n    switch (this._eventTypes.get(type)) {\n      case "mouse":\n        event = new MouseEvent(type, eventInit);\n        break;\n      case "keyboard":\n        event = new KeyboardEvent(type, eventInit);\n        break;\n      case "touch": {\n        if (this._browserName === "webkit") {\n          const createTouch = (t) => {\n            var _a2, _b2, _c2;\n            if (t instanceof Touch)\n              return t;\n            let pageX = t.pageX;\n            if (pageX === void 0 && t.clientX !== void 0)\n              pageX = t.clientX + (((_a2 = this.document.scrollingElement) == null ? void 0 : _a2.scrollLeft) || 0);\n            let pageY = t.pageY;\n            if (pageY === void 0 && t.clientY !== void 0)\n              pageY = t.clientY + (((_b2 = this.document.scrollingElement) == null ? void 0 : _b2.scrollTop) || 0);\n            return this.document.createTouch(this.window, (_c2 = t.target) != null ? _c2 : node, t.identifier, pageX, pageY, t.screenX, t.screenY, t.radiusX, t.radiusY, t.rotationAngle, t.force);\n          };\n          const createTouchList = (touches) => {\n            if (touches instanceof TouchList || !touches)\n              return touches;\n            return this.document.createTouchList(...touches.map(createTouch));\n          };\n          (_a = eventInit.target) != null ? _a : eventInit.target = node;\n          eventInit.touches = createTouchList(eventInit.touches);\n          eventInit.targetTouches = createTouchList(eventInit.targetTouches);\n          eventInit.changedTouches = createTouchList(eventInit.changedTouches);\n          event = new TouchEvent(type, eventInit);\n        } else {\n          (_b = eventInit.target) != null ? _b : eventInit.target = node;\n          eventInit.touches = (_c = eventInit.touches) == null ? void 0 : _c.map((t) => {\n            var _a2;\n            return t instanceof Touch ? t : new Touch({ ...t, target: (_a2 = t.target) != null ? _a2 : node });\n          });\n          eventInit.targetTouches = (_d = eventInit.targetTouches) == null ? void 0 : _d.map((t) => {\n            var _a2;\n            return t instanceof Touch ? t : new Touch({ ...t, target: (_a2 = t.target) != null ? _a2 : node });\n          });\n          eventInit.changedTouches = (_e = eventInit.changedTouches) == null ? void 0 : _e.map((t) => {\n            var _a2;\n            return t instanceof Touch ? t : new Touch({ ...t, target: (_a2 = t.target) != null ? _a2 : node });\n          });\n          event = new TouchEvent(type, eventInit);\n        }\n        break;\n      }\n      case "pointer":\n        event = new PointerEvent(type, eventInit);\n        break;\n      case "focus":\n        event = new FocusEvent(type, eventInit);\n        break;\n      case "drag":\n        event = new DragEvent(type, eventInit);\n        break;\n      case "wheel":\n        event = new WheelEvent(type, eventInit);\n        break;\n      case "deviceorientation":\n        try {\n          event = new DeviceOrientationEvent(type, eventInit);\n        } catch {\n          const { bubbles, cancelable, alpha, beta, gamma, absolute } = eventInit;\n          event = this.document.createEvent("DeviceOrientationEvent");\n          event.initDeviceOrientationEvent(type, bubbles, cancelable, alpha, beta, gamma, absolute);\n        }\n        break;\n      case "devicemotion":\n        try {\n          event = new DeviceMotionEvent(type, eventInit);\n        } catch {\n          const { bubbles, cancelable, acceleration, accelerationIncludingGravity, rotationRate, interval } = eventInit;\n          event = this.document.createEvent("DeviceMotionEvent");\n          event.initDeviceMotionEvent(type, bubbles, cancelable, acceleration, accelerationIncludingGravity, rotationRate, interval);\n        }\n        break;\n      default:\n        event = new Event(type, eventInit);\n        break;\n    }\n    node.dispatchEvent(event);\n  }\n  previewNode(node) {\n    if (node.nodeType === Node.TEXT_NODE)\n      return oneLine(`#text=${node.nodeValue || ""}`);\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      return oneLine(`<${node.nodeName.toLowerCase()} />`);\n    const element = node;\n    const attrs = [];\n    for (let i = 0; i < element.attributes.length; i++) {\n      const { name, value } = element.attributes[i];\n      if (name === "style")\n        continue;\n      if (!value && this._booleanAttributes.has(name))\n        attrs.push(` ${name}`);\n      else\n        attrs.push(` ${name}="${value}"`);\n    }\n    attrs.sort((a, b) => a.length - b.length);\n    const attrText = trimStringWithEllipsis(attrs.join(""), 500);\n    if (this._autoClosingTags.has(element.nodeName))\n      return oneLine(`<${element.nodeName.toLowerCase()}${attrText}/>`);\n    const children = element.childNodes;\n    let onlyText = false;\n    if (children.length <= 5) {\n      onlyText = true;\n      for (let i = 0; i < children.length; i++)\n        onlyText = onlyText && children[i].nodeType === Node.TEXT_NODE;\n    }\n    const text = onlyText ? element.textContent || "" : children.length ? "\\u2026" : "";\n    return oneLine(`<${element.nodeName.toLowerCase()}${attrText}>${trimStringWithEllipsis(text, 50)}</${element.nodeName.toLowerCase()}>`);\n  }\n  _generateSelectors(elements) {\n    this._evaluator.begin();\n    beginAriaCaches();\n    beginDOMCaches();\n    try {\n      const maxElements = this._isUtilityWorld && this._browserName === "firefox" ? 2 : 10;\n      const infos = elements.slice(0, maxElements).map((m) => ({\n        preview: this.previewNode(m),\n        selector: this.generateSelectorSimple(m)\n      }));\n      return infos.map((info, i) => `${i + 1}) ${info.preview} aka ${asLocator(this._sdkLanguage, info.selector)}`);\n    } finally {\n      endDOMCaches();\n      endAriaCaches();\n      this._evaluator.end();\n    }\n  }\n  strictModeViolationError(selector, matches) {\n    const lines = this._generateSelectors(matches).map((line) => `\n    ` + line);\n    if (lines.length < matches.length)\n      lines.push("\\n    ...");\n    return this.createStacklessError(`strict mode violation: ${asLocator(this._sdkLanguage, stringifySelector(selector))} resolved to ${matches.length} elements:${lines.join("")}\n`);\n  }\n  checkDeprecatedSelectorUsage(selector, matches) {\n    const kDeprecatedSelectors = /* @__PURE__ */ new Set([\n      "_react",\n      "_vue",\n      "xpath:light",\n      "text:light",\n      "id:light",\n      "data-testid:light",\n      "data-test-id:light",\n      "data-test:light"\n    ]);\n    if (!matches.length)\n      return;\n    const deperecated = selector.parts.find((part) => kDeprecatedSelectors.has(part.name));\n    if (!deperecated)\n      return;\n    const lines = this._generateSelectors(matches).map((line) => `\n    ` + line);\n    if (lines.length < matches.length)\n      lines.push("\\n    ...");\n    throw this.createStacklessError(`"${deperecated.name}" selector is not supported: ${asLocator(this._sdkLanguage, stringifySelector(selector))} resolved to ${matches.length} element${matches.length === 1 ? "" : "s"}:${lines.join("")}\n`);\n  }\n  createStacklessError(message) {\n    if (this._browserName === "firefox") {\n      const error2 = new Error("Error: " + message);\n      error2.stack = "";\n      return error2;\n    }\n    const error = new Error(message);\n    delete error.stack;\n    return error;\n  }\n  createHighlight() {\n    return new Highlight(this);\n  }\n  maskSelectors(selectors, color) {\n    if (this._highlight)\n      this.hideHighlight();\n    this._highlight = new Highlight(this);\n    this._highlight.install();\n    const elements = [];\n    for (const selector of selectors)\n      elements.push(this.querySelectorAll(selector, this.document.documentElement));\n    this._highlight.maskElements(elements.flat(), color);\n  }\n  highlight(selector) {\n    if (!this._highlight) {\n      this._highlight = new Highlight(this);\n      this._highlight.install();\n    }\n    this._highlight.runHighlightOnRaf(selector);\n  }\n  hideHighlight() {\n    if (this._highlight) {\n      this._highlight.uninstall();\n      delete this._highlight;\n    }\n  }\n  markTargetElements(markedElements, callId) {\n    var _a, _b;\n    if (((_a = this._markedElements) == null ? void 0 : _a.callId) !== callId)\n      this._markedElements = void 0;\n    const previous = ((_b = this._markedElements) == null ? void 0 : _b.elements) || /* @__PURE__ */ new Set();\n    const unmarkEvent = new CustomEvent("__playwright_unmark_target__", {\n      bubbles: true,\n      cancelable: true,\n      detail: callId,\n      composed: true\n    });\n    for (const element of previous) {\n      if (!markedElements.has(element))\n        element.dispatchEvent(unmarkEvent);\n    }\n    const markEvent = new CustomEvent("__playwright_mark_target__", {\n      bubbles: true,\n      cancelable: true,\n      detail: callId,\n      composed: true\n    });\n    for (const element of markedElements) {\n      if (!previous.has(element))\n        element.dispatchEvent(markEvent);\n    }\n    this._markedElements = { callId, elements: markedElements };\n  }\n  _setupGlobalListenersRemovalDetection() {\n    const customEventName = "__playwright_global_listeners_check__";\n    let seenEvent = false;\n    const handleCustomEvent = () => seenEvent = true;\n    this.window.addEventListener(customEventName, handleCustomEvent);\n    new MutationObserver((entries) => {\n      const newDocumentElement = entries.some((entry) => Array.from(entry.addedNodes).includes(this.document.documentElement));\n      if (!newDocumentElement)\n        return;\n      seenEvent = false;\n      this.window.dispatchEvent(new CustomEvent(customEventName));\n      if (seenEvent)\n        return;\n      this.window.addEventListener(customEventName, handleCustomEvent);\n      for (const callback of this.onGlobalListenersRemoved)\n        callback();\n    }).observe(this.document, { childList: true });\n  }\n  _setupHitTargetInterceptors() {\n    const listener = (event) => {\n      var _a;\n      return (_a = this._hitTargetInterceptor) == null ? void 0 : _a.call(this, event);\n    };\n    const addHitTargetInterceptorListeners = () => {\n      for (const event of this._allHitTargetInterceptorEvents)\n        this.window.addEventListener(event, listener, { capture: true, passive: false });\n    };\n    addHitTargetInterceptorListeners();\n    this.onGlobalListenersRemoved.add(addHitTargetInterceptorListeners);\n  }\n  async expect(element, options, elements) {\n    var _a, _b;\n    const isArray = options.expression === "to.have.count" || options.expression.endsWith(".array");\n    if (isArray)\n      return this.expectArray(elements, options);\n    if (!element) {\n      if (!options.isNot && options.expression === "to.be.hidden")\n        return { matches: true };\n      if (options.isNot && options.expression === "to.be.visible")\n        return { matches: false };\n      if (!options.isNot && options.expression === "to.be.detached")\n        return { matches: true };\n      if (options.isNot && options.expression === "to.be.attached")\n        return { matches: false };\n      if (options.isNot && options.expression === "to.be.in.viewport")\n        return { matches: false };\n      if (options.expression === "to.have.title" && ((_a = options == null ? void 0 : options.expectedText) == null ? void 0 : _a[0])) {\n        const matcher = new ExpectedTextMatcher(options.expectedText[0]);\n        const received = this.document.title;\n        return { received, matches: matcher.matches(received) };\n      }\n      if (options.expression === "to.have.url" && ((_b = options == null ? void 0 : options.expectedText) == null ? void 0 : _b[0])) {\n        const matcher = new ExpectedTextMatcher(options.expectedText[0]);\n        const received = this.document.location.href;\n        return { received, matches: matcher.matches(received) };\n      }\n      return { matches: options.isNot, missingReceived: true };\n    }\n    return await this.expectSingleElement(element, options);\n  }\n  async expectSingleElement(element, options) {\n    var _a, _b;\n    const expression = options.expression;\n    {\n      let result;\n      if (expression === "to.have.attribute") {\n        const hasAttribute = element.hasAttribute(options.expressionArg);\n        result = {\n          matches: hasAttribute,\n          received: hasAttribute ? "attribute present" : "attribute not present"\n        };\n      } else if (expression === "to.be.checked") {\n        const { checked, indeterminate } = options.expectedValue;\n        if (indeterminate) {\n          if (checked !== void 0)\n            throw this.createStacklessError("Can\'t assert indeterminate and checked at the same time");\n          result = this.elementState(element, "indeterminate");\n        } else {\n          result = this.elementState(element, checked === false ? "unchecked" : "checked");\n        }\n      } else if (expression === "to.be.disabled") {\n        result = this.elementState(element, "disabled");\n      } else if (expression === "to.be.editable") {\n        result = this.elementState(element, "editable");\n      } else if (expression === "to.be.readonly") {\n        result = this.elementState(element, "editable");\n        result.matches = !result.matches;\n      } else if (expression === "to.be.empty") {\n        if (element.nodeName === "INPUT" || element.nodeName === "TEXTAREA") {\n          const value = element.value;\n          result = { matches: !value, received: value ? "notEmpty" : "empty" };\n        } else {\n          const text = (_a = element.textContent) == null ? void 0 : _a.trim();\n          result = { matches: !text, received: text ? "notEmpty" : "empty" };\n        }\n      } else if (expression === "to.be.enabled") {\n        result = this.elementState(element, "enabled");\n      } else if (expression === "to.be.focused") {\n        const focused = this._activelyFocused(element).isFocused;\n        result = {\n          matches: focused,\n          received: focused ? "focused" : "inactive"\n        };\n      } else if (expression === "to.be.hidden") {\n        result = this.elementState(element, "hidden");\n      } else if (expression === "to.be.visible") {\n        result = this.elementState(element, "visible");\n      } else if (expression === "to.be.attached") {\n        result = {\n          matches: true,\n          received: "attached"\n        };\n      } else if (expression === "to.be.detached") {\n        result = {\n          matches: false,\n          received: "attached"\n        };\n      }\n      if (result) {\n        if (result.received === "error:notconnected")\n          throw this.createStacklessError("Element is not connected");\n        return result;\n      }\n    }\n    {\n      if (expression === "to.have.property") {\n        let target = element;\n        const properties = options.expressionArg.split(".");\n        for (let i = 0; i < properties.length - 1; i++) {\n          if (typeof target !== "object" || !(properties[i] in target))\n            return { received: void 0, matches: false };\n          target = target[properties[i]];\n        }\n        const received = target[properties[properties.length - 1]];\n        const matches = deepEquals(received, options.expectedValue);\n        return { received, matches };\n      }\n    }\n    {\n      if (expression === "to.be.in.viewport") {\n        const ratio = await this.viewportRatio(element);\n        return { received: `viewport ratio ${ratio}`, matches: ratio > 0 && ratio > ((_b = options.expectedNumber) != null ? _b : 0) - 1e-9 };\n      }\n    }\n    {\n      if (expression === "to.have.values") {\n        element = this.retarget(element, "follow-label");\n        if (element.nodeName !== "SELECT" || !element.multiple)\n          throw this.createStacklessError("Not a select element with a multiple attribute");\n        const received = [...element.selectedOptions].map((o) => o.value);\n        if (received.length !== options.expectedText.length)\n          return { received, matches: false };\n        return { received, matches: received.map((r, i) => new ExpectedTextMatcher(options.expectedText[i]).matches(r)).every(Boolean) };\n      }\n    }\n    {\n      if (expression === "to.match.aria") {\n        const result = matchesExpectAriaTemplate(element, options.expectedValue);\n        return {\n          received: result.received,\n          matches: !!result.matches.length\n        };\n      }\n    }\n    {\n      let received;\n      if (expression === "to.have.attribute.value") {\n        const value = element.getAttribute(options.expressionArg);\n        if (value === null)\n          return { received: null, matches: false };\n        received = value;\n      } else if (["to.have.class", "to.contain.class"].includes(expression)) {\n        if (!options.expectedText)\n          throw this.createStacklessError("Expected text is not provided for " + expression);\n        return {\n          received: element.classList.toString(),\n          matches: new ExpectedTextMatcher(options.expectedText[0]).matchesClassList(\n            this,\n            element.classList,\n            /* partial */\n            expression === "to.contain.class"\n          )\n        };\n      } else if (expression === "to.have.css") {\n        received = this.window.getComputedStyle(element).getPropertyValue(options.expressionArg);\n      } else if (expression === "to.have.id") {\n        received = element.id;\n      } else if (expression === "to.have.text") {\n        received = options.useInnerText ? element.innerText : elementText(/* @__PURE__ */ new Map(), element).full;\n      } else if (expression === "to.have.accessible.name") {\n        received = getElementAccessibleName(\n          element,\n          false\n          /* includeHidden */\n        );\n      } else if (expression === "to.have.accessible.description") {\n        received = getElementAccessibleDescription(\n          element,\n          false\n          /* includeHidden */\n        );\n      } else if (expression === "to.have.accessible.error.message") {\n        received = getElementAccessibleErrorMessage(element);\n      } else if (expression === "to.have.role") {\n        received = getAriaRole(element) || "";\n      } else if (expression === "to.have.value") {\n        element = this.retarget(element, "follow-label");\n        if (element.nodeName !== "INPUT" && element.nodeName !== "TEXTAREA" && element.nodeName !== "SELECT")\n          throw this.createStacklessError("Not an input element");\n        received = element.value;\n      }\n      if (received !== void 0 && options.expectedText) {\n        const matcher = new ExpectedTextMatcher(options.expectedText[0]);\n        return { received, matches: matcher.matches(received) };\n      }\n    }\n    throw this.createStacklessError("Unknown expect matcher: " + expression);\n  }\n  expectArray(elements, options) {\n    const expression = options.expression;\n    if (expression === "to.have.count") {\n      const received2 = elements.length;\n      const matches2 = received2 === options.expectedNumber;\n      return { received: received2, matches: matches2 };\n    }\n    if (!options.expectedText)\n      throw this.createStacklessError("Expected text is not provided for " + expression);\n    if (["to.have.class.array", "to.contain.class.array"].includes(expression)) {\n      const receivedClassLists = elements.map((e) => e.classList);\n      const received2 = receivedClassLists.map(String);\n      if (receivedClassLists.length !== options.expectedText.length)\n        return { received: received2, matches: false };\n      const matches2 = this._matchSequentially(\n        options.expectedText,\n        receivedClassLists,\n        (matcher, r) => matcher.matchesClassList(\n          this,\n          r,\n          /* partial */\n          expression === "to.contain.class.array"\n        )\n      );\n      return {\n        received: received2,\n        matches: matches2\n      };\n    }\n    if (!["to.contain.text.array", "to.have.text.array"].includes(expression))\n      throw this.createStacklessError("Unknown expect matcher: " + expression);\n    const received = elements.map((e) => options.useInnerText ? e.innerText : elementText(/* @__PURE__ */ new Map(), e).full);\n    const lengthShouldMatch = expression !== "to.contain.text.array";\n    const matchesLength = received.length === options.expectedText.length || !lengthShouldMatch;\n    if (!matchesLength)\n      return { received, matches: false };\n    const matches = this._matchSequentially(options.expectedText, received, (matcher, r) => matcher.matches(r));\n    return { received, matches };\n  }\n  _matchSequentially(expectedText, received, matchFn) {\n    const matchers = expectedText.map((e) => new ExpectedTextMatcher(e));\n    let mIndex = 0;\n    let rIndex = 0;\n    while (mIndex < matchers.length && rIndex < received.length) {\n      if (matchFn(matchers[mIndex], received[rIndex]))\n        ++mIndex;\n      ++rIndex;\n    }\n    return mIndex === matchers.length;\n  }\n};\nfunction oneLine(s) {\n  return s.replace(/\\n/g, "\\u21B5").replace(/\\t/g, "\\u21C6");\n}\nfunction cssUnquote(s) {\n  s = s.substring(1, s.length - 1);\n  if (!s.includes("\\\\"))\n    return s;\n  const r = [];\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === "\\\\" && i + 1 < s.length)\n      i++;\n    r.push(s[i++]);\n  }\n  return r.join("");\n}\nfunction createTextMatcher(selector, internal) {\n  if (selector[0] === "/" && selector.lastIndexOf("/") > 0) {\n    const lastSlash = selector.lastIndexOf("/");\n    const re = new RegExp(selector.substring(1, lastSlash), selector.substring(lastSlash + 1));\n    return { matcher: (elementText2) => re.test(elementText2.full), kind: "regex" };\n  }\n  const unquote = internal ? JSON.parse.bind(JSON) : cssUnquote;\n  let strict = false;\n  if (selector.length > 1 && selector[0] === \'"\' && selector[selector.length - 1] === \'"\') {\n    selector = unquote(selector);\n    strict = true;\n  } else if (internal && selector.length > 1 && selector[0] === \'"\' && selector[selector.length - 2] === \'"\' && selector[selector.length - 1] === "i") {\n    selector = unquote(selector.substring(0, selector.length - 1));\n    strict = false;\n  } else if (internal && selector.length > 1 && selector[0] === \'"\' && selector[selector.length - 2] === \'"\' && selector[selector.length - 1] === "s") {\n    selector = unquote(selector.substring(0, selector.length - 1));\n    strict = true;\n  } else if (selector.length > 1 && selector[0] === "\'" && selector[selector.length - 1] === "\'") {\n    selector = unquote(selector);\n    strict = true;\n  }\n  selector = normalizeWhiteSpace(selector);\n  if (strict) {\n    if (internal)\n      return { kind: "strict", matcher: (elementText2) => elementText2.normalized === selector };\n    const strictTextNodeMatcher = (elementText2) => {\n      if (!selector && !elementText2.immediate.length)\n        return true;\n      return elementText2.immediate.some((s) => normalizeWhiteSpace(s) === selector);\n    };\n    return { matcher: strictTextNodeMatcher, kind: "strict" };\n  }\n  selector = selector.toLowerCase();\n  return { kind: "lax", matcher: (elementText2) => elementText2.normalized.toLowerCase().includes(selector) };\n}\nvar ExpectedTextMatcher = class {\n  constructor(expected) {\n    this._normalizeWhiteSpace = expected.normalizeWhiteSpace;\n    this._ignoreCase = expected.ignoreCase;\n    this._string = expected.matchSubstring ? void 0 : this.normalize(expected.string);\n    this._substring = expected.matchSubstring ? this.normalize(expected.string) : void 0;\n    if (expected.regexSource) {\n      const flags = new Set((expected.regexFlags || "").split(""));\n      if (expected.ignoreCase === false)\n        flags.delete("i");\n      if (expected.ignoreCase === true)\n        flags.add("i");\n      this._regex = new RegExp(expected.regexSource, [...flags].join(""));\n    }\n  }\n  matches(text) {\n    if (!this._regex)\n      text = this.normalize(text);\n    if (this._string !== void 0)\n      return text === this._string;\n    if (this._substring !== void 0)\n      return text.includes(this._substring);\n    if (this._regex)\n      return !!this._regex.test(text);\n    return false;\n  }\n  matchesClassList(injectedScript, classList, partial) {\n    if (partial) {\n      if (this._regex)\n        throw injectedScript.createStacklessError("Partial matching does not support regular expressions. Please provide a string value.");\n      return this._string.split(/\\s+/g).filter(Boolean).every((className) => classList.contains(className));\n    }\n    return this.matches(classList.toString());\n  }\n  normalize(s) {\n    if (!s)\n      return s;\n    if (this._normalizeWhiteSpace)\n      s = normalizeWhiteSpace(s);\n    if (this._ignoreCase)\n      s = s.toLocaleLowerCase();\n    return s;\n  }\n};\nfunction deepEquals(a, b) {\n  if (a === b)\n    return true;\n  if (a && b && typeof a === "object" && typeof b === "object") {\n    if (a.constructor !== b.constructor)\n      return false;\n    if (Array.isArray(a)) {\n      if (a.length !== b.length)\n        return false;\n      for (let i = 0; i < a.length; ++i) {\n        if (!deepEquals(a[i], b[i]))\n          return false;\n      }\n      return true;\n    }\n    if (a instanceof RegExp)\n      return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf)\n      return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString)\n      return a.toString() === b.toString();\n    const keys = Object.keys(a);\n    if (keys.length !== Object.keys(b).length)\n      return false;\n    for (let i = 0; i < keys.length; ++i) {\n      if (!b.hasOwnProperty(keys[i]))\n        return false;\n    }\n    for (const key of keys) {\n      if (!deepEquals(a[key], b[key]))\n        return false;\n    }\n    return true;\n  }\n  if (typeof a === "number" && typeof b === "number")\n    return isNaN(a) && isNaN(b);\n  return false;\n}\n';
node_modules/typescript/lib/typescript.js:133459:  const numberLength = (num) => Math.log(num) * Math.LOG10E + 1;
node_modules/typescript/lib/typescript.js:133470:    const errorCountDigitsLength = Math.log(errorCount) * Math.LOG10E + 1 | 0;
node_modules/typescript/lib/pl/diagnosticMessages.generated.json:542:  "DIRECTORY_6038": "KATALOG",
node_modules/typescript/lib/pl/diagnosticMessages.generated.json:782:  "FILE_OR_DIRECTORY_6040": "PLIK LUB KATALOG",
node_modules/typescript/lib/lib.dom.d.ts:27854:    readonly SVG_MORPHOLOGY_OPERATOR_UNKNOWN: 0;
node_modules/typescript/lib/lib.dom.d.ts:27855:    readonly SVG_MORPHOLOGY_OPERATOR_ERODE: 1;
node_modules/typescript/lib/lib.dom.d.ts:27856:    readonly SVG_MORPHOLOGY_OPERATOR_DILATE: 2;
node_modules/typescript/lib/lib.dom.d.ts:27866:    readonly SVG_MORPHOLOGY_OPERATOR_UNKNOWN: 0;
node_modules/typescript/lib/lib.dom.d.ts:27867:    readonly SVG_MORPHOLOGY_OPERATOR_ERODE: 1;
node_modules/typescript/lib/lib.dom.d.ts:27868:    readonly SVG_MORPHOLOGY_OPERATOR_DILATE: 2;
node_modules/typescript/lib/it/diagnosticMessages.generated.json:1001:  "KIND_6034": "TIPOLOGIA",
node_modules/typescript/lib/_tsserver.js:309:    const envLogOptions = parseLoggingEnvironmentString(process.env.TSS_LOG);
node_modules/typescript/lib/_tsserver.js:569:    const homePath = import_os.default.homedir && import_os.default.homedir() || process.env.HOME || (process.env.LOGNAME || process.env.USER) && `/${usersDir}/${process.env.LOGNAME || process.env.USER}` || import_os.default.tmpdir();
node_modules/typescript/lib/_tsc.js:128548:  const numberLength = (num) => Math.log(num) * Math.LOG10E + 1;
node_modules/typescript/lib/_tsc.js:128559:    const errorCountDigitsLength = Math.log(errorCount) * Math.LOG10E + 1 | 0;
node_modules/typescript/lib/lib.es5.d.ts:668:    readonly LOG2E: number;
node_modules/typescript/lib/lib.es5.d.ts:670:    readonly LOG10E: number;